Okay, here is the refactored code aiming for better SOLID adherence. New files have been created for interfaces, repositories, and more focused services.

**Note:** This is a significant structural refactoring. While the *intent* is to preserve the underlying logic, thorough testing would be required to guarantee identical behavior in all edge cases compared to the original code. Dependency Injection is handled manually in `BTOApp.java` for clarity.

***

**Interfaces**

Interfaces/Repositories/IApplicationRepository.java
```java
package Interfaces.Repositories;

import java.util.List;
import java.util.Map;
import Models.BTOApplication;

public interface IApplicationRepository {
    Map<String, BTOApplication> loadApplications();
    void saveApplications(Map<String, BTOApplication> applications);
    Map<String, BTOApplication> getAllApplications(); // Added for easier access by services
}
```

Interfaces/Repositories/IEnquiryRepository.java
```java
package Interfaces.Repositories;

import java.util.List;
import Models.Enquiry;

public interface IEnquiryRepository {
    List<Enquiry> loadEnquiries();
    void saveEnquiries(List<Enquiry> enquiries);
    List<Enquiry> getAllEnquiries(); // Added for easier access by services
}
```

Interfaces/Repositories/IOfficerRegistrationRepository.java
```java
package Interfaces.Repositories;

import java.util.List;
import java.util.Map;
import Models.OfficerRegistration;

public interface IOfficerRegistrationRepository {
    Map<String, OfficerRegistration> loadOfficerRegistrations();
    void saveOfficerRegistrations(Map<String, OfficerRegistration> registrations);
    Map<String, OfficerRegistration> getAllRegistrations(); // Added for easier access by services
}
```

Interfaces/Repositories/IProjectRepository.java
```java
package Interfaces.Repositories;

import java.util.List;
import Models.Project;

public interface IProjectRepository {
    List<Project> loadProjects();
    void saveProjects(List<Project> projects);
    List<Project> getAllProjects(); // Added for easier access by services
    Project findProjectByName(String name); // Convenience method
}
```

Interfaces/Repositories/IUserRepository.java
```java
package Interfaces.Repositories;

import java.util.Map;
import Models.User;

public interface IUserRepository {
    Map<String, User> loadUsers();
    void saveUsers(Map<String, User> users);
    User findUserByNric(String nric);
    Map<String, User> getAllUsers(); // Added for easier access by services
}
```

Interfaces/Services/IApplicationService.java
```java
package Interfaces.Services;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Models.Applicant;
import Models.BTOApplication;
import Models.Project;
import Models.User;

public interface IApplicationService {
    BTOApplication findApplicationByApplicantAndProject(String nric, String projectName);
    boolean submitApplication(Applicant applicant, Project project, FlatType flatType);
    boolean requestWithdrawal(Applicant applicant);
    boolean approveWithdrawal(BTOApplication application);
    boolean rejectWithdrawal(BTOApplication application);
    boolean approveApplication(BTOApplication application);
    boolean rejectApplication(BTOApplication application);
    boolean bookFlat(BTOApplication application, Applicant applicant, Project project);
    void synchronizeApplicantStatus(Applicant applicant);
    void adjustUnitsOnLoad(); // Called after loading applications
    void removeApplicationsForProject(String projectName); // For project deletion
}
```

Interfaces/Services/IAuthService.java
```java
package Interfaces.Services;

import Models.User;

public interface IAuthService {
    User login(String nric, String password);
    boolean changePassword(User user, String oldPassword, String newPassword);
}
```

Interfaces/Services/IDataSynchronizationService.java
```java
package Interfaces.Services;

public interface IDataSynchronizationService {
    void synchronizeAllData();
}

```

Interfaces/Services/IEligibilityService.java
```java
package Interfaces.Services;

import Enums.FlatType;
import Models.HDBOfficer;
import Models.Project;
import Models.User;

public interface IEligibilityService {
     boolean canApplyForFlatType(User user, FlatType type);
     boolean isProjectVisibleToUser(User user, Project project);
     boolean canOfficerRegisterForProject(HDBOfficer officer, Project project);
     boolean isOfficerHandlingOverlappingProject(HDBOfficer officer, Project targetProject);
     Project getOfficerHandlingProject(HDBOfficer officer);
}
```

Interfaces/Services/IEnquiryService.java
```java
package Interfaces.Services;

import java.util.List;
import Models.Enquiry;
import Models.User;

public interface IEnquiryService {
    boolean submitEnquiry(User user, String projectName, String text);
    boolean replyToEnquiry(Enquiry enquiry, String replyText, User replier);
    boolean editEnquiry(Enquiry enquiry, String newText);
    boolean deleteEnquiry(Enquiry enquiry);
    List<Enquiry> getEnquiriesByApplicant(String nric);
    List<Enquiry> getEnquiriesByProject(String projectName);
    List<Enquiry> getUnrepliedEnquiriesForProjects(List<String> projectNames);
    List<Enquiry> getRepliedEnquiriesForProjects(List<String> projectNames);
    List<Enquiry> getAllEnquiries();
    void removeEnquiriesForProject(String projectName); // For project deletion
}
```

Interfaces/Services/IFilterService.java
```java
package Interfaces.Services;

import Enums.FlatType;
import Models.Project;
import java.util.List;

public interface IFilterService {
    void setLocationFilter(String location);
    void setFlatTypeFilter(FlatType flatType);
    String getLocationFilter();
    FlatType getFlatTypeFilter();
    void clearFilters();
    List<Project> applyFilters(List<Project> projects); // Applies current filters to a list
    String getCurrentFilterStatus();
}
```

Interfaces/Services/IOfficerRegistrationService.java
```java
package Interfaces.Services;

import java.util.List;
import java.util.Map;
import Models.HDBOfficer;
import Models.OfficerRegistration;
import Models.Project;

public interface IOfficerRegistrationService {
    boolean submitRegistration(HDBOfficer officer, Project project);
    boolean approveRegistration(OfficerRegistration registration, Project project);
    boolean rejectRegistration(OfficerRegistration registration);
    List<OfficerRegistration> getRegistrationsByOfficer(String nric);
    List<OfficerRegistration> getRegistrationsByProject(String projectName);
    List<OfficerRegistration> getPendingRegistrationsForProject(String projectName);
    void removeRegistrationsForProject(String projectName); // For project deletion
}
```

Interfaces/Services/IProjectDisplayService.java
```java
package Interfaces.Services;

import java.util.List;
import Models.Project;
import Models.User;

public interface IProjectDisplayService {
    void displayProjectList(List<Project> projectList, String prompt, User currentUser);
    Project selectProjectFromList(List<Project> projectList, Scanner scanner); // Scanner passed for interaction
}
```

Interfaces/Services/IProjectService.java
```java
package Interfaces.Services;

import java.util.Date;
import java.util.List;
import java.util.Map;
import Enums.FlatType;
import Models.FlatTypeDetails;
import Models.HDBManager;
import Models.Project;
import Models.User;

public interface IProjectService {
    Project findProjectByName(String name);
    List<Project> getAllProjects();
    List<Project> getVisibleProjects(User currentUser);
    List<Project> getOpenProjects(User currentUser); // Visible, Active, Eligible, Available
    List<Project> getManagedProjects(String managerNric);
    boolean createProject(String projectName, String neighborhood, Map<FlatType, FlatTypeDetails> flatTypes,
                          Date openingDate, Date closingDate, HDBManager manager, int maxOfficers);
    boolean editProjectDetails(Project project, String newNeighborhood, Map<FlatType, FlatTypeDetails> newFlatTypes,
                               Date newOpeningDate, Date newClosingDate, int newMaxSlots);
    boolean deleteProject(Project projectToDelete);
    boolean toggleProjectVisibility(Project project);
    boolean checkDateOverlap(Project p1, Project p2);
}
```

Interfaces/Services/IReportService.java
```java
package Interfaces.Services;

import java.util.List;
import Enums.FlatType;
import Enums.MaritalStatus;
import Models.BTOApplication;

public interface IReportService {
    List<BTOApplication> generateBookedApplicantReport(List<String> projectNames, FlatType filterFlatType,
                                                       MaritalStatus filterMaritalStatus, int minAge, int maxAge);
    void displayApplicantReport(List<BTOApplication> reportData, FlatType filterFlatType,
                                MaritalStatus filterMaritalStatus, int minAge, int maxAge);
}
```

**Concrete Repositories (CSV Implementation)**

Repositories/CsvApplicationRepository.java
```java
package Repositories;

import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Interfaces.Repositories.IApplicationRepository;
import Models.BTOApplication;
import Parsers.Dparse;
import Services.CsvRW; // Assuming CsvRW is in Services package
import Utils.DateUtils;

public class CsvApplicationRepository implements IApplicationRepository {
    private static final String DATA_DIR = "data";
    private static final String APPLICATION_FILE = DATA_DIR + File.separator + "applications.csv";
    private static final String[] APPLICATION_HEADER = { "ApplicationID", "ApplicantNRIC", "ProjectName",
            "FlatTypeApplied", "Status", "ApplicationDate" };
    private static final String DELIMITER = ",";

    private Map<String, BTOApplication> applicationsCache; // Cache loaded data

    public CsvApplicationRepository() {
        this.applicationsCache = null; // Load on demand
    }

    @Override
    public Map<String, BTOApplication> loadApplications() {
        if (this.applicationsCache != null) {
            return new HashMap<>(this.applicationsCache); // Return copy
        }

        Map<String, BTOApplication> loadedApplications = new HashMap<>();
        List<String[]> rawData = CsvRW.readCsv(APPLICATION_FILE, APPLICATION_HEADER.length);

        for (String[] data : rawData) {
            try {
                String appId = data[0].trim();
                if (appId.isEmpty() || loadedApplications.containsKey(appId)) {
                    if (!appId.isEmpty())
                        System.err.println("Skipping duplicate application ID in CSV: " + appId);
                    continue;
                }
                String applicantNric = data[1].trim();
                String projectName = data[2].trim();
                FlatType flatType = FlatType.fromString(data[3].trim());
                ApplicationStatus status = ApplicationStatus.valueOf(data[4].trim().toUpperCase());
                Date appDate = Dparse.parseDate(data[5].trim());

                if (appDate == null) {
                    System.err.println("Skipping application with invalid date: " + appId);
                    continue;
                }
                if (flatType == null && (status == ApplicationStatus.BOOKED || status == ApplicationStatus.SUCCESSFUL
                        || status == ApplicationStatus.PENDING_WITHDRAWAL)) {
                    System.err.println("Warning: Application " + appId + " is " + status
                            + " but has invalid/missing flat type '" + data[3] + "'. Status might be inconsistent.");
                }
                if (status == ApplicationStatus.PENDING_WITHDRAWAL) {
                     // Handled in BTOApplication constructor now
                    // System.out.println("Info: Application " + appId + " loaded with PENDING_WITHDRAWAL status.");
                }

                BTOApplication application = new BTOApplication(appId, applicantNric, projectName, flatType, status,
                        appDate);
                loadedApplications.put(application.getApplicationId(), application);

            } catch (IllegalArgumentException e) {
                System.err.println("Error parsing enum/data in application data: " + String.join(DELIMITER, data)
                        + " - " + e.getMessage());
            } catch (Exception e) {
                System.err.println("Error parsing application data line: " + String.join(DELIMITER, data) + " - "
                        + e.getMessage());
            }
        }
        this.applicationsCache = loadedApplications;
        System.out.println("Loaded " + this.applicationsCache.size() + " applications from CSV.");
        return new HashMap<>(this.applicationsCache); // Return copy
    }

    @Override
    public void saveApplications(Map<String, BTOApplication> applicationsToSave) {
        List<String[]> dataList = new ArrayList<>();
        dataList.add(APPLICATION_HEADER);
        applicationsToSave.values().stream()
                .sorted(Comparator.comparing(BTOApplication::getApplicationId))
                .forEach(app -> {
                    dataList.add(new String[] {
                            app.getApplicationId(),
                            app.getApplicantNric(),
                            app.getProjectName(),
                            app.getFlatTypeApplied() == null ? "" : app.getFlatTypeApplied().name(), // Use name() for saving consistency
                            app.getStatus().name(),
                            DateUtils.formatDate(app.getApplicationDate())
                    });
                });
        CsvRW.writeCsv(APPLICATION_FILE, dataList);
        this.applicationsCache = new HashMap<>(applicationsToSave); // Update cache
        System.out.println("Saved " + applicationsToSave.size() + " applications to CSV.");
    }

     @Override
     public Map<String, BTOApplication> getAllApplications() {
         if (this.applicationsCache == null) {
             loadApplications();
         }
         // Return a defensive copy to prevent external modification of the cache
         return new HashMap<>(this.applicationsCache);
     }
}
```

Repositories/CsvEnquiryRepository.java
```java
package Repositories;

import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import Interfaces.Repositories.IEnquiryRepository;
import Models.Enquiry;
import Parsers.Dparse;
import Services.CsvRW; // Assuming CsvRW is in Services package
import Utils.DateUtils;

public class CsvEnquiryRepository implements IEnquiryRepository {
    private static final String DATA_DIR = "data";
    private static final String DELIMITER = ",";
    private static final String ENQUIRY_FILE = DATA_DIR + File.separator + "enquiries.csv";
    private static final String[] ENQUIRY_HEADER = {"EnquiryID", "ApplicantNRIC", "ProjectName", "EnquiryText", "ReplyText", "RepliedByNRIC", "EnquiryDate", "ReplyDate"};

    private List<Enquiry> enquiriesCache;

    public CsvEnquiryRepository() {
        this.enquiriesCache = null; // Load on demand
    }

    @Override
    public List<Enquiry> loadEnquiries() {
        if (this.enquiriesCache != null) {
            return new ArrayList<>(this.enquiriesCache); // Return copy
        }

        List<Enquiry> loadedEnquiries = new ArrayList<>();
        Set<String> enquiryIds = new HashSet<>();
        List<String[]> rawData = CsvRW.readCsv(ENQUIRY_FILE, ENQUIRY_HEADER.length);

        for (String[] data : rawData) {
            try {
                String id = data[0].trim();
                 if (id.isEmpty() || !enquiryIds.add(id)) {
                     if (!id.isEmpty()) System.err.println("Skipping duplicate enquiry ID in CSV: " + id);
                    continue;
                 }
                String applicantNric = data[1].trim();
                String projectName = data[2].trim();
                String text = data[3].trim(); // Keep raw text from CSV
                String reply = data[4].trim(); // Keep raw text from CSV
                String repliedBy = data[5].trim();
                Date enqDate = Dparse.parseDate(data[6].trim());
                Date replyDate = Dparse.parseDate(data[7].trim());

                 if (text.isEmpty() || enqDate == null) {
                     System.err.println("Skipping enquiry with missing text or invalid date: " + id);
                     enquiryIds.remove(id); // Remove from set if skipped
                     continue;
                 }
                 if ((reply != null && !reply.isEmpty()) && (repliedBy == null || repliedBy.isEmpty() || replyDate == null)) {
                     System.err.println("Warning: Enquiry " + id + " seems replied but missing replier NRIC or reply date. Loading reply as is.");
                 }

                // Use the constructor that takes all fields, handles nulls/emptiness internally
                Enquiry enquiry = new Enquiry(id, applicantNric, projectName, text, reply, repliedBy, enqDate, replyDate);
                loadedEnquiries.add(enquiry);
            } catch (IllegalArgumentException e) {
                 System.err.println("Error parsing enum/data in enquiry data: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            } catch (Exception e) {
                System.err.println("Error parsing enquiry data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        }
        Enquiry.finalizeNextIdInitialization(); // Ensure nextId is set correctly after loading all
        this.enquiriesCache = loadedEnquiries;
        System.out.println("Loaded " + this.enquiriesCache.size() + " enquiries from CSV.");
        return new ArrayList<>(this.enquiriesCache); // Return copy
    }

    @Override
    public void saveEnquiries(List<Enquiry> enquiriesToSave) {
        List<String[]> dataList = new ArrayList<>();
        dataList.add(ENQUIRY_HEADER);
        enquiriesToSave.stream()
            .sorted(Comparator.comparing(Enquiry::getEnquiryId))
            .forEach(enq -> {
                dataList.add(new String[]{
                    enq.getEnquiryId(),
                    enq.getApplicantNric(),
                    enq.getProjectName(),
                    enq.getEnquiryText(), // Save raw text
                    enq.getReplyText() == null ? "" : enq.getReplyText(), // Save raw text or empty
                    enq.getRepliedByNric() == null ? "" : enq.getRepliedByNric(),
                    DateUtils.formatDate(enq.getEnquiryDate()),
                    DateUtils.formatDate(enq.getReplyDate()) // Handles null date formatting
                });
            });
        CsvRW.writeCsv(ENQUIRY_FILE, dataList);
        this.enquiriesCache = new ArrayList<>(enquiriesToSave); // Update cache
        System.out.println("Saved " + enquiriesToSave.size() + " enquiries to CSV.");
    }

     @Override
     public List<Enquiry> getAllEnquiries() {
         if (this.enquiriesCache == null) {
             loadEnquiries();
         }
         // Return a defensive copy
         return new ArrayList<>(this.enquiriesCache);
     }
}
```

Repositories/CsvOfficerRegistrationRepository.java
```java
package Repositories;

import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import Enums.OfficerRegistrationStatus;
import Interfaces.Repositories.IOfficerRegistrationRepository;
import Models.OfficerRegistration;
import Parsers.Dparse;
import Services.CsvRW; // Assuming CsvRW is in Services package
import Utils.DateUtils;

public class CsvOfficerRegistrationRepository implements IOfficerRegistrationRepository {
    private static final String DATA_DIR = "data";
    private static final String DELIMITER = ",";
    private static final String OFFICER_REGISTRATION_FILE = DATA_DIR + File.separator + "officer_registrations.csv";
    private static final String[] OFFICER_REGISTRATION_HEADER = {"RegistrationID", "OfficerNRIC", "ProjectName", "Status", "RegistrationDate"};

    private Map<String, OfficerRegistration> registrationsCache;

    public CsvOfficerRegistrationRepository() {
        this.registrationsCache = null; // Load on demand
    }

    @Override
    public Map<String, OfficerRegistration> loadOfficerRegistrations() {
        if (this.registrationsCache != null) {
            return new HashMap<>(this.registrationsCache); // Return copy
        }

        Map<String, OfficerRegistration> loadedRegistrations = new HashMap<>();
        List<String[]> rawData = CsvRW.readCsv(OFFICER_REGISTRATION_FILE, OFFICER_REGISTRATION_HEADER.length);

        for (String[] data : rawData) {
            try {
                String regId = data[0].trim();
                 if (regId.isEmpty() || loadedRegistrations.containsKey(regId)) {
                     if (!regId.isEmpty()) System.err.println("Skipping duplicate registration ID in CSV: " + regId);
                    continue;
                 }
                String officerNric = data[1].trim();
                String projectName = data[2].trim();
                OfficerRegistrationStatus status = OfficerRegistrationStatus.valueOf(data[3].trim().toUpperCase());
                Date regDate = Dparse.parseDate(data[4].trim());

                 if (regDate == null) {
                     System.err.println("Skipping registration with invalid date: " + regId);
                     return;
                 }

                 // Basic validation - deeper validation (user exists, project exists) should be in DataSyncService
                 if (officerNric.isEmpty() || projectName.isEmpty()) {
                      System.err.println("Skipping registration with empty NRIC or Project Name: " + regId);
                      return;
                 }

                OfficerRegistration registration = new OfficerRegistration(regId, officerNric, projectName, status, regDate);
                loadedRegistrations.put(registration.getRegistrationId(), registration);
            } catch (IllegalArgumentException e) {
                 System.err.println("Error parsing enum/data in officer registration data: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            } catch (Exception e) {
                System.err.println("Error parsing officer registration data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        }
        this.registrationsCache = loadedRegistrations;
        System.out.println("Loaded " + this.registrationsCache.size() + " officer registrations from CSV.");
        return new HashMap<>(this.registrationsCache); // Return copy
    }

    @Override
    public void saveOfficerRegistrations(Map<String, OfficerRegistration> registrationsToSave) {
        List<String[]> dataList = new ArrayList<>();
        dataList.add(OFFICER_REGISTRATION_HEADER);
        registrationsToSave.values().stream()
            .sorted(Comparator.comparing(OfficerRegistration::getRegistrationId))
            .forEach(reg -> {
                dataList.add(new String[]{
                    reg.getRegistrationId(),
                    reg.getOfficerNric(),
                    reg.getProjectName(),
                    reg.getStatus().name(),
                    DateUtils.formatDate(reg.getRegistrationDate())
                });
            });
        CsvRW.writeCsv(OFFICER_REGISTRATION_FILE, dataList);
        this.registrationsCache = new HashMap<>(registrationsToSave); // Update cache
        System.out.println("Saved " + registrationsToSave.size() + " officer registrations to CSV.");
    }

     @Override
     public Map<String, OfficerRegistration> getAllRegistrations() {
         if (this.registrationsCache == null) {
             loadOfficerRegistrations();
         }
         // Return a defensive copy
         return new HashMap<>(this.registrationsCache);
     }
}
```

Repositories/CsvProjectRepository.java
```java
package Repositories;

import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import Enums.FlatType;
import Interfaces.Repositories.IProjectRepository;
import Models.FlatTypeDetails;
import Models.Project;
import Parsers.Dparse;
import Parsers.LSparse;
import Services.CsvRW; // Assuming CsvRW is in Services package
import Utils.DateUtils;

public class CsvProjectRepository implements IProjectRepository {
    private static final String DELIMITER = ",";
    private static final String DATA_DIR = "data";
    private static final String LIST_DELIMITER = ";"; // Used within Officer list column
    private static final String[] PROJECT_HEADER = {
        "Project Name", "Neighborhood", "Type 1", "Number of units for Type 1", "Selling price for Type 1",
        "Type 2", "Number of units for Type 2", "Selling price for Type 2",
        "Application opening date", "Application closing date", "Manager", "Officer Slot", "Officer", "Visibility"
    };
    private static final String PROJECT_FILE = DATA_DIR + File.separator + "ProjectList.csv";

    private List<Project> projectsCache;

    public CsvProjectRepository() {
        this.projectsCache = null; // Load on demand
    }

    @Override
    public List<Project> loadProjects() {
        if (this.projectsCache != null) {
            return new ArrayList<>(this.projectsCache); // Return copy
        }

        List<Project> loadedProjects = new ArrayList<>();
        Set<String> projectNames = new HashSet<>(); // For duplicate name check
        List<String[]> rawData = CsvRW.readCsv(PROJECT_FILE, PROJECT_HEADER.length);

        for (String[] data : rawData) {
            try {
                String projectName = data[0].trim();
                if (projectName.isEmpty() || !projectNames.add(projectName.toLowerCase())) {
                     if (!projectName.isEmpty()) System.err.println("Skipping duplicate project name in CSV: " + projectName);
                    continue;
                }

                String neighborhood = data[1].trim();
                Map<FlatType, FlatTypeDetails> flatTypes = new HashMap<>();

                // Parse Flat Type 1
                if (data[2] != null && !data[2].trim().isEmpty()) {
                    FlatType type1 = FlatType.fromString(data[2].trim());
                    if (type1 != null) {
                        int units1 = Integer.parseInt(data[3].trim());
                        double price1 = Double.parseDouble(data[4].trim());
                        // Available units will be adjusted later by ApplicationService based on booked apps
                        flatTypes.put(type1, new FlatTypeDetails(units1, units1, price1));
                    } else {
                         System.err.println("Warning: Unknown flat type '" + data[2] + "' in project '" + projectName + "'. Skipping type.");
                    }
                }

                // Parse Flat Type 2
                 if (data[5] != null && !data[5].trim().isEmpty()) {
                    FlatType type2 = FlatType.fromString(data[5].trim());
                     if (type2 != null) {
                        int units2 = Integer.parseInt(data[6].trim());
                        double price2 = Double.parseDouble(data[7].trim());
                        // Available units will be adjusted later by ApplicationService based on booked apps
                        flatTypes.put(type2, new FlatTypeDetails(units2, units2, price2));
                     } else {
                          System.err.println("Warning: Unknown flat type '" + data[5] + "' in project '" + projectName + "'. Skipping type.");
                     }
                }

                Date openingDate = Dparse.parseDate(data[8].trim());
                Date closingDate = Dparse.parseDate(data[9].trim());
                String managerNric = data[10].trim();
                int officerSlots = Integer.parseInt(data[11].trim());

                // Parse Officer List using LSparse
                List<String> officers = LSparse.parseListString(data[12]);

                boolean visibility = false;
                if (data.length > 13 && data[13] != null) {
                     String visibilityStr = data[13].trim();
                     if (visibilityStr.equals("1")) {
                         visibility = true;
                     } else if (!visibilityStr.equals("0") && !visibilityStr.isEmpty()) {
                         System.err.println("Warning: Invalid visibility value '" + visibilityStr + "' for project '" + projectName + "'. Assuming false.");
                     }
                }

                // Basic Validation (deeper validation in DataSyncService)
                if (managerNric.isEmpty()) {
                    System.err.println("Warning: Project '" + projectName + "' has missing manager NRIC. Skipping project.");
                    projectNames.remove(projectName.toLowerCase()); // Remove from set if skipped
                    continue;
                }
                 if (openingDate == null || closingDate == null || closingDate.before(openingDate)) {
                     System.err.println("Warning: Project '" + projectName + "' has invalid application dates (Open: " + data[8] + ", Close: " + data[9] + "). Skipping project.");
                     projectNames.remove(projectName.toLowerCase()); // Remove from set if skipped
                     continue;
                 }
                 if (flatTypes.isEmpty()) {
                     System.err.println("Warning: Project '" + projectName + "' has no valid flat types defined. Skipping project.");
                     projectNames.remove(projectName.toLowerCase()); // Remove from set if skipped
                     continue;
                 }

                // Note: Validation of manager/officer NRICs existence and roles happens in DataSyncService
                // Note: Validation of officer count vs slots happens in DataSyncService

                Project project = new Project(projectName, neighborhood, flatTypes, openingDate, closingDate, managerNric, officerSlots, officers, visibility);
                loadedProjects.add(project);

            } catch (NumberFormatException e) {
                System.err.println("Error parsing number in project data: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            } catch (IllegalArgumentException e) {
                System.err.println("Error parsing enum/data in project data: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            } catch (Exception e) {
                 System.err.println("Unexpected error parsing project data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
                 e.printStackTrace(); // Print stack trace for unexpected errors
            }
        }
        this.projectsCache = loadedProjects;
        System.out.println("Loaded " + this.projectsCache.size() + " projects from CSV.");
        return new ArrayList<>(this.projectsCache); // Return copy
    }

    @Override
    public void saveProjects(List<Project> projectsToSave) {
        List<String[]> dataList = new ArrayList<>();
        dataList.add(PROJECT_HEADER);

        projectsToSave.stream()
            .sorted(Comparator.comparing(Project::getProjectName))
            .forEach(project -> {
                String[] data = new String[PROJECT_HEADER.length];
                data[0] = project.getProjectName();
                data[1] = project.getNeighborhood();

                // Handle flat types systematically
                FlatTypeDetails twoRoomDetails = project.getFlatTypeDetails(FlatType.TWO_ROOM);
                FlatTypeDetails threeRoomDetails = project.getFlatTypeDetails(FlatType.THREE_ROOM);

                // Type 1 (Assume 2-Room if present, else 3-Room if present, else empty)
                FlatType type1 = null;
                FlatTypeDetails details1 = null;
                if (twoRoomDetails != null) {
                    type1 = FlatType.TWO_ROOM;
                    details1 = twoRoomDetails;
                } else if (threeRoomDetails != null) {
                    type1 = FlatType.THREE_ROOM;
                    details1 = threeRoomDetails;
                }

                if (details1 != null && type1 != null) {
                    data[2] = type1.getDisplayName(); // Save display name
                    data[3] = String.valueOf(details1.getTotalUnits());
                    data[4] = String.format("%.2f", details1.getSellingPrice()); // Format price
                } else {
                    data[2] = ""; data[3] = "0"; data[4] = "0.00";
                }

                // Type 2 (Assume 3-Room if present AND different from Type 1, else empty)
                 FlatType type2 = null;
                 FlatTypeDetails details2 = null;
                 if (threeRoomDetails != null && type1 != FlatType.THREE_ROOM) {
                     type2 = FlatType.THREE_ROOM;
                     details2 = threeRoomDetails;
                 }

                if (details2 != null && type2 != null) {
                    data[5] = type2.getDisplayName(); // Save display name
                    data[6] = String.valueOf(details2.getTotalUnits());
                    data[7] = String.format("%.2f", details2.getSellingPrice()); // Format price
                } else {
                    data[5] = ""; data[6] = "0"; data[7] = "0.00";
                }


                data[8] = DateUtils.formatDate(project.getApplicationOpeningDate());
                data[9] = DateUtils.formatDate(project.getApplicationClosingDate());
                data[10] = project.getManagerNric();
                data[11] = String.valueOf(project.getMaxOfficerSlots());

                // Join officer list using the correct delimiter
                String officers = project.getApprovedOfficerNrics().stream()
                                        .collect(Collectors.joining(LIST_DELIMITER));
                data[12] = officers;

                data[13] = project.isVisible() ? "1" : "0";

                dataList.add(data);
        });
        CsvRW.writeCsv(PROJECT_FILE, dataList);
        this.projectsCache = new ArrayList<>(projectsToSave); // Update cache
        System.out.println("Saved " + projectsToSave.size() + " projects to CSV.");
    }

     @Override
     public List<Project> getAllProjects() {
         if (this.projectsCache == null) {
             loadProjects();
         }
         // Return a defensive copy
         return new ArrayList<>(this.projectsCache);
     }

     @Override
     public Project findProjectByName(String name) {
         if (name == null || name.trim().isEmpty()) return null;
         String trimmedName = name.trim();
         return getAllProjects().stream() // Use cached data via getAllProjects()
                 .filter(p -> p.getProjectName().equalsIgnoreCase(trimmedName))
                 .findFirst()
                 .orElse(null);
     }
}
```

Repositories/CsvUserRepository.java
```java
package Repositories;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import Enums.MaritalStatus;
import Enums.UserRole;
import Interfaces.Repositories.IUserRepository;
import Models.Applicant;
import Models.HDBManager;
import Models.HDBOfficer;
import Models.User;
import Services.CsvRW; // Assuming CsvRW is in Services package
import Utils.NricValidator; // Assuming NricValidator is in Utils package

public class CsvUserRepository implements IUserRepository {
    private static final String DATA_DIR = "data";
    private static final String APPLICANT_LIST_FILE = DATA_DIR + File.separator + "ApplicantList.csv";
    private static final String OFFICER_LIST_FILE = DATA_DIR + File.separator + "OfficerList.csv";
    private static final String MANAGER_LIST_FILE = DATA_DIR + File.separator + "ManagerList.csv";
    private static final String DELIMITER = ",";

    private static final String[] APPLICANT_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };
    private static final String[] OFFICER_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };
    private static final String[] MANAGER_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };

    private Map<String, User> usersCache;

    public CsvUserRepository() {
        this.usersCache = null; // Load on demand
    }

    @Override
    public Map<String, User> loadUsers() {
        if (this.usersCache != null) {
            return new HashMap<>(this.usersCache); // Return copy
        }

        Map<String, User> loadedUsers = new HashMap<>();

        // Load Applicants
        CsvRW.readCsv(APPLICANT_LIST_FILE, APPLICANT_HEADER.length).forEach(data -> {
            try {
                String nric = data[1].trim().toUpperCase(); // Standardize NRIC case
                if (!NricValidator.isValidNric(nric) || loadedUsers.containsKey(nric)) {
                    if (loadedUsers.containsKey(nric))
                        System.err.println("Duplicate NRIC found in ApplicantList: " + nric + ". Skipping duplicate.");
                    else
                        System.err.println("Invalid NRIC format in ApplicantList: " + nric + ". Skipping.");
                    return;
                }
                int age = Integer.parseInt(data[2].trim());
                MaritalStatus status = MaritalStatus.valueOf(data[3].trim().toUpperCase());
                Applicant applicant = new Applicant(nric, data[4].trim(), data[0].trim(), age, status);
                loadedUsers.put(nric, applicant);
            } catch (Exception e) {
                System.err.println(
                        "Error parsing applicant data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        });

        // Load Officers
        CsvRW.readCsv(OFFICER_LIST_FILE, OFFICER_HEADER.length).forEach(data -> {
            try {
                String nric = data[1].trim().toUpperCase(); // Standardize NRIC case
                if (!NricValidator.isValidNric(nric)) {
                    System.err.println("Invalid NRIC format in OfficerList: " + nric + ". Skipping.");
                    return;
                }
                int age = Integer.parseInt(data[2].trim());
                MaritalStatus status = MaritalStatus.valueOf(data[3].trim().toUpperCase());
                HDBOfficer officer = new HDBOfficer(nric, data[4].trim(), data[0].trim(), age, status);

                if (loadedUsers.containsKey(nric)) {
                    User existingUser = loadedUsers.get(nric);
                    if (existingUser instanceof HDBManager) {
                        System.err.println("Conflict: NRIC " + nric + " exists as Manager. Cannot overwrite with Officer role. Skipping Officer.");
                        return;
                    } else if (existingUser instanceof HDBOfficer) {
                         System.err.println("Duplicate NRIC found in OfficerList: " + nric + ". Skipping duplicate.");
                         return;
                    } else { // Existing is Applicant
                        System.out.println(
                            "Info: User " + nric + " found in Applicant list. Upgrading to Officer role.");
                    }
                }
                loadedUsers.put(nric, officer); // Add or overwrite Applicant
            } catch (Exception e) {
                System.err.println(
                        "Error parsing officer data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        });

        // Load Managers
        CsvRW.readCsv(MANAGER_LIST_FILE, MANAGER_HEADER.length).forEach(data -> {
            try {
                String nric = data[1].trim().toUpperCase(); // Standardize NRIC case
                if (!NricValidator.isValidNric(nric)) {
                    System.err.println("Invalid NRIC format in ManagerList: " + nric + ". Skipping.");
                    return;
                }
                int age = Integer.parseInt(data[2].trim());
                MaritalStatus status = MaritalStatus.valueOf(data[3].trim().toUpperCase());
                HDBManager manager = new HDBManager(nric, data[4].trim(), data[0].trim(), age, status);

                if (loadedUsers.containsKey(nric)) {
                     User existingUser = loadedUsers.get(nric);
                     if (existingUser instanceof HDBManager) {
                          System.err.println("Duplicate NRIC found in ManagerList: " + nric + ". Skipping duplicate.");
                          return;
                     } else { // Existing is Applicant or Officer
                         System.out.println("Info: User " + nric + " found in other lists. Upgrading to Manager role.");
                     }
                }
                loadedUsers.put(nric, manager); // Add or overwrite Applicant/Officer
            } catch (Exception e) {
                System.err.println(
                        "Error parsing manager data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        });

        this.usersCache = loadedUsers;
        System.out.println("Loaded " + this.usersCache.size() + " unique users from CSV.");
        return new HashMap<>(this.usersCache); // Return copy
    }

    @Override
    public void saveUsers(Map<String, User> usersToSave) {
        List<String[]> applicantData = new ArrayList<>();
        List<String[]> officerData = new ArrayList<>();
        List<String[]> managerData = new ArrayList<>();

        // Add headers
        applicantData.add(APPLICANT_HEADER);
        officerData.add(OFFICER_HEADER);
        managerData.add(MANAGER_HEADER);

        // Populate data lists based on role
        usersToSave.values().forEach(user -> {
            String[] userData = {
                    user.getName(),
                    user.getNric(),
                    String.valueOf(user.getAge()),
                    user.getMaritalStatus().name(),
                    user.getPassword() // Save current password
            };
            switch (user.getRole()) {
                case HDB_MANAGER:
                    managerData.add(userData);
                    break;
                case HDB_OFFICER:
                    // Officers are also Applicants, save in both lists if needed by design
                    // Or just save as Officer if roles are strictly hierarchical upgrade
                    // Current load logic implies upgrade, so save only in highest role file.
                    officerData.add(userData);
                    break;
                case APPLICANT:
                    // Only save here if they are *not* also an Officer or Manager
                    if (!(user instanceof HDBOfficer) && !(user instanceof HDBManager)) {
                         applicantData.add(userData);
                    }
                    break;
            }
        });

        // Write to CSV files
        CsvRW.writeCsv(APPLICANT_LIST_FILE, applicantData);
        CsvRW.writeCsv(OFFICER_LIST_FILE, officerData);
        CsvRW.writeCsv(MANAGER_LIST_FILE, managerData);

        this.usersCache = new HashMap<>(usersToSave); // Update cache
        System.out.println("Saved " + usersToSave.size() + " users to CSV.");
    }

     @Override
     public User findUserByNric(String nric) {
         if (nric == null) return null;
         if (this.usersCache == null) {
             loadUsers();
         }
         return this.usersCache.get(nric.toUpperCase()); // Use standardized case for lookup
     }

     @Override
     public Map<String, User> getAllUsers() {
         if (this.usersCache == null) {
             loadUsers();
         }
         // Return a defensive copy
         return new HashMap<>(this.usersCache);
     }
}
```

**Concrete Services**

Services/ApplicationService.java
```java
package Services;

import java.util.Map;
import java.util.Objects;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Interfaces.Repositories.IApplicationRepository;
import Interfaces.Repositories.IProjectRepository;
import Interfaces.Repositories.IUserRepository;
import Interfaces.Services.IApplicationService;
import Models.Applicant;
import Models.BTOApplication;
import Models.FlatTypeDetails;
import Models.Project;
import Models.User;
import Utils.DateUtils;

public class ApplicationService implements IApplicationService {

    private final IApplicationRepository applicationRepository;
    private final IProjectRepository projectRepository;
    private final IUserRepository userRepository; // Needed to update Applicant status

    public ApplicationService(IApplicationRepository applicationRepository, IProjectRepository projectRepository, IUserRepository userRepository) {
        this.applicationRepository = applicationRepository;
        this.projectRepository = projectRepository;
        this.userRepository = userRepository;
    }

    @Override
    public BTOApplication findApplicationByApplicantAndProject(String nric, String projectName) {
        if (nric == null || projectName == null) return null;
        String appId = BTOApplication.generateId(nric, projectName); // Use static method for consistency
        return applicationRepository.getAllApplications().get(appId);
    }

    @Override
    public boolean submitApplication(Applicant applicant, Project project, FlatType flatType) {
        if (applicant == null || project == null || flatType == null) return false;

        // Create new application
        BTOApplication newApplication = new BTOApplication(applicant.getNric(), project.getProjectName(),
                flatType, DateUtils.getCurrentDate());

        // Update application repository
        Map<String, BTOApplication> currentApplications = applicationRepository.getAllApplications();
        currentApplications.put(newApplication.getApplicationId(), newApplication);
        applicationRepository.saveApplications(currentApplications);

        // Update applicant's state
        applicant.setAppliedProjectName(project.getProjectName());
        applicant.setApplicationStatus(ApplicationStatus.PENDING);
        applicant.setBookedFlatType(null);
        // No need to save users here, assume user state is transient or saved elsewhere (e.g. on password change)
        // If user state needs persistence beyond login session, userRepository.saveUsers() would be needed.

        System.out.println("Application submitted successfully for project '" + project.getProjectName() + "' ("
                + flatType.getDisplayName() + "). Status: PENDING.");
        return true;
    }

    @Override
    public boolean requestWithdrawal(Applicant applicant) {
        if (applicant == null || applicant.getAppliedProjectName() == null) return false;

        BTOApplication application = findApplicationByApplicantAndProject(applicant.getNric(), applicant.getAppliedProjectName());
        if (application == null) {
            System.out.println("Error: Could not find the application record to request withdrawal.");
            return false;
        }

        ApplicationStatus currentStatus = application.getStatus();
        if (currentStatus != ApplicationStatus.PENDING &&
            currentStatus != ApplicationStatus.SUCCESSFUL &&
            currentStatus != ApplicationStatus.BOOKED) {
            System.out.println("Application status (" + currentStatus + ") is not eligible for withdrawal request.");
            return false;
        }

        // Update application status
        application.setStatus(ApplicationStatus.PENDING_WITHDRAWAL); // This also sets statusBeforeWithdrawal internally
        Map<String, BTOApplication> currentApplications = applicationRepository.getAllApplications();
        currentApplications.put(application.getApplicationId(), application); // Update map
        applicationRepository.saveApplications(currentApplications);

        // Update applicant's transient state
        applicant.setApplicationStatus(ApplicationStatus.PENDING_WITHDRAWAL);

        System.out.println("Withdrawal request submitted successfully. Status: PENDING_WITHDRAWAL.");
        return true;
    }

    @Override
    public boolean approveWithdrawal(BTOApplication application) {
        if (application == null || application.getStatus() != ApplicationStatus.PENDING_WITHDRAWAL) return false;

        Applicant applicant = findApplicant(application.getApplicantNric());
        if (applicant == null) return false; // Should not happen if data is consistent

        Project project = projectRepository.findProjectByName(application.getProjectName());
        // Allow withdrawal even if project is deleted? Current logic requires project for unit release.
        if (project == null) {
             System.err.println("Error: Project data not found for application "
                            + application.getApplicationId() + ". Cannot process withdrawal properly (unit release might fail).");
             // Decide whether to proceed or fail. Let's proceed but warn.
        }


        ApplicationStatus originalStatus = application.getStatusBeforeWithdrawal();
        // If original status wasn't stored (e.g., loaded from old CSV), infer it
        if (originalStatus == null) {
            originalStatus = inferStatusBeforeWithdrawal(application, applicant);
            System.out.println("Info: Inferred original status as " + originalStatus + " for withdrawal approval.");
        }

        ApplicationStatus finalStatus;
        boolean releasedUnit = false;

        if (originalStatus == ApplicationStatus.BOOKED) {
            finalStatus = ApplicationStatus.UNSUCCESSFUL; // Or maybe WITHDRAWN_PENALTY? Keep as UNSUCCESSFUL for now.
            FlatType bookedType = application.getFlatTypeApplied();
            if (bookedType != null && project != null) { // Check project exists for unit release
                FlatTypeDetails details = project.getMutableFlatTypeDetails(bookedType);
                if (details != null) {
                    if (details.incrementAvailableUnits()) {
                        releasedUnit = true;
                        System.out.println("Unit for " + bookedType.getDisplayName()
                                + " released back to project " + project.getProjectName());
                    } else {
                        System.err.println("Error: Could not increment available units for " + bookedType
                                + " during withdrawal approval (already at max?).");
                    }
                } else {
                    System.err.println("Error: Could not find flat details for " + bookedType
                            + " during withdrawal approval.");
                }
            } else if (bookedType == null) {
                System.err.println("Error: Cannot determine booked flat type to release unit during withdrawal approval.");
            }
        } else if (originalStatus == ApplicationStatus.SUCCESSFUL) {
            finalStatus = ApplicationStatus.UNSUCCESSFUL;
        } else { // Original was likely PENDING
            finalStatus = ApplicationStatus.WITHDRAWN;
        }

        // Update application
        application.setStatus(finalStatus); // This clears statusBeforeWithdrawal
        Map<String, BTOApplication> currentApplications = applicationRepository.getAllApplications();
        currentApplications.put(application.getApplicationId(), application);
        applicationRepository.saveApplications(currentApplications);

        // Update applicant state
        applicant.setApplicationStatus(finalStatus);
        applicant.setBookedFlatType(null); // Ensure booked type is cleared

        System.out.println("Withdrawal request Approved. Application status set to " + finalStatus + ".");

        // Save project if unit was released
        if (releasedUnit && project != null) {
            // Need to get the full list, update the specific project, and save the list
            List<Project> allProjects = projectRepository.getAllProjects();
            // Find the project in the list and update it (or replace it)
            for (int i = 0; i < allProjects.size(); i++) {
                if (allProjects.get(i).getProjectName().equals(project.getProjectName())) {
                    allProjects.set(i, project); // Replace with the modified project object
                    break;
                }
            }
            projectRepository.saveProjects(allProjects);
        }

        return true;
    }

    @Override
    public boolean rejectWithdrawal(BTOApplication application) {
        if (application == null || application.getStatus() != ApplicationStatus.PENDING_WITHDRAWAL) return false;

        Applicant applicant = findApplicant(application.getApplicantNric());
        if (applicant == null) return false;

        ApplicationStatus originalStatus = application.getStatusBeforeWithdrawal();
        if (originalStatus == null) {
             originalStatus = inferStatusBeforeWithdrawal(application, applicant);
             System.out.println("Info: Inferred original status as " + originalStatus + " for withdrawal rejection.");
        }

        // Revert application status
        application.setStatus(originalStatus); // This clears statusBeforeWithdrawal
        Map<String, BTOApplication> currentApplications = applicationRepository.getAllApplications();
        currentApplications.put(application.getApplicationId(), application);
        applicationRepository.saveApplications(currentApplications);

        // Revert applicant state
        applicant.setApplicationStatus(originalStatus);
        // Re-set booked flat type if original status was BOOKED
        if (originalStatus == ApplicationStatus.BOOKED) {
            applicant.setBookedFlatType(application.getFlatTypeApplied());
        }

        System.out.println("Withdrawal request Rejected. Application status reverted to " + originalStatus + ".");
        return true;
    }

    @Override
    public boolean approveApplication(BTOApplication application) {
         if (application == null || application.getStatus() != ApplicationStatus.PENDING) return false;

         Applicant applicant = findApplicant(application.getApplicantNric());
         if (applicant == null) return false;

         Project project = projectRepository.findProjectByName(application.getProjectName());
         if (project == null) {
             System.err.println("Error: Project not found for application " + application.getApplicationId());
             return false;
         }

         FlatType appliedType = application.getFlatTypeApplied();
         if (appliedType == null) {
             System.out.println("Error: Application has no specified flat type. Cannot approve.");
             return false;
         }
         FlatTypeDetails details = project.getFlatTypeDetails(appliedType);
         if (details == null) {
             System.out.println("Error: Applied flat type (" + appliedType.getDisplayName()
                     + ") does not exist in this project. Rejecting application.");
             // Automatically reject if flat type doesn't exist in project
             return rejectApplication(application);
         }

         // Check against total units, not available units here. Booking handles availability.
         long alreadySuccessfulOrBookedCount = applicationRepository.getAllApplications().values().stream()
                 .filter(a -> a.getProjectName().equals(project.getProjectName()) &&
                         a.getFlatTypeApplied() == appliedType &&
                         (a.getStatus() == ApplicationStatus.SUCCESSFUL || a.getStatus() == ApplicationStatus.BOOKED))
                 .count();

         if (alreadySuccessfulOrBookedCount < details.getTotalUnits()) {
             application.setStatus(ApplicationStatus.SUCCESSFUL);
             Map<String, BTOApplication> currentApplications = applicationRepository.getAllApplications();
             currentApplications.put(application.getApplicationId(), application);
             applicationRepository.saveApplications(currentApplications);

             applicant.setApplicationStatus(ApplicationStatus.SUCCESSFUL);

             System.out.println("Application Approved (Status: SUCCESSFUL). Applicant can now book via Officer.");
             return true;
         } else {
             System.out.println("Cannot approve. The number of successful/booked applications already meets or exceeds the total supply ("
                             + details.getTotalUnits() + ") for " + appliedType.getDisplayName() + ".");
             // Should we auto-reject here? Or just prevent approval? Let's just prevent approval.
             return false;
         }
    }

    @Override
    public boolean rejectApplication(BTOApplication application) {
        if (application == null || application.getStatus() != ApplicationStatus.PENDING) return false;

        Applicant applicant = findApplicant(application.getApplicantNric());
        if (applicant == null) return false;

        application.setStatus(ApplicationStatus.UNSUCCESSFUL);
        Map<String, BTOApplication> currentApplications = applicationRepository.getAllApplications();
        currentApplications.put(application.getApplicationId(), application);
        applicationRepository.saveApplications(currentApplications);

        applicant.setApplicationStatus(ApplicationStatus.UNSUCCESSFUL);
        applicant.setBookedFlatType(null); // Ensure booked type is cleared

        System.out.println("Application Rejected (Status: UNSUCCESSFUL).");
        return true;
    }

     @Override
     public boolean bookFlat(BTOApplication application, Applicant applicant, Project project) {
         if (application == null || applicant == null || project == null ||
             application.getStatus() != ApplicationStatus.SUCCESSFUL ||
             applicant.hasBooked()) {
             System.err.println("Error: Pre-conditions for booking not met (App Status: " + application.getStatus() + ", Applicant Booked: " + applicant.hasBooked() + ")");
             return false;
         }

         FlatType appliedFlatType = application.getFlatTypeApplied();
         if (appliedFlatType == null) {
             System.err.println("Error: Application record does not have a valid flat type specified. Cannot book.");
             return false;
         }

         // Get mutable details directly from the project object passed in
         FlatTypeDetails details = project.getMutableFlatTypeDetails(appliedFlatType);
         if (details == null || details.getAvailableUnits() <= 0) {
             System.err.println("Error: No available units for the applied flat type ("
                     + appliedFlatType.getDisplayName() + ") at this moment. Booking cannot proceed.");
             return false;
         }

         // Decrement units
         if (!details.decrementAvailableUnits()) {
             System.err.println("Error: Failed to decrement unit count (possibly became zero concurrently?). Booking cancelled.");
             // No state change occurred yet, just return false
             return false;
         }

         // Update application status
         application.setStatus(ApplicationStatus.BOOKED);
         Map<String, BTOApplication> currentApplications = applicationRepository.getAllApplications();
         currentApplications.put(application.getApplicationId(), application);
         applicationRepository.saveApplications(currentApplications);

         // Update applicant state
         applicant.setApplicationStatus(ApplicationStatus.BOOKED);
         applicant.setBookedFlatType(appliedFlatType);

         // Save the project with updated unit count
         List<Project> allProjects = projectRepository.getAllProjects();
         for (int i = 0; i < allProjects.size(); i++) {
             if (allProjects.get(i).getProjectName().equals(project.getProjectName())) {
                 allProjects.set(i, project); // Replace with the modified project object
                 break;
             }
         }
         projectRepository.saveProjects(allProjects);

         System.out.println("Booking confirmed successfully!");
         System.out.println("Applicant status updated to BOOKED.");
         System.out.println("Remaining units for " + appliedFlatType.getDisplayName() + ": " + details.getAvailableUnits());

         // Receipt generation can be triggered by the controller after this returns true
         return true;
     }

    @Override
    public void synchronizeApplicantStatus(Applicant applicant) {
        // Find the most relevant application for this applicant
        BTOApplication relevantApp = applicationRepository.getAllApplications().values().stream()
                .filter(app -> app.getApplicantNric().equals(applicant.getNric()))
                .max(Comparator.comparing((BTOApplication application) -> application.getStatus(),
                        Comparator.comparingInt(ApplicationStatus::getPriority).reversed()) // Use priority enum method
                        .thenComparing(BTOApplication::getApplicationDate).reversed())
                .orElse(null);

        if (relevantApp != null) {
            applicant.setAppliedProjectName(relevantApp.getProjectName());
            applicant.setApplicationStatus(relevantApp.getStatus());
            if (relevantApp.getStatus() == ApplicationStatus.BOOKED) {
                applicant.setBookedFlatType(relevantApp.getFlatTypeApplied());
            } else {
                applicant.setBookedFlatType(null);
            }
        } else {
            applicant.clearApplicationState();
        }
    }

     @Override
     public void adjustUnitsOnLoad() {
         Map<Project, Map<FlatType, Integer>> bookedCounts = new HashMap<>();
         List<Project> projects = projectRepository.getAllProjects(); // Get current projects

         // Count booked applications for existing projects
         applicationRepository.getAllApplications().values().stream()
             .filter(app -> app.getStatus() == ApplicationStatus.BOOKED && app.getFlatTypeApplied() != null)
             .forEach(app -> {
                 Project project = projects.stream() // Find project in the current list
                     .filter(p -> p.getProjectName().equalsIgnoreCase(app.getProjectName()))
                     .findFirst().orElse(null);
                 if (project != null) {
                     bookedCounts.computeIfAbsent(project, k -> new HashMap<>())
                                 .merge(app.getFlatTypeApplied(), 1, Integer::sum);
                 } else {
                      System.err.println("Warning (Unit Sync): Booked application " + app.getApplicationId() + " refers to non-existent project '"
                                + app.getProjectName() + "'. Unit count cannot be adjusted.");
                 }
             });

         // Adjust available units in the project objects
         final boolean[] projectModified = {false}; // Use array to modify in lambda
         bookedCounts.forEach((project, typeCounts) -> {
             typeCounts.forEach((type, count) -> {
                 FlatTypeDetails details = project.getMutableFlatTypeDetails(type);
                 if (details != null) {
                     int initialAvailable = details.getTotalUnits(); // Start from total
                     int finalAvailable = Math.max(0, initialAvailable - count);
                     if (finalAvailable != details.getAvailableUnits()) {
                         details.setAvailableUnits(finalAvailable); // Use the setter for validation
                         projectModified[0] = true;
                         System.out.println("Info (Unit Sync): Adjusted available units for " + project.getProjectName() + "/" + type.getDisplayName() + " to " + finalAvailable);
                     }
                     if (count > details.getTotalUnits()) {
                         System.err.println("Error (Unit Sync): More flats booked (" + count + ") than total units ("
                                 + details.getTotalUnits() + ") for " + project.getProjectName() + "/"
                                 + type.getDisplayName() + ". Available units set to 0.");
                     }
                 } else {
                     System.err.println("Warning (Unit Sync): Trying to adjust units for non-existent flat type "
                             + type.getDisplayName() + " in project " + project.getProjectName());
                 }
             });
         });

         // Persist projects ONLY if any were modified
         if (projectModified[0]) {
              System.out.println("Info (Unit Sync): Saving projects due to available unit adjustments.");
              projectRepository.saveProjects(projects);
         }
     }

     @Override
     public void removeApplicationsForProject(String projectName) {
         Map<String, BTOApplication> currentApps = applicationRepository.getAllApplications();
         boolean changed = currentApps.entrySet().removeIf(entry -> entry.getValue().getProjectName().equals(projectName));
         if (changed) {
             applicationRepository.saveApplications(currentApps);
             System.out.println("Removed applications associated with deleted project: " + projectName);
         }
     }


    // Helper to find applicant (avoids saving users just for status updates)
    private Applicant findApplicant(String nric) {
        User user = userRepository.findUserByNric(nric);
        if (user instanceof Applicant) {
            return (Applicant) user;
        }
        System.err.println("Error: Could not find valid Applicant record for NRIC: " + nric);
        return null;
    }

     // Helper to infer status before withdrawal if not explicitly stored
     private ApplicationStatus inferStatusBeforeWithdrawal(BTOApplication app, Applicant applicant) {
         // Check if applicant object reflects booked status (might be slightly out of sync, but best guess)
         if (applicant != null && applicant.hasBooked() && Objects.equals(app.getFlatTypeApplied(), applicant.getBookedFlatType())) {
             return ApplicationStatus.BOOKED;
         }
         // If flat type exists, assume it was at least successful (or pending if flat type is null?)
         // This is ambiguous. Let's prioritize BOOKED if applicant state suggests it, otherwise SUCCESSFUL if flat type exists.
         if (app.getFlatTypeApplied() != null) {
             return ApplicationStatus.SUCCESSFUL;
         }
         // Default fallback
         return ApplicationStatus.PENDING;
     }
}
```

Services/AuthService.java
```java
package Services;

import Interfaces.Repositories.IUserRepository;
import Interfaces.Services.IAuthService;
import Models.User;
import Utils.NricValidator;

public class AuthService implements IAuthService {
    private final IUserRepository userRepository;

    public AuthService(IUserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public User login(String nric, String password) {
        if (nric == null || password == null) return null;
        String upperNric = nric.trim().toUpperCase();

        if (!NricValidator.isValidNric(upperNric)) {
            System.out.println("Invalid NRIC format.");
            return null;
        }
        User user = userRepository.findUserByNric(upperNric); // Use repository method
        if (user != null && user.getPassword().equals(password)) {
            return user;
        } else if (user != null) {
            System.out.println("Incorrect password.");
            return null;
        } else {
            System.out.println("User NRIC not found.");
            return null;
        }
    }

    @Override
    public boolean changePassword(User user, String oldPassword, String newPassword) {
        if (user == null || oldPassword == null || newPassword == null) return false;

        // Find the user in the repository to ensure we're working with the persisted state if necessary
        // Though the passed 'user' object should be the one to modify
        User persistedUser = userRepository.findUserByNric(user.getNric());
        if (persistedUser == null || !persistedUser.getNric().equals(user.getNric())) {
             System.err.println("Error: User mismatch during password change.");
             return false;
        }


        if (user.getPassword().equals(oldPassword)) {
            if (!newPassword.isEmpty()) {
                if (newPassword.equals(oldPassword)) {
                     System.out.println("New password cannot be the same as the old password.");
                     return false;
                }
                user.setPassword(newPassword); // Update the user object passed in

                // Save the updated user state via the repository
                Map<String, User> allUsers = userRepository.getAllUsers();
                allUsers.put(user.getNric(), user); // Update the map
                userRepository.saveUsers(allUsers); // Persist changes

                System.out.println("Password changed successfully. Please log in again.");
                return true;
            } else {
                 System.out.println("New password cannot be empty.");
                 return false;
            }
        } else {
            System.out.println("Incorrect old password.");
            return false;
        }
    }
}
```

Services/DataSynchronizationService.java
```java
package Services;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import Enums.OfficerRegistrationStatus;
import Interfaces.Repositories.IApplicationRepository;
import Interfaces.Repositories.IOfficerRegistrationRepository;
import Interfaces.Repositories.IProjectRepository;
import Interfaces.Repositories.IUserRepository;
import Interfaces.Services.IApplicationService;
import Interfaces.Services.IDataSynchronizationService;
import Models.Applicant;
import Models.HDBOfficer;
import Models.OfficerRegistration;
import Models.Project;
import Models.User;

public class DataSynchronizationService implements IDataSynchronizationService {

    private final IUserRepository userRepository;
    private final IProjectRepository projectRepository;
    private final IApplicationRepository applicationRepository;
    private final IOfficerRegistrationRepository officerRegistrationRepository;
    private final IApplicationService applicationService; // Needed for adjustUnitsOnLoad and syncApplicantStatus

    public DataSynchronizationService(
            IUserRepository userRepository,
            IProjectRepository projectRepository,
            IApplicationRepository applicationRepository,
            IOfficerRegistrationRepository officerRegistrationRepository,
            IApplicationService applicationService) {
        this.userRepository = userRepository;
        this.projectRepository = projectRepository;
        this.applicationRepository = applicationRepository;
        this.officerRegistrationRepository = officerRegistrationRepository;
        this.applicationService = applicationService;
    }

    @Override
    public void synchronizeAllData() {
        System.out.println("Synchronizing loaded data...");

        // Load all data first
        Map<String, User> users = userRepository.getAllUsers();
        List<Project> projects = projectRepository.getAllProjects();
        Map<String, OfficerRegistration> registrations = officerRegistrationRepository.getAllRegistrations();
        // Applications are loaded implicitly by applicationService methods if needed

        boolean registrationsModified = false;
        boolean projectsModified = false; // Track if projects need saving due to officer list changes

        // 1. Synchronize Applicant Status based on Applications
        users.values().stream()
                .filter(u -> u instanceof Applicant)
                .map(u -> (Applicant) u)
                .forEach(applicationService::synchronizeApplicantStatus);
        // Note: User saving is typically handled elsewhere (e.g., password change)

        // 2. Synchronize Project Officer Lists and Registrations
        for (Project project : projects) {
            List<String> currentApprovedNrics = new ArrayList<>(project.getApprovedOfficerNrics()); // Modifiable copy
            List<String> nricsToRemoveFromProject = new ArrayList<>();
            boolean projectOfficerListChanged = false;

            // Check existing officers in the project list
            for (String officerNric : currentApprovedNrics) {
                User user = users.get(officerNric);
                // If user doesn't exist or is not an officer, remove from project list
                if (!(user instanceof HDBOfficer)) {
                    System.err.println("Data Sync Warning: NRIC " + officerNric + " in project '"
                            + project.getProjectName()
                            + "' approved list is not a valid HDB Officer. Removing from project.");
                    nricsToRemoveFromProject.add(officerNric);
                    projectOfficerListChanged = true;
                    continue; // Move to next NRIC in project list
                }

                // Check if a corresponding APPROVED registration exists
                String expectedRegId = OfficerRegistration.generateId(officerNric, project.getProjectName());
                OfficerRegistration existingReg = registrations.get(expectedRegId);

                if (existingReg == null || existingReg.getStatus() != OfficerRegistrationStatus.APPROVED) {
                    System.out.println("Info (Sync): Auto-creating/updating APPROVED registration for Officer " + officerNric
                            + " for Project '" + project.getProjectName() + "' based on project's officer list.");

                    // Use project opening date as a placeholder if registration date is unknown
                    Date placeholderDate = project.getApplicationOpeningDate() != null
                            ? project.getApplicationOpeningDate()
                            : new Date(0); // Epoch as fallback

                    OfficerRegistration syncReg = new OfficerRegistration(expectedRegId, officerNric,
                            project.getProjectName(), OfficerRegistrationStatus.APPROVED, placeholderDate);
                    registrations.put(syncReg.getRegistrationId(), syncReg);
                    registrationsModified = true;
                }
            }

            // Remove invalid officers found above from the project's list
            if (!nricsToRemoveFromProject.isEmpty()) {
                 project.internal_setApprovedOfficers(
                     currentApprovedNrics.stream()
                         .filter(nric -> !nricsToRemoveFromProject.contains(nric))
                         .collect(Collectors.toList())
                 );
                 projectsModified = true;
            }

             // Check officer count vs slots after cleanup
             if (project.getApprovedOfficerNrics().size() > project.getMaxOfficerSlots()) {
                  System.err.println("Warning (Sync): Project '" + project.getProjectName() + "' still has more approved officers ("+project.getApprovedOfficerNrics().size()+") than slots ("+project.getMaxOfficerSlots()+") after cleanup. Data inconsistency exists.");
             }
        }


        // 3. Check Registrations against Projects and Users
        List<String> regIdsToRemove = new ArrayList<>();
        for (OfficerRegistration reg : registrations.values()) {
            User user = users.get(reg.getOfficerNric());
            Project project = projects.stream()
                                    .filter(p -> p.getProjectName().equals(reg.getProjectName()))
                                    .findFirst().orElse(null);

            // If user doesn't exist or isn't an officer, mark registration for removal
            if (!(user instanceof HDBOfficer)) {
                 System.err.println("Data Sync Warning: Registration " + reg.getRegistrationId()
                            + " refers to invalid or non-officer NRIC: " + reg.getOfficerNric() + ". Removing registration.");
                 regIdsToRemove.add(reg.getRegistrationId());
                 registrationsModified = true;
                 continue;
            }

            // If project doesn't exist, mark registration for removal
            if (project == null) {
                 System.err.println("Data Sync Warning: Registration " + reg.getRegistrationId()
                            + " refers to a non-existent project '" + reg.getProjectName()
                            + "'. Removing registration.");
                 regIdsToRemove.add(reg.getRegistrationId());
                 registrationsModified = true;
                 continue;
            }

            // If registration is APPROVED but officer is NOT in project list, log warning (don't auto-remove registration, project list might be wrong)
            if (reg.getStatus() == OfficerRegistrationStatus.APPROVED && !project.getApprovedOfficerNrics().contains(reg.getOfficerNric())) {
                 System.err.println("Data Sync Warning: Approved registration " + reg.getRegistrationId()
                            + " exists, but officer " + reg.getOfficerNric() + " is NOT in project '"
                            + project.getProjectName()
                            + "' approved list. Data inconsistency exists.");
                 // Potential action: Change registration status to PENDING? Or just warn? Just warning for now.
            }
        }

        // Remove invalid registrations found above
        if (!regIdsToRemove.isEmpty()) {
            regIdsToRemove.forEach(registrations::remove);
            registrationsModified = true;
        }

        // 4. Adjust Project Available Units based on Booked Applications
        // This modifies project objects in the 'projects' list
        applicationService.adjustUnitsOnLoad(); // This now reads projects/apps via repositories

        // 5. Save modified data
        if (registrationsModified) {
            System.out.println("Saving updated officer registrations due to synchronization...");
            officerRegistrationRepository.saveOfficerRegistrations(registrations);
        }
        // Check if projects were modified by unit sync OR officer list cleanup
        // The adjustUnitsOnLoad method now saves projects internally if needed.
        // We only need to save if the officer list was changed here.
        if (projectsModified) {
             System.out.println("Saving updated projects due to officer list synchronization...");
             projectRepository.saveProjects(projects); // Save the potentially modified list
        }


        System.out.println("Data synchronization complete.");
    }
}
```

Services/EligibilityService.java
```java
package Services;

import java.util.Date;
import java.util.Objects;

import Enums.FlatType;
import Enums.MaritalStatus;
import Enums.OfficerRegistrationStatus;
import Enums.ApplicationStatus;
import Interfaces.Repositories.IOfficerRegistrationRepository;
import Interfaces.Repositories.IProjectRepository;
import Interfaces.Repositories.IUserRepository;
import Interfaces.Services.IEligibilityService;
import Models.Applicant;
import Models.HDBManager;
import Models.HDBOfficer;
import Models.OfficerRegistration;
import Models.Project;
import Models.User;
import Utils.DateUtils;

public class EligibilityService implements IEligibilityService {

    private final IUserRepository userRepository; // Needed for user details
    private final IOfficerRegistrationRepository officerRegistrationRepository;
    private final IProjectRepository projectRepository; // Needed to check project dates

    public EligibilityService(IUserRepository userRepository, IOfficerRegistrationRepository officerRegistrationRepository, IProjectRepository projectRepository) {
        this.userRepository = userRepository;
        this.officerRegistrationRepository = officerRegistrationRepository;
        this.projectRepository = projectRepository;
    }

    @Override
    public boolean canApplyForFlatType(User user, FlatType type) {
        if (user == null || type == null || user instanceof HDBManager) {
            return false; // Managers cannot apply
        }

        // Officers might be able to apply (handled by checks in controller/apply method)
        // This method checks basic age/marital status eligibility

        MaritalStatus maritalStatus = user.getMaritalStatus();
        int age = user.getAge();

        if (maritalStatus == MaritalStatus.SINGLE) {
            // Singles >= 35 can apply for 2-Room only
            return age >= 35 && type == FlatType.TWO_ROOM;
        } else if (maritalStatus == MaritalStatus.MARRIED) {
            // Married >= 21 can apply for 2-Room or 3-Room
            return age >= 21 && (type == FlatType.TWO_ROOM || type == FlatType.THREE_ROOM);
        }
        return false; // Should not happen if marital status is valid
    }

    @Override
    public boolean isProjectVisibleToUser(User user, Project project) {
        if (user == null || project == null) return false;

        // Managers see everything
        if (user instanceof HDBManager) return true;

        // Check explicit visibility flag
        if (project.isVisible()) return true;

        // Check if the user has an active/booked/pending-withdrawal application for this project
        if (user instanceof Applicant) {
            Applicant appUser = (Applicant) user;
            ApplicationStatus status = appUser.getApplicationStatus();
            if (project.getProjectName().equals(appUser.getAppliedProjectName()) &&
                status != null &&
                status != ApplicationStatus.UNSUCCESSFUL &&
                status != ApplicationStatus.WITHDRAWN)
            {
                return true;
            }
        }

        // Check if the user is an approved officer handling this project
        if (user instanceof HDBOfficer) {
            String regId = OfficerRegistration.generateId(user.getNric(), project.getProjectName());
            OfficerRegistration registration = officerRegistrationRepository.getAllRegistrations().get(regId);
            if (registration != null && registration.getStatus() == OfficerRegistrationStatus.APPROVED) {
                return true;
            }
        }

        // Otherwise, not visible
        return false;
    }

    @Override
    public boolean canOfficerRegisterForProject(HDBOfficer officer, Project project) {
        if (officer == null || project == null) return false;
        Date currentDate = DateUtils.getCurrentDate();

        // 1. Project must have slots and not be expired
        if (project.getRemainingOfficerSlots() <= 0 || project.isApplicationPeriodExpired(currentDate)) {
            return false;
        }

        // 2. Officer must not already have *any* registration (Pending/Approved/Rejected) for this project
        String regId = OfficerRegistration.generateId(officer.getNric(), project.getProjectName());
        if (officerRegistrationRepository.getAllRegistrations().containsKey(regId)) {
            return false;
        }

        // 3. Officer cannot have an active BTO application or pending withdrawal
        if (officer.hasActiveApplication() || officer.hasPendingWithdrawal()) {
            return false;
        }

        // 4. Project dates must not overlap with currently handled project (if any)
        Project currentlyHandling = getOfficerHandlingProject(officer);
        if (currentlyHandling != null && checkDateOverlap(project, currentlyHandling)) {
            return false;
        }

        // 5. Project dates must not overlap with other *pending* registrations
        boolean overlapsWithPending = officerRegistrationRepository.getAllRegistrations().values().stream()
            .filter(reg -> reg.getOfficerNric().equals(officer.getNric()) && reg.getStatus() == OfficerRegistrationStatus.PENDING)
            .map(reg -> projectRepository.findProjectByName(reg.getProjectName()))
            .filter(Objects::nonNull)
            .anyMatch(pendingProject -> checkDateOverlap(project, pendingProject));
        if (overlapsWithPending) {
            return false;
        }

        // 6. Officer cannot register for a project they have previously applied for (any status?)
        // Let's assume any application record prevents registration.
        boolean hasAppliedToProject = applicationRepository.getAllApplications().values().stream()
             .anyMatch(app -> app.getApplicantNric().equals(officer.getNric()) &&
                             app.getProjectName().equals(project.getProjectName()));
         if (hasAppliedToProject) {
             return false;
         }


        return true; // All checks passed
    }

     @Override
     public boolean isOfficerHandlingOverlappingProject(HDBOfficer officer, Project targetProject) {
         if (officer == null || targetProject == null) return false;

         return officerRegistrationRepository.getAllRegistrations().values().stream()
                 .filter(reg -> reg.getOfficerNric().equals(officer.getNric()) &&
                         reg.getStatus() == OfficerRegistrationStatus.APPROVED &&
                         !reg.getProjectName().equals(targetProject.getProjectName())) // Exclude target project itself
                 .map(reg -> projectRepository.findProjectByName(reg.getProjectName()))
                 .filter(Objects::nonNull) // Filter out registrations for non-existent projects
                 .anyMatch(otherProject -> checkDateOverlap(targetProject, otherProject));
     }

     @Override
     public Project getOfficerHandlingProject(HDBOfficer officer) {
         if (officer == null) return null;
         Date today = DateUtils.getCurrentDate();

         return officerRegistrationRepository.getAllRegistrations().values().stream()
                 .filter(reg -> reg.getOfficerNric().equals(officer.getNric())
                         && reg.getStatus() == OfficerRegistrationStatus.APPROVED)
                 .map(reg -> projectRepository.findProjectByName(reg.getProjectName()))
                 .filter(Objects::nonNull)
                 // Handling project must be currently active (not just approved registration)
                 .filter(p -> p.isApplicationPeriodActive(today))
                 .findFirst()
                 .orElse(null);
     }

     // Helper for date overlap check (could be in a Date utility if used more widely)
     private boolean checkDateOverlap(Project p1, Project p2) {
         if (p1 == null || p2 == null || p1.getApplicationOpeningDate() == null || p1.getApplicationClosingDate() == null
                 || p2.getApplicationOpeningDate() == null || p2.getApplicationClosingDate() == null) {
             return false; // Cannot overlap if dates are missing
         }
         // Overlap occurs if p1 starts before p2 ends AND p1 ends after p2 starts
         return !p1.getApplicationOpeningDate().after(p2.getApplicationClosingDate()) &&
                !p1.getApplicationClosingDate().before(p2.getApplicationOpeningDate());
     }
}
```

Services/EnquiryService.java
```java
package Services;

import java.util.List;
import java.util.stream.Collectors;

import Interfaces.Repositories.IEnquiryRepository;
import Interfaces.Services.IEnquiryService;
import Models.Enquiry;
import Models.User;
import Utils.DateUtils;

public class EnquiryService implements IEnquiryService {

    private final IEnquiryRepository enquiryRepository;

    public EnquiryService(IEnquiryRepository enquiryRepository) {
        this.enquiryRepository = enquiryRepository;
    }

    @Override
    public boolean submitEnquiry(User user, String projectName, String text) {
        if (user == null || projectName == null || projectName.trim().isEmpty() || text == null || text.trim().isEmpty()) {
            System.err.println("Invalid parameters for submitting enquiry.");
            return false;
        }
        // Project existence check can be done here or assumed valid based on user input context
        // Let's assume context is valid for now.

        Enquiry newEnquiry = new Enquiry(user.getNric(), projectName.trim(), text.trim(), DateUtils.getCurrentDate());

        List<Enquiry> currentEnquiries = enquiryRepository.getAllEnquiries();
        currentEnquiries.add(newEnquiry);
        enquiryRepository.saveEnquiries(currentEnquiries);

        System.out.println("Enquiry submitted successfully (ID: " + newEnquiry.getEnquiryId() + ").");
        return true;
    }

    @Override
    public boolean replyToEnquiry(Enquiry enquiry, String replyText, User replier) {
        if (enquiry == null || replyText == null || replyText.trim().isEmpty() || replier == null) {
             System.err.println("Invalid parameters for replying to enquiry.");
            return false;
        }

        if (enquiry.setReply(replyText, replier.getNric(), DateUtils.getCurrentDate())) {
            // Persist the change
            List<Enquiry> currentEnquiries = enquiryRepository.getAllEnquiries();
            // Find and update the enquiry in the list (or replace if list is mutable)
            for (int i = 0; i < currentEnquiries.size(); i++) {
                if (currentEnquiries.get(i).getEnquiryId().equals(enquiry.getEnquiryId())) {
                    currentEnquiries.set(i, enquiry);
                    break;
                }
            }
            enquiryRepository.saveEnquiries(currentEnquiries);
            System.out.println("Reply submitted successfully for enquiry ID: " + enquiry.getEnquiryId());
            return true;
        } else {
            // Error message printed within enquiry.setReply()
            return false;
        }
    }

    @Override
    public boolean editEnquiry(Enquiry enquiry, String newText) {
         if (enquiry == null || newText == null || newText.trim().isEmpty()) {
             System.err.println("Invalid parameters for editing enquiry.");
             return false;
         }
         if (enquiry.isReplied()) {
              System.err.println("Cannot edit an enquiry that has already been replied to (ID: " + enquiry.getEnquiryId() + ").");
              return false;
         }

         if (enquiry.setEnquiryText(newText)) {
             // Persist the change
             List<Enquiry> currentEnquiries = enquiryRepository.getAllEnquiries();
             for (int i = 0; i < currentEnquiries.size(); i++) {
                 if (currentEnquiries.get(i).getEnquiryId().equals(enquiry.getEnquiryId())) {
                     currentEnquiries.set(i, enquiry);
                     break;
                 }
             }
             enquiryRepository.saveEnquiries(currentEnquiries);
             System.out.println("Enquiry updated successfully.");
             return true;
         } else {
             // Error message printed within enquiry.setEnquiryText() or above
             return false;
         }
    }

    @Override
    public boolean deleteEnquiry(Enquiry enquiry) {
        if (enquiry == null) return false;

        if (enquiry.isReplied()) {
             System.err.println("Cannot delete an enquiry that has already been replied to (ID: " + enquiry.getEnquiryId() + ").");
             return false;
        }

        List<Enquiry> currentEnquiries = enquiryRepository.getAllEnquiries();
        boolean removed = currentEnquiries.removeIf(e -> e.getEnquiryId().equals(enquiry.getEnquiryId()));

        if (removed) {
            enquiryRepository.saveEnquiries(currentEnquiries);
            System.out.println("Enquiry deleted successfully.");
            return true;
        } else {
            System.err.println("Error: Failed to find enquiry " + enquiry.getEnquiryId() + " for deletion.");
            return false;
        }
    }

    @Override
    public List<Enquiry> getEnquiriesByApplicant(String nric) {
        return enquiryRepository.getAllEnquiries().stream()
                .filter(e -> e.getApplicantNric().equals(nric))
                .sorted(Comparator.comparing(Enquiry::getEnquiryDate).reversed())
                .collect(Collectors.toList());
    }

    @Override
    public List<Enquiry> getEnquiriesByProject(String projectName) {
         return enquiryRepository.getAllEnquiries().stream()
                .filter(e -> e.getProjectName().equalsIgnoreCase(projectName))
                .sorted(Comparator.comparing(Enquiry::getEnquiryDate).reversed())
                .collect(Collectors.toList());
    }

     @Override
     public List<Enquiry> getUnrepliedEnquiriesForProjects(List<String> projectNames) {
         if (projectNames == null || projectNames.isEmpty()) {
             return List.of(); // Return empty list if no projects specified
         }
         return enquiryRepository.getAllEnquiries().stream()
                 .filter(e -> projectNames.contains(e.getProjectName()) && !e.isReplied())
                 .sorted(Comparator.comparing(Enquiry::getProjectName) // Sort by project then date
                           .thenComparing(Enquiry::getEnquiryDate))
                 .collect(Collectors.toList());
     }

     @Override
     public List<Enquiry> getRepliedEnquiriesForProjects(List<String> projectNames) {
          if (projectNames == null || projectNames.isEmpty()) {
             return List.of();
         }
         return enquiryRepository.getAllEnquiries().stream()
                 .filter(e -> projectNames.contains(e.getProjectName()) && e.isReplied())
                 .sorted(Comparator.comparing(Enquiry::getProjectName)
                           .thenComparing(Enquiry::getEnquiryDate).reversed()) // Show newest replied first? Or oldest? Let's do newest.
                 .collect(Collectors.toList());
     }

     @Override
     public List<Enquiry> getAllEnquiries() {
          return enquiryRepository.getAllEnquiries().stream()
                 .sorted(Comparator.comparing(Enquiry::getProjectName)
                           .thenComparing(Enquiry::getEnquiryDate).reversed())
                 .collect(Collectors.toList());
     }

     @Override
     public void removeEnquiriesForProject(String projectName) {
         List<Enquiry> currentEnqs = enquiryRepository.getAllEnquiries();
         boolean changed = currentEnqs.removeIf(enq -> enq.getProjectName().equals(projectName));
         if (changed) {
             enquiryRepository.saveEnquiries(currentEnqs);
             System.out.println("Removed enquiries associated with deleted project: " + projectName);
         }
     }
}
```

Services/FilterService.java
```java
package Services;

import java.util.List;
import java.util.stream.Collectors;

import Enums.FlatType;
import Interfaces.Services.IFilterService;
import Models.Project;

public class FilterService implements IFilterService {

    private String filterLocation = null;
    private FlatType filterFlatType = null;

    @Override
    public void setLocationFilter(String location) {
        this.filterLocation = (location == null || location.trim().isEmpty()) ? null : location.trim();
    }

    @Override
    public void setFlatTypeFilter(FlatType flatType) {
        this.filterFlatType = flatType; // Allow null to clear
    }

    @Override
    public String getLocationFilter() {
        return filterLocation;
    }

    @Override
    public FlatType getFlatTypeFilter() {
        return filterFlatType;
    }

    @Override
    public void clearFilters() {
        this.filterLocation = null;
        this.filterFlatType = null;
        System.out.println("Filters cleared.");
    }

    @Override
    public List<Project> applyFilters(List<Project> projects) {
        if (projects == null) return List.of();

        return projects.stream()
                .filter(p -> filterLocation == null || p.getNeighborhood().equalsIgnoreCase(filterLocation))
                .filter(p -> filterFlatType == null || p.getFlatTypes().containsKey(filterFlatType))
                // Sorting is usually done *after* filtering, where the list is used
                .collect(Collectors.toList());
    }

    @Override
    public String getCurrentFilterStatus() {
         return "Location=" + (filterLocation == null ? "Any" : filterLocation)
                        + ", FlatType=" + (filterFlatType == null ? "Any" : filterFlatType);
    }
}
```

Services/OfficerRegistrationService.java
```java
package Services;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import Enums.OfficerRegistrationStatus;
import Interfaces.Repositories.IApplicationRepository;
import Interfaces.Repositories.IOfficerRegistrationRepository;
import Interfaces.Repositories.IProjectRepository;
import Interfaces.Services.IEligibilityService;
import Interfaces.Services.IOfficerRegistrationService;
import Models.HDBOfficer;
import Models.OfficerRegistration;
import Models.Project;
import Utils.DateUtils;

public class OfficerRegistrationService implements IOfficerRegistrationService {

    private final IOfficerRegistrationRepository registrationRepository;
    private final IProjectRepository projectRepository; // Needed for project access during approval
    private final IEligibilityService eligibilityService; // Needed for overlap checks

    // Constructor injection
    public OfficerRegistrationService(IOfficerRegistrationRepository registrationRepository,
                                      IProjectRepository projectRepository,
                                      IEligibilityService eligibilityService) {
        this.registrationRepository = registrationRepository;
        this.projectRepository = projectRepository;
        this.eligibilityService = eligibilityService;
    }

    @Override
    public boolean submitRegistration(HDBOfficer officer, Project project) {
        if (officer == null || project == null) return false;

        // Eligibility check should happen in the controller before calling this
        // Or could be re-checked here for safety

        OfficerRegistration newRegistration = new OfficerRegistration(officer.getNric(),
                project.getProjectName(), DateUtils.getCurrentDate());

        Map<String, OfficerRegistration> currentRegs = registrationRepository.getAllRegistrations();
        currentRegs.put(newRegistration.getRegistrationId(), newRegistration);
        registrationRepository.saveOfficerRegistrations(currentRegs);

        System.out.println("Registration request submitted for project '" + project.getProjectName()
                + "'. Status: PENDING approval by Manager.");
        return true;
    }

    @Override
    public boolean approveRegistration(OfficerRegistration registration, Project project) {
        if (registration == null || project == null || registration.getStatus() != OfficerRegistrationStatus.PENDING) {
            return false;
        }

        // Check for remaining slots
        if (project.getRemainingOfficerSlots() <= 0) {
            System.out.println("Cannot approve. No remaining officer slots for this project.");
            return false;
        }

        // Add officer to project's list *first*
        if (project.addApprovedOfficer(registration.getOfficerNric())) {
            // If successfully added to project, update registration status
            registration.setStatus(OfficerRegistrationStatus.APPROVED);

            // Save updated registration
            Map<String, OfficerRegistration> currentRegs = registrationRepository.getAllRegistrations();
            currentRegs.put(registration.getRegistrationId(), registration);
            registrationRepository.saveOfficerRegistrations(currentRegs);

            // Save updated project (with new officer in list)
            List<Project> allProjects = projectRepository.getAllProjects();
             for (int i = 0; i < allProjects.size(); i++) {
                 if (allProjects.get(i).getProjectName().equals(project.getProjectName())) {
                     allProjects.set(i, project); // Replace with the modified project object
                     break;
                 }
             }
            projectRepository.saveProjects(allProjects);


            System.out.println("Registration Approved. Officer " + registration.getOfficerNric() + " added to project.");
            return true;
        } else {
            // This might happen if the officer was somehow already in the list, or slots became zero concurrently
            System.err.println("Error: Failed to add officer " + registration.getOfficerNric() + " to project '" + project.getProjectName() + "' approved list (unexpected). Approval aborted.");
            return false;
        }
    }

    @Override
    public boolean rejectRegistration(OfficerRegistration registration) {
        if (registration == null || registration.getStatus() != OfficerRegistrationStatus.PENDING) {
            return false;
        }

        registration.setStatus(OfficerRegistrationStatus.REJECTED);

        Map<String, OfficerRegistration> currentRegs = registrationRepository.getAllRegistrations();
        currentRegs.put(registration.getRegistrationId(), registration);
        registrationRepository.saveOfficerRegistrations(currentRegs);

        System.out.println("Registration Rejected for officer " + registration.getOfficerNric() + " for project " + registration.getProjectName());
        return true;
    }

    @Override
    public List<OfficerRegistration> getRegistrationsByOfficer(String nric) {
        return registrationRepository.getAllRegistrations().values().stream()
                .filter(reg -> reg.getOfficerNric().equals(nric))
                .sorted(Comparator.comparing(OfficerRegistration::getRegistrationDate).reversed())
                .collect(Collectors.toList());
    }

    @Override
    public List<OfficerRegistration> getRegistrationsByProject(String projectName) {
        return registrationRepository.getAllRegistrations().values().stream()
                .filter(reg -> reg.getProjectName().equals(projectName))
                .sorted(Comparator.comparing(OfficerRegistration::getRegistrationDate))
                .collect(Collectors.toList());
    }

     @Override
     public List<OfficerRegistration> getPendingRegistrationsForProject(String projectName) {
          return registrationRepository.getAllRegistrations().values().stream()
                .filter(reg -> reg.getProjectName().equals(projectName) && reg.getStatus() == OfficerRegistrationStatus.PENDING)
                .sorted(Comparator.comparing(OfficerRegistration::getRegistrationDate))
                .collect(Collectors.toList());
     }

     @Override
     public void removeRegistrationsForProject(String projectName) {
         Map<String, OfficerRegistration> currentRegs = registrationRepository.getAllRegistrations();
         boolean changed = currentRegs.entrySet().removeIf(entry -> entry.getValue().getProjectName().equals(projectName));
         if (changed) {
             registrationRepository.saveOfficerRegistrations(currentRegs);
             System.out.println("Removed officer registrations associated with deleted project: " + projectName);
         }
     }
}
```

Services/ProjectDisplayService.java
```java
package Services;

import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.FlatType;
import Enums.UserRole;
import Interfaces.Services.IEligibilityService;
import Interfaces.Services.IFilterService;
import Interfaces.Services.IProjectDisplayService;
import Models.Applicant;
import Models.FlatTypeDetails;
import Models.Project;
import Models.User;
import Utils.DateUtils;

public class ProjectDisplayService implements IProjectDisplayService {

    private final IFilterService filterService; // To display current filters
    private final IEligibilityService eligibilityService; // To show eligibility marks

    public ProjectDisplayService(IFilterService filterService, IEligibilityService eligibilityService) {
        this.filterService = filterService;
        this.eligibilityService = eligibilityService;
    }

    @Override
    public void displayProjectList(List<Project> projectList, String prompt, User currentUser) {
        if (projectList == null) {
             System.out.println("No project list provided.");
             return;
        }
        if (projectList.isEmpty()) {
            System.out.println("No projects match the current criteria.");
            return;
        }

        System.out.println("\n--- " + prompt + " ---");
        System.out.println("Current Filters: " + filterService.getCurrentFilterStatus());
        System.out.println(
                "--------------------------------------------------------------------------------------------------------------------");
        System.out.printf("%-3s %-15s %-12s %-10s %-10s %-8s %-25s\n", "#", "Project Name", "Neighborhood", "Open",
                "Close", "Visible", "Flat Types (Available/Total, Price, Eligibility)");
        System.out.println(
                "--------------------------------------------------------------------------------------------------------------------");

        for (int i = 0; i < projectList.size(); i++) {
            Project p = projectList.get(i);
            // Check visibility again based on the current user, although the list might already be filtered
            boolean isVisible = eligibilityService.isProjectVisibleToUser(currentUser, p);

            System.out.printf("%-3d %-15s %-12s %-10s %-10s %-8s ",
                    i + 1,
                    p.getProjectName(),
                    p.getNeighborhood(),
                    DateUtils.formatDate(p.getApplicationOpeningDate()),
                    DateUtils.formatDate(p.getApplicationClosingDate()),
                    isVisible ? "On" : "Off"); // Display effective visibility

            // Generate flat details string
            String flatDetails = p.getFlatTypes().entrySet().stream()
                    .sorted(Map.Entry.comparingByKey()) // Sort by FlatType enum order
                    .map(entry -> {
                        FlatType type = entry.getKey();
                        FlatTypeDetails details = entry.getValue();
                        String eligibilityMark = "";
                        // Show eligibility only for Applicants/Officers (potential applicants)
                        if (currentUser != null && currentUser.getRole() != UserRole.HDB_MANAGER) {
                            if (!eligibilityService.canApplyForFlatType(currentUser, type)) {
                                eligibilityMark = " (Ineligible)";
                            } else if (details.getAvailableUnits() <= 0) {
                                eligibilityMark = " (No Units)";
                            }
                        }
                        return String.format("%s: %d/%d ($%.0f)%s",
                                type.getDisplayName(), details.getAvailableUnits(), details.getTotalUnits(),
                                details.getSellingPrice(), eligibilityMark);
                    })
                    .collect(Collectors.joining(", "));
            System.out.println(flatDetails);

            // Show manager/officer info only for Manager/Officer roles
            if (currentUser != null && currentUser.getRole() != UserRole.APPLICANT) {
                System.out.printf("%-3s %-15s %-12s %-10s %-10s %-8s %-25s\n", "", "", "", "", "", "", // Alignment placeholders
                        "Mgr: " + p.getManagerNric() + ", Officers: " + p.getApprovedOfficerNrics().size() + "/"
                                + p.getMaxOfficerSlots());
            }
            if (i < projectList.size() - 1)
                System.out.println("---"); // Separator between projects

        }
        System.out.println(
                "--------------------------------------------------------------------------------------------------------------------");
    }

    @Override
    public Project selectProjectFromList(List<Project> projectList, Scanner scanner) {
        if (projectList == null || projectList.isEmpty()) {
            return null; // No project to select
        }
        System.out.print("Enter the number of the project (or 0 to cancel): ");
        int choice;
        try {
            // Use InputUtils or handle directly
            String input = scanner.nextLine();
            choice = Integer.parseInt(input);

            if (choice == 0) {
                System.out.println("Operation cancelled.");
                return null;
            }
            if (choice >= 1 && choice <= projectList.size()) {
                return projectList.get(choice - 1); // Adjust for 0-based index
            } else {
                System.out.println("Invalid choice number.");
                return null;
            }
        } catch (NumberFormatException e) {
            System.out.println("Invalid input. Please enter a number.");
            return null;
        }
    }
}
```

Services/ProjectService.java
```java
package Services;

import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import Enums.FlatType;
import Interfaces.Repositories.IApplicationRepository;
import Interfaces.Repositories.IEnquiryRepository;
import Interfaces.Repositories.IOfficerRegistrationRepository;
import Interfaces.Repositories.IProjectRepository;
import Interfaces.Services.IApplicationService;
import Interfaces.Services.IEligibilityService;
import Interfaces.Services.IEnquiryService;
import Interfaces.Services.IFilterService;
import Interfaces.Services.IOfficerRegistrationService;
import Interfaces.Services.IProjectService;
import Models.FlatTypeDetails;
import Models.HDBManager;
import Models.Project;
import Models.User;
import Utils.DateUtils;

public class ProjectService implements IProjectService {

    private final IProjectRepository projectRepository;
    private final IEligibilityService eligibilityService; // Needed for visibility/overlap checks
    private final IFilterService filterService; // Needed to apply filters for views
    // Services needed for cascading deletes or checks
    private final IApplicationService applicationService;
    private final IOfficerRegistrationService officerRegistrationService;
    private final IEnquiryService enquiryService;


    public ProjectService(IProjectRepository projectRepository,
                          IEligibilityService eligibilityService,
                          IFilterService filterService,
                          IApplicationService applicationService,
                          IOfficerRegistrationService officerRegistrationService,
                          IEnquiryService enquiryService) {
        this.projectRepository = projectRepository;
        this.eligibilityService = eligibilityService;
        this.filterService = filterService;
        this.applicationService = applicationService;
        this.officerRegistrationService = officerRegistrationService;
        this.enquiryService = enquiryService;
    }

    @Override
    public Project findProjectByName(String name) {
        return projectRepository.findProjectByName(name); // Delegate to repository
    }

    @Override
    public List<Project> getAllProjects() {
        return projectRepository.getAllProjects().stream()
               .sorted(Comparator.comparing(Project::getProjectName))
               .collect(Collectors.toList());
    }

    @Override
    public List<Project> getVisibleProjects(User currentUser) {
        // Get all projects, then filter by visibility for the specific user
        return projectRepository.getAllProjects().stream()
                .filter(p -> eligibilityService.isProjectVisibleToUser(currentUser, p))
                .sorted(Comparator.comparing(Project::getProjectName))
                .collect(Collectors.toList());
    }

     @Override
     public List<Project> getOpenProjects(User currentUser) {
         Date currentDate = DateUtils.getCurrentDate();
         // Get all projects and apply multiple filters
         return projectRepository.getAllProjects().stream()
                 // 1. Apply general location/type filters first
                 .filter(p -> filterService.getLocationFilter() == null || p.getNeighborhood().equalsIgnoreCase(filterService.getLocationFilter()))
                 .filter(p -> filterService.getFlatTypeFilter() == null || p.getFlatTypes().containsKey(filterService.getFlatTypeFilter()))
                 // 2. Check visibility for the current user
                 .filter(p -> eligibilityService.isProjectVisibleToUser(currentUser, p))
                 // 3. Check if application period is active
                 .filter(p -> p.isApplicationPeriodActive(currentDate))
                 // 4. Check eligibility and availability for the user
                 .filter(p -> {
                     // Check if user is eligible for *any* flat type in the project
                     boolean eligibleForAny = p.getFlatTypes().keySet().stream()
                             .anyMatch(flatType -> eligibilityService.canApplyForFlatType(currentUser, flatType));
                     if (!eligibleForAny) return false;

                     // Check if there's at least one flat type they are eligible for AND has units available
                     boolean availableAndEligibleExists = p.getFlatTypes().entrySet().stream()
                             .anyMatch(entry -> eligibilityService.canApplyForFlatType(currentUser, entry.getKey())
                                     && entry.getValue().getAvailableUnits() > 0);
                     return availableAndEligibleExists;
                 })
                 .sorted(Comparator.comparing(Project::getProjectName))
                 .collect(Collectors.toList());
     }


    @Override
    public List<Project> getManagedProjects(String managerNric) {
        // Get all projects, filter by manager NRIC, then apply view filters
        List<Project> allProjects = projectRepository.getAllProjects();
        List<Project> managed = allProjects.stream()
                .filter(p -> p.getManagerNric().equals(managerNric))
                .collect(Collectors.toList());
        // Apply current view filters (location/type) to the managed list
        return filterService.applyFilters(managed).stream()
                .sorted(Comparator.comparing(Project::getProjectName))
                .collect(Collectors.toList());
    }

    @Override
    public boolean createProject(String projectName, String neighborhood, Map<FlatType, FlatTypeDetails> flatTypes,
                                 Date openingDate, Date closingDate, HDBManager manager, int maxOfficers) {

        // 1. Validate Inputs (Basic)
        if (projectName == null || projectName.trim().isEmpty() || neighborhood == null || neighborhood.trim().isEmpty() ||
            flatTypes == null || flatTypes.isEmpty() || openingDate == null || closingDate == null || manager == null || maxOfficers < 1) {
            System.err.println("Error: Invalid parameters for creating project.");
            return false;
        }
        if (closingDate.before(openingDate)) {
             System.err.println("Error: Closing date cannot be before opening date.");
             return false;
        }
        if (maxOfficers > 10) { // Assuming max 10 based on original code
             System.err.println("Error: Maximum officer slots cannot exceed 10.");
             return false;
        }


        // 2. Check for duplicate project name
        if (projectRepository.findProjectByName(projectName) != null) {
            System.err.println("Error: Project name '" + projectName + "' already exists.");
            return false;
        }

        // 3. Check for date overlap with other projects managed by the same manager
        Project proposedProject = new Project(projectName, neighborhood, flatTypes, openingDate, closingDate, manager.getNric(), maxOfficers, List.of(), false); // Temp object for overlap check
        boolean overlaps = projectRepository.getAllProjects().stream()
                .filter(p -> p.getManagerNric().equals(manager.getNric()))
                .anyMatch(existingProject -> eligibilityService.checkDateOverlap(proposedProject, existingProject)); // Use eligibility service for check

        if (overlaps) {
            System.err.println("Error: The specified application period overlaps with another project you manage.");
            return false;
        }

        // 4. Create and Save Project
        // Visibility is false by default on creation
        Project newProject = new Project(projectName.trim(), neighborhood.trim(), flatTypes, openingDate, closingDate,
                                         manager.getNric(), maxOfficers, List.of(), false); // Empty officer list initially

        List<Project> currentProjects = projectRepository.getAllProjects();
        currentProjects.add(newProject);
        projectRepository.saveProjects(currentProjects);

        System.out.println("Project '" + newProject.getProjectName() + "' created successfully. Visibility is currently OFF.");
        return true;
    }

    @Override
    public boolean editProjectDetails(Project project, String newNeighborhood, Map<FlatType, FlatTypeDetails> newFlatTypes,
                                      Date newOpeningDate, Date newClosingDate, int newMaxSlots) {
        if (project == null) return false;

        // Store original values for comparison/revert if needed
        String originalNeighborhood = project.getNeighborhood();
        Map<FlatType, FlatTypeDetails> originalFlatTypes = project.getFlatTypes(); // Get unmodifiable map
        Date originalOpening = project.getApplicationOpeningDate();
        Date originalClosing = project.getApplicationClosingDate();
        int originalMaxSlots = project.getMaxOfficerSlots();

        // Apply changes tentatively
        boolean changed = false;
        if (newNeighborhood != null && !newNeighborhood.trim().isEmpty() && !newNeighborhood.trim().equals(originalNeighborhood)) {
            project.setNeighborhood(newNeighborhood.trim());
            changed = true;
        }
        if (newFlatTypes != null && !newFlatTypes.equals(originalFlatTypes)) { // Simple equality check might work for maps if FlatTypeDetails has proper equals
            project.setFlatTypes(newFlatTypes); // Assumes FlatTypeDetails are correctly updated by caller
            changed = true;
        }

        Date finalOpening = (newOpeningDate != null) ? newOpeningDate : originalOpening;
        Date finalClosing = (newClosingDate != null) ? newClosingDate : originalClosing;
        boolean datesChanged = !finalOpening.equals(originalOpening) || !finalClosing.equals(originalClosing);
        boolean datesValid = true;

        if (datesChanged) {
            if (finalClosing.before(finalOpening)) {
                System.err.println("Error: New closing date cannot be before new opening date. Dates not updated.");
                datesValid = false;
            } else {
                // Check for overlap ONLY if dates changed and are valid relative to each other
                Project proposedProjectDates = new Project( // Temp object for check
                        project.getProjectName(), project.getNeighborhood(), project.getFlatTypes(),
                        finalOpening, finalClosing, project.getManagerNric(), project.getMaxOfficerSlots(),
                        project.getApprovedOfficerNrics(), project.isVisible());

                boolean overlaps = projectRepository.getAllProjects().stream()
                        .filter(p -> p.getManagerNric().equals(project.getManagerNric()) && !p.getProjectName().equals(project.getProjectName())) // Exclude self
                        .anyMatch(existingProject -> eligibilityService.checkDateOverlap(proposedProjectDates, existingProject));

                if (overlaps) {
                    System.err.println("Error: The new application period overlaps with another project you manage. Dates not updated.");
                    datesValid = false;
                }
            }
        }

        if (datesChanged && datesValid) {
            project.setApplicationOpeningDate(finalOpening);
            project.setApplicationClosingDate(finalClosing);
            changed = true;
            System.out.println("Application dates updated.");
        }

        if (newMaxSlots >= 0 && newMaxSlots != originalMaxSlots) {
             // setMaxOfficerSlots has internal validation against current approved count
            if (project.setMaxOfficerSlots(newMaxSlots)) {
                 changed = true;
            } else {
                 // Error message printed within setMaxOfficerSlots
            }
        }

        // If any valid change occurred, save the project list
        if (changed) {
            List<Project> allProjects = projectRepository.getAllProjects();
             for (int i = 0; i < allProjects.size(); i++) {
                 if (allProjects.get(i).getProjectName().equals(project.getProjectName())) {
                     allProjects.set(i, project); // Replace with the modified project object
                     break;
                 }
             }
            projectRepository.saveProjects(allProjects);
            System.out.println("Project details update attempt complete.");
            return true;
        } else {
            System.out.println("No changes detected or changes were invalid. Project not saved.");
            // Revert changes if necessary? The project object was modified directly.
            // If validation failed, the setters might have prevented bad state, or we might need explicit revert.
            // For simplicity, assume setters handled invalid states or the caller handles the object state.
            return false;
        }
    }

    @Override
    public boolean deleteProject(Project projectToDelete) {
        if (projectToDelete == null) return false;
        String projectName = projectToDelete.getProjectName();

        // 1. Check for active applications (using ApplicationService might be cleaner)
         boolean hasActiveApplications = applicationService.getAllApplications().values().stream()
                .anyMatch(app -> app.getProjectName().equals(projectName) &&
                        (app.getStatus() == ApplicationStatus.PENDING ||
                         app.getStatus() == ApplicationStatus.SUCCESSFUL ||
                         app.getStatus() == ApplicationStatus.BOOKED ||
                         app.getStatus() == ApplicationStatus.PENDING_WITHDRAWAL));

        // 2. Check for active officer registrations (using OfficerRegService might be cleaner)
         boolean hasActiveRegistrations = officerRegistrationService.getAllRegistrations().values().stream()
                .anyMatch(reg -> reg.getProjectName().equals(projectName) &&
                        (reg.getStatus() == OfficerRegistrationStatus.PENDING ||
                         reg.getStatus() == OfficerRegistrationStatus.APPROVED));


        if (hasActiveApplications || hasActiveRegistrations) {
            System.out.println("Error: Cannot delete project '" + projectName + "'.");
            if (hasActiveApplications)
                System.out.println("- It has active BTO applications (Pending/Successful/Booked/PendingWithdrawal).");
            if (hasActiveRegistrations)
                System.out.println("- It has active Officer registrations (Pending/Approved).");
            System.out.println("Resolve these associations before deleting.");
            return false;
        }

        // 3. Remove the project from the repository
        List<Project> currentProjects = projectRepository.getAllProjects();
        boolean removed = currentProjects.removeIf(p -> p.getProjectName().equals(projectName));

        if (removed) {
            projectRepository.saveProjects(currentProjects);
            System.out.println("Project '" + projectName + "' deleted successfully.");

            // 4. Cascade delete related data using other services
            applicationService.removeApplicationsForProject(projectName);
            officerRegistrationService.removeRegistrationsForProject(projectName);
            enquiryService.removeEnquiriesForProject(projectName);

            return true;
        } else {
            System.err.println("Error: Failed to remove project '" + projectName + "' from list (not found?).");
            return false;
        }
    }

    @Override
    public boolean toggleProjectVisibility(Project project) {
        if (project == null) return false;

        boolean currentVisibility = project.isVisible();
        project.setVisibility(!currentVisibility); // Toggle the state

        // Save the updated project list
        List<Project> allProjects = projectRepository.getAllProjects();
         for (int i = 0; i < allProjects.size(); i++) {
             if (allProjects.get(i).getProjectName().equals(project.getProjectName())) {
                 allProjects.set(i, project); // Replace with the modified project object
                 break;
             }
         }
        projectRepository.saveProjects(allProjects);

        System.out.println("Project '" + project.getProjectName() + "' visibility toggled to "
                + (project.isVisible() ? "ON" : "OFF") + ".");
        return true;
    }

     @Override
     public boolean checkDateOverlap(Project p1, Project p2) {
         // Delegate to eligibility service which already has this logic
         return eligibilityService.checkDateOverlap(p1, p2);
     }
}
```

Services/ReportService.java
```java
package Services;

import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Enums.MaritalStatus;
import Interfaces.Repositories.IApplicationRepository;
import Interfaces.Repositories.IUserRepository;
import Interfaces.Services.IReportService;
import Models.BTOApplication;
import Models.User;

public class ReportService implements IReportService {

    private final IApplicationRepository applicationRepository;
    private final IUserRepository userRepository;

    public ReportService(IApplicationRepository applicationRepository, IUserRepository userRepository) {
        this.applicationRepository = applicationRepository;
        this.userRepository = userRepository;
    }

    @Override
    public List<BTOApplication> generateBookedApplicantReport(List<String> projectNames, FlatType filterFlatType,
                                                              MaritalStatus filterMaritalStatus, int minAge, int maxAge) {

        if (projectNames == null || projectNames.isEmpty()) {
            System.out.println("No projects specified for the report.");
            return List.of(); // Return empty list
        }

        // Fetch all applications once
        Map<String, BTOApplication> allApplications = applicationRepository.getAllApplications();
        Map<String, User> allUsers = userRepository.getAllUsers(); // Fetch users for filtering

        return allApplications.values().stream()
                // Filter by BOOKED status
                .filter(app -> app.getStatus() == ApplicationStatus.BOOKED)
                // Filter by specified project names
                .filter(app -> projectNames.contains(app.getProjectName()))
                // Filter by flat type (if specified)
                .filter(app -> filterFlatType == null || app.getFlatTypeApplied() == filterFlatType)
                // Filter by applicant details (marital status, age)
                .filter(app -> {
                    User user = allUsers.get(app.getApplicantNric());
                    if (user == null) return false; // Skip if user data not found

                    // Apply marital status filter
                    if (filterMaritalStatus != null && user.getMaritalStatus() != filterMaritalStatus) {
                        return false;
                    }
                    // Apply min age filter (maxAge=0 means no upper limit)
                    if (minAge > 0 && user.getAge() < minAge) {
                        return false;
                    }
                    // Apply max age filter (maxAge=0 means no upper limit)
                    if (maxAge > 0 && user.getAge() > maxAge) {
                        return false;
                    }
                    return true; // Passed all filters
                })
                // Sort the results
                .sorted(Comparator.comparing(BTOApplication::getProjectName)
                                  .thenComparing(BTOApplication::getApplicantNric))
                .collect(Collectors.toList());
    }

    @Override
    public void displayApplicantReport(List<BTOApplication> reportData, FlatType filterFlatType,
                                       MaritalStatus filterMaritalStatus, int minAge, int maxAge) {

        System.out.println("\n--- Report: Applicants with Flat Bookings ---");
        System.out.println("Filters Applied: Project(s) selected, FlatType="
                + (filterFlatType == null ? "Any" : filterFlatType.getDisplayName()) + ", MaritalStatus="
                + (filterMaritalStatus == null ? "Any" : filterMaritalStatus) + ", Age="
                + (minAge > 0 ? minAge : "Any") + "-" + (maxAge > 0 ? maxAge : "Any"));
        System.out.println("---------------------------------------------------------------------------------");
        System.out.printf("%-15s | %-15s | %-5s | %-10s | %-15s | %-8s\n",
                "Applicant NRIC", "Name", "Age", "Marital", "Project Name", "FlatType");
        System.out.println("---------------------------------------------------------------------------------");

        if (reportData == null || reportData.isEmpty()) {
            System.out.println("No matching booked applications found for the specified filters.");
        } else {
            // Fetch all users once to avoid repeated lookups inside the loop
            Map<String, User> allUsers = userRepository.getAllUsers();
            reportData.forEach(app -> {
                User user = allUsers.get(app.getApplicantNric());
                System.out.printf("%-15s | %-15s | %-5s | %-10s | %-15s | %-8s\n",
                        app.getApplicantNric(),
                        (user != null) ? user.getName() : "N/A",
                        (user != null) ? String.valueOf(user.getAge()) : "N/A", // Age as string
                        (user != null) ? user.getMaritalStatus().name() : "N/A",
                        app.getProjectName(),
                        (app.getFlatTypeApplied() != null) ? app.getFlatTypeApplied().getDisplayName() : "N/A");
            });
        }
        System.out.println("---------------------------------------------------------------------------------");
        System.out.println("Total matching booked applicants: " + (reportData == null ? 0 : reportData.size()));
        System.out.println("--- End of Report ---");
    }
}
```

**Utilities**

Utils/InputUtils.java
```java
package Utils;

import java.util.Date;
import java.util.Scanner;
import Parsers.Dparse; // Assuming Dparse is in Parsers package

public class InputUtils {

    // Make scanner potentially injectable or passed if needed elsewhere,
    // but for simple utility, static methods might be acceptable here.
    // However, passing scanner promotes testability.

    public static int getIntInput(Scanner scanner, String prompt, int min, int max) {
        int value = -1;
        while (true) {
            System.out.print(prompt + " ");
            String input = scanner.nextLine();
            try {
                value = Integer.parseInt(input);
                if (value >= min && value <= max) {
                    break;
                } else {
                    System.out.println("Input must be between " + min + " and " + max + ".");
                }
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a whole number.");
            }
        }
        return value;
    }

    public static double getDoubleInput(Scanner scanner, String prompt, double min, double max) {
        double value = -1.0;
        while (true) {
            System.out.print(prompt + " ");
             String input = scanner.nextLine();
            try {
                value = Double.parseDouble(input);
                if (value >= min && value <= max) {
                    break;
                } else {
                    System.out.println("Input must be between " + min + " and " + max + ".");
                }
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a number.");
            }
        }
        return value;
    }

    public static Date getDateInput(Scanner scanner, String prompt, boolean allowBlank) {
        Date date = null;
        while (true) {
            System.out.print(prompt + " ");
            String input = scanner.nextLine().trim();
            if (input.isEmpty()) {
                if (allowBlank) {
                    return null; // Return null if blank is allowed
                } else {
                    System.out.println("Input cannot be empty.");
                    continue; // Ask again if blank not allowed
                }
            }
            // Use Dparse for consistent date parsing
            date = Dparse.parseDate(input);
            if (date != null) {
                break; // Valid date parsed
            }
            // Error message is printed by Dparse.parseDate
        }
        return date;
    }

    public static String getStringInput(Scanner scanner, String prompt, boolean allowEmpty) {
         while (true) {
             System.out.print(prompt + " ");
             String input = scanner.nextLine().trim();
             if (!input.isEmpty() || allowEmpty) {
                 return input;
             } else {
                 System.out.println("Input cannot be empty.");
             }
         }
    }

     public static boolean getConfirmation(Scanner scanner, String prompt) {
         while (true) {
             System.out.print(prompt + " (yes/no): ");
             String confirm = scanner.nextLine().trim().toLowerCase();
             if (confirm.equals("yes")) {
                 return true;
             } else if (confirm.equals("no")) {
                 return false;
             } else {
                 System.out.println("Invalid input. Please enter 'yes' or 'no'.");
             }
         }
     }
}
```

Utils/DateUtils.java
```java
package Utils;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Calendar; // Needed for date manipulation

public class DateUtils {
    // Use the format from Dparse for consistency
    public static final SimpleDateFormat DATE_FORMAT = Parsers.Dparse.DATE_FORMAT;

    public static Date getCurrentDate() {
        // Return a new Date object representing the current moment
        return new Date();
    }

    public static String formatDate(Date date) {
        if (date == null) {
            return ""; // Return empty string for null dates, consistent with CSV saving
        }
        // Ensure lenient is false if needed, though Dparse handles this on parsing
        // DATE_FORMAT.setLenient(false);
        return DATE_FORMAT.format(date);
    }

    // Helper to get the start of the next day, useful for date comparisons
    public static Date getEndOfDay(Date date) {
        if (date == null) return null;
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        cal.set(Calendar.HOUR_OF_DAY, 23);
        cal.set(Calendar.MINUTE, 59);
        cal.set(Calendar.SECOND, 59);
        cal.set(Calendar.MILLISECOND, 999);
        // Or more simply for comparison purposes:
        // cal.add(Calendar.DATE, 1);
        // cal.set(Calendar.HOUR_OF_DAY, 0);
        // cal.set(Calendar.MINUTE, 0);
        // cal.set(Calendar.SECOND, 0);
        // cal.set(Calendar.MILLISECOND, 0);
        return cal.getTime();
    }

     // Helper to get the start of the day (00:00:00)
     public static Date getStartOfDay(Date date) {
         if (date == null) return null;
         Calendar cal = Calendar.getInstance();
         cal.setTime(date);
         cal.set(Calendar.HOUR_OF_DAY, 0);
         cal.set(Calendar.MINUTE, 0);
         cal.set(Calendar.SECOND, 0);
         cal.set(Calendar.MILLISECOND, 0);
         return cal.getTime();
     }
}
```

Utils/NricValidator.java
```java
package Utils;

import java.util.regex.Pattern;

public class NricValidator {
    // Singapore NRIC pattern: Starts with S, T, F, or G, followed by 7 digits, ends with an uppercase letter.
    private static final Pattern NRIC_PATTERN = Pattern.compile("^[STFG]\\d{7}[A-Z]$", Pattern.CASE_INSENSITIVE); // Allow lowercase input but match uppercase internally

    /**
     * Validates an NRIC string.
     * @param nric The NRIC string to validate.
     * @return true if the format is valid, false otherwise.
     */
    public static boolean isValidNric(String nric) {
        // Check for null or empty string first
        if (nric == null || nric.trim().isEmpty()) {
            return false;
        }
        // Match against the pattern (case-insensitive due to flag, but usually stored uppercase)
        return NRIC_PATTERN.matcher(nric.trim()).matches();
     }
}
```

Models/Applicant.java
```java
package Models;

import Enums.MaritalStatus;
import Enums.UserRole;
import Enums.ApplicationStatus;
import Enums.FlatType;

public class Applicant extends User {
    // These fields represent the *current* state, synchronized from application data
    private String appliedProjectName;
    private ApplicationStatus applicationStatus;
    private FlatType bookedFlatType;

    public Applicant(String nric, String password, String name, int age, MaritalStatus maritalStatus) {
        super(nric, password, name, age, maritalStatus);
        // Initial state is no application
        this.clearApplicationState();
    }

    @Override
    public UserRole getRole() { return UserRole.APPLICANT; }

    // Getters
    public String getAppliedProjectName() { return appliedProjectName; }
    public ApplicationStatus getApplicationStatus() { return applicationStatus; }
    public FlatType getBookedFlatType() { return bookedFlatType; }

    // Setters - Used by synchronization logic
    public void setAppliedProjectName(String appliedProjectName) { this.appliedProjectName = appliedProjectName; }
    public void setApplicationStatus(ApplicationStatus applicationStatus) { this.applicationStatus = applicationStatus; }
    public void setBookedFlatType(FlatType bookedFlatType) { this.bookedFlatType = bookedFlatType; }

    // Convenience methods based on status
    public boolean hasActiveApplication() {
        // Active means pending approval or approved but not yet booked
        return this.applicationStatus == ApplicationStatus.PENDING ||
               this.applicationStatus == ApplicationStatus.SUCCESSFUL;
    }

     public boolean hasPendingWithdrawal() {
        return this.applicationStatus == ApplicationStatus.PENDING_WITHDRAWAL;
    }

    public boolean hasBooked() {
        // Booked status implies a booked flat type should also be set
        return this.applicationStatus == ApplicationStatus.BOOKED;
        // Redundant check: && this.bookedFlatType != null; (should be guaranteed by booking logic)
    }

    // Method to reset state, e.g., if all applications are resolved/deleted
    public void clearApplicationState() {
        this.appliedProjectName = null;
        this.applicationStatus = null; // Or perhaps a 'NO_APPLICATION' status? Null seems fine.
        this.bookedFlatType = null;
    }
}
```

Models/BTOApplication.java
```java
package Models;

import Enums.ApplicationStatus;
import Enums.FlatType;

import java.util.Date;
import java.util.Objects;

public class BTOApplication {
    private final String applicationId; // Format: ApplicantNRIC_ProjectName
    private final String applicantNric;
    private final String projectName;
    private FlatType flatTypeApplied; // Can be null initially? No, required on creation.
    private ApplicationStatus status;
    private final Date applicationDate;
    private ApplicationStatus statusBeforeWithdrawal; // To revert if withdrawal is rejected

    // Static method to generate consistent IDs
    public static String generateId(String applicantNric, String projectName) {
         return applicantNric + "_" + projectName;
    }

    // Constructor for new applications
    public BTOApplication(String applicantNric, String projectName, FlatType flatTypeApplied, Date applicationDate) {
        // Basic null checks
        Objects.requireNonNull(applicantNric, "Applicant NRIC cannot be null");
        Objects.requireNonNull(projectName, "Project Name cannot be null");
        Objects.requireNonNull(flatTypeApplied, "Flat Type Applied cannot be null for new application");
        Objects.requireNonNull(applicationDate, "Application Date cannot be null");

        if (applicantNric.trim().isEmpty() || projectName.trim().isEmpty()) {
             throw new IllegalArgumentException("Applicant NRIC and Project Name cannot be empty");
        }

        this.applicationId = generateId(applicantNric, projectName);
        this.applicantNric = applicantNric;
        this.projectName = projectName;
        this.flatTypeApplied = flatTypeApplied;
        this.status = ApplicationStatus.PENDING; // New applications start as PENDING
        this.applicationDate = applicationDate;
        this.statusBeforeWithdrawal = null;
    }

    // Constructor for loading from persistence
    public BTOApplication(String applicationId, String applicantNric, String projectName, FlatType flatTypeApplied, ApplicationStatus status, Date applicationDate) {
        // Basic null checks for required fields during load
        Objects.requireNonNull(applicationId, "Application ID cannot be null when loading");
        Objects.requireNonNull(applicantNric, "Applicant NRIC cannot be null when loading");
        Objects.requireNonNull(projectName, "Project Name cannot be null when loading");
        Objects.requireNonNull(status, "Status cannot be null when loading");
        Objects.requireNonNull(applicationDate, "Application Date cannot be null when loading");

        // Warning if status implies a flat type but it's null
         if (flatTypeApplied == null && (status == ApplicationStatus.BOOKED || status == ApplicationStatus.SUCCESSFUL || status == ApplicationStatus.PENDING_WITHDRAWAL )) {
              System.err.println("Warning: Loading " + status + " application ("+applicationId+") with null flatTypeApplied. Data might be inconsistent.");
         }

        this.applicationId = applicationId;
        this.applicantNric = applicantNric;
        this.projectName = projectName;
        this.flatTypeApplied = flatTypeApplied; // Allow null when loading if CSV was inconsistent
        this.status = status;
        this.applicationDate = applicationDate;
        this.statusBeforeWithdrawal = null; // This should ideally be persisted too if needed across sessions

        // Log if loaded in pending withdrawal state without knowing original
        if (status == ApplicationStatus.PENDING_WITHDRAWAL) {
            // The service layer will handle inferring the original status if needed
            System.out.println("Info: Application " + applicationId + " loaded with PENDING_WITHDRAWAL status.");
        }
    }

    // Getters
    public String getApplicationId() { return applicationId; }
    public String getApplicantNric() { return applicantNric; }
    public String getProjectName() { return projectName; }
    public FlatType getFlatTypeApplied() { return flatTypeApplied; }
    public ApplicationStatus getStatus() { return status; }
    public Date getApplicationDate() { return applicationDate; }
    public ApplicationStatus getStatusBeforeWithdrawal() { return statusBeforeWithdrawal; }

    // Setter for status, handles storing previous status on withdrawal request
    public void setStatus(ApplicationStatus newStatus) {
        Objects.requireNonNull(newStatus, "Application status cannot be set to null");

        // If moving TO pending withdrawal, store the current status
        if (newStatus == ApplicationStatus.PENDING_WITHDRAWAL && this.status != ApplicationStatus.PENDING_WITHDRAWAL) {
            this.statusBeforeWithdrawal = this.status;
        }
        // If moving FROM pending withdrawal (approved/rejected), clear the stored status
        else if (this.status == ApplicationStatus.PENDING_WITHDRAWAL && newStatus != ApplicationStatus.PENDING_WITHDRAWAL) {
            this.statusBeforeWithdrawal = null;
        }
        this.status = newStatus;
    }

    // Optional: Setter for flat type if it can change post-application (unlikely in BTO)
    // public void setFlatTypeApplied(FlatType flatTypeApplied) { this.flatTypeApplied = flatTypeApplied; }

    // --- Standard overrides ---
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        BTOApplication that = (BTOApplication) o;
        return applicationId.equals(that.applicationId); // ID is unique identifier
    }

    @Override
    public int hashCode() {
        return Objects.hash(applicationId);
    }

    @Override
    public String toString() {
        return "BTOApplication{" +
                "applicationId='" + applicationId + '\'' +
                ", applicantNric='" + applicantNric + '\'' +
                ", projectName='" + projectName + '\'' +
                ", flatTypeApplied=" + flatTypeApplied +
                ", status=" + status +
                ", applicationDate=" + applicationDate +
                ", statusBeforeWithdrawal=" + statusBeforeWithdrawal +
                '}';
    }
}
```

Models/Enquiry.java
```java
package Models;

import java.util.Date;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicLong; // Use AtomicLong for thread safety

public class Enquiry {
    private final String enquiryId;
    private final String applicantNric;
    private final String projectName;
    private String enquiryText; // Mutable if not replied
    private String replyText; // Null until replied
    private String repliedByNric; // Null until replied
    private final Date enquiryDate;
    private Date replyDate; // Null until replied

    // Thread-safe static counter for generating unique IDs
    private static final AtomicLong nextId = new AtomicLong(1);

    // Constructor for new enquiries
    public Enquiry(String applicantNric, String projectName, String enquiryText, Date enquiryDate) {
        // Use Objects.requireNonNull for cleaner null checks
        Objects.requireNonNull(applicantNric, "Applicant NRIC cannot be null");
        Objects.requireNonNull(projectName, "Project Name cannot be null");
        Objects.requireNonNull(enquiryText, "Enquiry Text cannot be null");
        Objects.requireNonNull(enquiryDate, "Enquiry Date cannot be null");

        if (applicantNric.trim().isEmpty() || projectName.trim().isEmpty() || enquiryText.trim().isEmpty()) {
            throw new IllegalArgumentException("Enquiry fields (NRIC, Project, Text) cannot be empty");
        }

        // Generate unique ID atomically
        this.enquiryId = "ENQ" + nextId.getAndIncrement();
        this.applicantNric = applicantNric;
        this.projectName = projectName;
        this.enquiryText = enquiryText.trim(); // Trim input text
        this.enquiryDate = enquiryDate;
        // Initialize reply fields to null
        this.replyText = null;
        this.repliedByNric = null;
        this.replyDate = null;
    }

    // Constructor for loading from persistence
    public Enquiry(String enquiryId, String applicantNric, String projectName, String enquiryText, String replyText, String repliedByNric, Date enquiryDate, Date replyDate) {
        // Null checks for essential fields during load
        Objects.requireNonNull(enquiryId, "Enquiry ID cannot be null when loading");
        Objects.requireNonNull(applicantNric, "Applicant NRIC cannot be null when loading");
        Objects.requireNonNull(projectName, "Project Name cannot be null when loading");
        Objects.requireNonNull(enquiryText, "Enquiry Text cannot be null when loading");
        Objects.requireNonNull(enquiryDate, "Enquiry Date cannot be null when loading");

        this.enquiryId = enquiryId;
        this.applicantNric = applicantNric;
        this.projectName = projectName;
        this.enquiryText = enquiryText; // Assume already trimmed from source
        // Handle potentially empty/null reply fields from CSV
        this.replyText = (replyText == null || replyText.trim().isEmpty()) ? null : replyText.trim();
        this.repliedByNric = (repliedByNric == null || repliedByNric.trim().isEmpty()) ? null : repliedByNric.trim();
        this.enquiryDate = enquiryDate;
        this.replyDate = replyDate; // Can be null if not replied

        // Update the static counter based on loaded IDs
        updateNextId(enquiryId);
    }

    // Method to update the static ID counter based on loaded IDs
    // Should be called by the repository after loading all enquiries
    public static void updateNextId(String loadedEnquiryId) {
         if (loadedEnquiryId != null && loadedEnquiryId.startsWith("ENQ")) {
            try {
                // Extract number part after "ENQ"
                long idNum = Long.parseLong(loadedEnquiryId.substring(3));
                // Atomically set nextId if the loaded ID is greater or equal
                nextId.accumulateAndGet(idNum + 1, Math::max);
            } catch (NumberFormatException | StringIndexOutOfBoundsException e) {
                // Log warning if parsing fails, but don't stop loading
                System.err.println("Warning: Could not parse enquiry ID for nextId update: " + loadedEnquiryId);
            }
         }
    }

    // Method to call after all loading is done (e.g., in Repository or DataService)
     public static void finalizeNextIdInitialization() {
         System.out.println("Enquiry nextId initialized to: " + nextId.get());
     }

    // --- Getters ---
    public String getEnquiryId() { return enquiryId; }
    public String getApplicantNric() { return applicantNric; }
    public String getProjectName() { return projectName; }
    public String getEnquiryText() { return enquiryText; }
    public String getReplyText() { return replyText; }
    public String getRepliedByNric() { return repliedByNric; }
    public Date getEnquiryDate() { return enquiryDate; }
    public Date getReplyDate() { return replyDate; }

    // --- Setters ---

    /**
     * Sets the enquiry text. Can only be done if the enquiry has not been replied to.
     * @param enquiryText The new enquiry text (cannot be null or empty).
     * @return true if the text was set successfully, false otherwise.
     */
    public boolean setEnquiryText(String enquiryText) {
        if (isReplied()) {
             System.err.println("Cannot edit an enquiry that has already been replied to (ID: " + enquiryId + ").");
             return false;
        }
        if (enquiryText == null || enquiryText.trim().isEmpty()) {
             System.err.println("Enquiry text cannot be empty.");
             return false;
        }
        this.enquiryText = enquiryText.trim();
        return true;
    }

    /**
     * Sets the reply details for the enquiry.
     * @param replyText The reply text (cannot be null or empty).
     * @param repliedByNric The NRIC of the user who replied (cannot be null or empty).
     * @param replyDate The date of the reply (cannot be null).
     * @return true if the reply was set successfully, false otherwise.
     */
    public boolean setReply(String replyText, String repliedByNric, Date replyDate) {
        // Prevent setting reply if already replied? Or allow overwriting? Let's prevent.
        if (isReplied()) {
             System.err.println("Enquiry " + enquiryId + " has already been replied to. Cannot set reply again.");
             return false;
        }
        if (replyText == null || replyText.trim().isEmpty() ||
            repliedByNric == null || repliedByNric.trim().isEmpty() ||
            replyDate == null)
        {
            System.err.println("Invalid reply parameters provided for enquiry ID: " + enquiryId + ". All fields (text, replier NRIC, date) are required.");
            return false;
        }
        this.replyText = replyText.trim();
        this.repliedByNric = repliedByNric.trim();
        this.replyDate = replyDate;
        return true;
    }

    // --- State Check ---
    public boolean isReplied() {
        // Considered replied if replyText is not null and not empty
        return this.replyText != null && !this.replyText.isEmpty();
    }

    // --- Standard overrides ---
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Enquiry enquiry = (Enquiry) o;
        return enquiryId.equals(enquiry.enquiryId); // ID is unique identifier
    }

    @Override
    public int hashCode() {
        return Objects.hash(enquiryId);
    }

    @Override
    public String toString() {
        return "Enquiry{" +
                "enquiryId='" + enquiryId + '\'' +
                ", applicantNric='" + applicantNric + '\'' +
                ", projectName='" + projectName + '\'' +
                ", enquiryDate=" + enquiryDate +
                ", replied=" + isReplied() +
                '}';
    }
}
```

Models/FlatTypeDetails.java
```java
package Models;

import java.util.Objects;

public class FlatTypeDetails {
    private final int totalUnits; // Total units planned for this type
    private int availableUnits; // Units currently available for booking
    private double sellingPrice;

    public FlatTypeDetails(int totalUnits, int availableUnits, double sellingPrice) {
        // Validation during construction
        if (totalUnits < 0) {
            throw new IllegalArgumentException("Total units cannot be negative: " + totalUnits);
        }
        if (availableUnits < 0 || availableUnits > totalUnits) {
            throw new IllegalArgumentException("Invalid available units: " + availableUnits + " (Total: " + totalUnits + ")");
        }
        if (sellingPrice < 0) {
            throw new IllegalArgumentException("Selling price cannot be negative: " + sellingPrice);
        }

        this.totalUnits = totalUnits;
        this.availableUnits = availableUnits;
        this.sellingPrice = sellingPrice;
    }

    // Getters
    public int getTotalUnits() { return totalUnits; }
    public int getAvailableUnits() { return availableUnits; }
    public double getSellingPrice() { return sellingPrice; }

    // Setters with validation

    /**
     * Sets the selling price. Must be non-negative.
     * @param sellingPrice The new selling price.
     */
    public void setSellingPrice(double sellingPrice) {
        if (sellingPrice >= 0) {
            this.sellingPrice = sellingPrice;
        } else {
             System.err.println("Warning: Attempted to set negative selling price (" + sellingPrice + "). Price not changed.");
             // Or throw IllegalArgumentException("Selling price cannot be negative: " + sellingPrice);
        }
    }

    /**
     * Decrements the number of available units by one.
     * Fails if no units are currently available.
     * @return true if a unit was successfully decremented, false otherwise.
     */
    public boolean decrementAvailableUnits() {
        if (this.availableUnits > 0) {
            this.availableUnits--;
            return true;
        } else {
             // Log or handle the case where decrement is attempted on zero units
             System.err.println("Warning: Attempted to decrement available units when already zero.");
             return false;
        }
    }

    /**
     * Increments the number of available units by one (e.g., due to withdrawal).
     * Fails if available units are already equal to total units.
     * @return true if a unit was successfully incremented, false otherwise.
     */
    public boolean incrementAvailableUnits() {
        if (this.availableUnits < this.totalUnits) {
            this.availableUnits++;
            return true;
        } else {
             // Log or handle the case where increment goes beyond total
             System.err.println("Warning: Attempted to increment available units beyond total units (" + this.totalUnits + ").");
             return false;
        }
    }

    /**
     * Directly sets the number of available units. Used during data synchronization.
     * Clamps the value within the valid range [0, totalUnits].
     * @param availableUnits The desired number of available units.
     */
    public void setAvailableUnits(int availableUnits) {
        if (availableUnits >= 0 && availableUnits <= this.totalUnits) {
            this.availableUnits = availableUnits;
        } else {
            // Log the error and clamp the value to the nearest valid boundary
            System.err.println("Error: Invalid available units (" + availableUnits + ") set for flat type with total " + this.totalUnits + ". Clamping to valid range [0, " + this.totalUnits + "].");
            this.availableUnits = Math.max(0, Math.min(availableUnits, this.totalUnits));
        }
    }

    // --- Standard overrides ---
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FlatTypeDetails that = (FlatTypeDetails) o;
        // Two details are equal if total units, available units, and price are the same
        return totalUnits == that.totalUnits &&
               availableUnits == that.availableUnits &&
               Double.compare(that.sellingPrice, sellingPrice) == 0;
    }

    @Override
    public int hashCode() {
        return Objects.hash(totalUnits, availableUnits, sellingPrice);
    }

    @Override
    public String toString() {
        return "FlatTypeDetails{" +
                "totalUnits=" + totalUnits +
                ", availableUnits=" + availableUnits +
                ", sellingPrice=" + sellingPrice +
                '}';
    }
}
```

Models/HDBManager.java
```java
package Models;

import Enums.MaritalStatus;
import Enums.UserRole;

// This class might not need to extend Applicant if Managers cannot perform Applicant actions.
// Let's assume they are distinct for now and extend User directly.
public class HDBManager extends User {

    public HDBManager(String nric, String password, String name, int age, MaritalStatus maritalStatus) {
        super(nric, password, name, age, maritalStatus);
        // No manager-specific fields currently
    }

    @Override
    public UserRole getRole() {
        return UserRole.HDB_MANAGER;
    }

    // Add any manager-specific methods or properties here if needed in the future.
}
```

Models/HDBOfficer.java
```java
package Models;

import Enums.UserRole;
import Enums.MaritalStatus;

// HDBOfficer inherits Applicant capabilities (can view projects, apply - though restricted, manage own enquiries)
public class HDBOfficer extends Applicant {

    public HDBOfficer(String nric, String password, String name, int age, MaritalStatus maritalStatus) {
        super(nric, password, name, age, maritalStatus);
        // No officer-specific fields currently, inherits application state from Applicant
    }

    @Override
    public UserRole getRole() {
        return UserRole.HDB_OFFICER;
    }

    // Add any officer-specific methods or properties here if needed.
    // For example, reference to the project they are currently handling (though this is derived in EligibilityService).
}
```

Models/OfficerRegistration.java
```java
package Models;

import Enums.OfficerRegistrationStatus;
import java.util.Date;
import java.util.Objects;

public class OfficerRegistration {
    private final String registrationId; // Format: OfficerNRIC_REG_ProjectName
    private final String officerNric;
    private final String projectName;
    private OfficerRegistrationStatus status; // Mutable status
    private final Date registrationDate;

    // Static method to generate consistent IDs
    public static String generateId(String officerNric, String projectName) {
        return officerNric + "_REG_" + projectName;
    }

    // Constructor for new registrations (always start as PENDING)
    public OfficerRegistration(String officerNric, String projectName, Date registrationDate) {
        Objects.requireNonNull(officerNric, "Officer NRIC cannot be null");
        Objects.requireNonNull(projectName, "Project Name cannot be null");
        Objects.requireNonNull(registrationDate, "Registration Date cannot be null");
        if (officerNric.trim().isEmpty() || projectName.trim().isEmpty()) {
             throw new IllegalArgumentException("Officer NRIC and Project Name cannot be empty");
        }

        this.registrationId = generateId(officerNric, projectName);
        this.officerNric = officerNric;
        this.projectName = projectName;
        this.status = OfficerRegistrationStatus.PENDING; // Default status
        this.registrationDate = registrationDate;
    }

    // Constructor for loading from persistence
    public OfficerRegistration(String registrationId, String officerNric, String projectName, OfficerRegistrationStatus status, Date registrationDate) {
        Objects.requireNonNull(registrationId, "Registration ID cannot be null when loading");
        Objects.requireNonNull(officerNric, "Officer NRIC cannot be null when loading");
        Objects.requireNonNull(projectName, "Project Name cannot be null when loading");
        Objects.requireNonNull(status, "Status cannot be null when loading");
        Objects.requireNonNull(registrationDate, "Registration Date cannot be null when loading");

        this.registrationId = registrationId;
        this.officerNric = officerNric;
        this.projectName = projectName;
        this.status = status;
        this.registrationDate = registrationDate;
    }

    // Getters
    public String getRegistrationId() { return registrationId; }
    public String getOfficerNric() { return officerNric; }
    public String getProjectName() { return projectName; }
    public OfficerRegistrationStatus getStatus() { return status; }
    public Date getRegistrationDate() { return registrationDate; }

    // Setter for status
    public void setStatus(OfficerRegistrationStatus status) {
        Objects.requireNonNull(status, "Status cannot be set to null");
        this.status = status;
    }

    // --- Standard overrides ---
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        OfficerRegistration that = (OfficerRegistration) o;
        return registrationId.equals(that.registrationId); // ID is unique identifier
    }

    @Override
    public int hashCode() {
        return Objects.hash(registrationId);
    }

    @Override
    public String toString() {
        return "OfficerRegistration{" +
                "registrationId='" + registrationId + '\'' +
                ", officerNric='" + officerNric + '\'' +
                ", projectName='" + projectName + '\'' +
                ", status=" + status +
                ", registrationDate=" + registrationDate +
                '}';
    }
}
```

Models/Project.java
```java
package Models;

import Enums.FlatType;
import Utils.DateUtils; // For date comparisons

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

public class Project {
    private String projectName; // Can be set via setter? No, should be final identifier? Let's make it final.
    private final String projectNameIdentifier; // Use this for equality/hashcode
    private String neighborhood; // Mutable
    private Map<FlatType, FlatTypeDetails> flatTypes; // Mutable map content
    private Date applicationOpeningDate; // Mutable
    private Date applicationClosingDate; // Mutable
    private final String managerNric; // Final
    private int maxOfficerSlots; // Mutable
    private List<String> approvedOfficerNrics; // Mutable list content
    private boolean visibility; // Mutable

    public Project(String projectName, String neighborhood, Map<FlatType, FlatTypeDetails> flatTypes,
                   Date applicationOpeningDate, Date applicationClosingDate, String managerNric,
                   int maxOfficerSlots, List<String> approvedOfficerNrics, boolean visibility) {

        // --- Input Validation ---
        Objects.requireNonNull(projectName, "Project Name cannot be null");
        Objects.requireNonNull(neighborhood, "Neighborhood cannot be null");
        Objects.requireNonNull(flatTypes, "Flat Types map cannot be null");
        Objects.requireNonNull(applicationOpeningDate, "Application Opening Date cannot be null");
        Objects.requireNonNull(applicationClosingDate, "Application Closing Date cannot be null");
        Objects.requireNonNull(managerNric, "Manager NRIC cannot be null");

        if (projectName.trim().isEmpty()) throw new IllegalArgumentException("Project name cannot be empty");
        if (neighborhood.trim().isEmpty()) throw new IllegalArgumentException("Neighborhood cannot be empty");
        if (flatTypes.isEmpty()) throw new IllegalArgumentException("Project must have at least one flat type");
        if (managerNric.trim().isEmpty()) throw new IllegalArgumentException("Manager NRIC cannot be empty");
        if (maxOfficerSlots < 0) throw new IllegalArgumentException("Max officer slots cannot be negative");
        if (applicationClosingDate.before(applicationOpeningDate)) {
             throw new IllegalArgumentException("Project closing date cannot be before opening date.");
        }
        // --- End Validation ---

        this.projectNameIdentifier = projectName.trim();
        this.projectName = projectName.trim(); // Store trimmed version
        this.neighborhood = neighborhood.trim();
        // Create a deep copy of the flat types map to ensure internal state is not modified externally
        this.flatTypes = flatTypes.entrySet().stream()
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        e -> new FlatTypeDetails(e.getValue().getTotalUnits(), e.getValue().getAvailableUnits(), e.getValue().getSellingPrice()),
                        (v1, v2) -> v1, // Merge function (shouldn't be needed with distinct FlatType keys)
                        HashMap::new
                ));
        this.applicationOpeningDate = applicationOpeningDate;
        this.applicationClosingDate = applicationClosingDate;
        this.managerNric = managerNric;
        // Ensure approved officers list is not null and doesn't exceed max slots initially
        List<String> initialOfficers = (approvedOfficerNrics != null) ? new ArrayList<>(approvedOfficerNrics) : new ArrayList<>();
        if (initialOfficers.size() > maxOfficerSlots) {
             System.err.println("Warning: Initial approved officers (" + initialOfficers.size() + ") exceed max slots (" + maxOfficerSlots + ") for project " + projectName + ". Truncating list.");
             this.approvedOfficerNrics = initialOfficers.subList(0, maxOfficerSlots);
        } else {
             this.approvedOfficerNrics = initialOfficers;
        }
        this.maxOfficerSlots = maxOfficerSlots; // Set max slots *after* potentially truncating list
        this.visibility = visibility;
    }

    // --- Getters ---
    public String getProjectName() { return projectName; }
    public String getNeighborhood() { return neighborhood; }
    // Return an unmodifiable view of the map to prevent external modification
    public Map<FlatType, FlatTypeDetails> getFlatTypes() { return Collections.unmodifiableMap(flatTypes); }
    public Date getApplicationOpeningDate() { return applicationOpeningDate; }
    public Date getApplicationClosingDate() { return applicationClosingDate; }
    public String getManagerNric() { return managerNric; }
    public int getMaxOfficerSlots() { return maxOfficerSlots; }
    // Return an unmodifiable view of the list
    public List<String> getApprovedOfficerNrics() { return Collections.unmodifiableList(approvedOfficerNrics); }
    public boolean isVisible() { return visibility; }
    public int getRemainingOfficerSlots() { return Math.max(0, maxOfficerSlots - approvedOfficerNrics.size()); }

    // --- Setters with Validation ---

    // Project Name is identifier, should not be changed after creation.
    // public void setProjectName(String projectName) { ... }

    public void setNeighborhood(String neighborhood) {
         Objects.requireNonNull(neighborhood, "Neighborhood cannot be null");
         if (neighborhood.trim().isEmpty()) throw new IllegalArgumentException("Neighborhood cannot be empty");
         this.neighborhood = neighborhood.trim();
    }

    public void setFlatTypes(Map<FlatType, FlatTypeDetails> newFlatTypes) {
        Objects.requireNonNull(newFlatTypes, "Flat Types map cannot be null");
        if (newFlatTypes.isEmpty()) throw new IllegalArgumentException("Project must have at least one flat type");
        // Create a deep copy again
        this.flatTypes = newFlatTypes.entrySet().stream()
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        e -> new FlatTypeDetails(e.getValue().getTotalUnits(), e.getValue().getAvailableUnits(), e.getValue().getSellingPrice()),
                        (v1, v2) -> v1,
                        HashMap::new
                ));
    }

    public void setApplicationOpeningDate(Date applicationOpeningDate) {
        Objects.requireNonNull(applicationOpeningDate, "Application Opening Date cannot be null");
        // Ensure new opening date is not after the current closing date
        if (this.applicationClosingDate != null && applicationOpeningDate.after(this.applicationClosingDate)) {
             System.err.println("Warning: New opening date cannot be after the current closing date. Date not updated.");
             // Or throw new IllegalArgumentException("Opening date cannot be after closing date.");
             return;
        }
        this.applicationOpeningDate = applicationOpeningDate;
    }

    public void setApplicationClosingDate(Date applicationClosingDate) {
         Objects.requireNonNull(applicationClosingDate, "Application Closing Date cannot be null");
         // Ensure new closing date is not before the current opening date
         if (this.applicationOpeningDate != null && applicationClosingDate.before(this.applicationOpeningDate)) {
             System.err.println("Warning: Closing date cannot be before opening date. Date not updated.");
             // Or throw new IllegalArgumentException("Closing date cannot be before opening date.");
             return;
         }
         this.applicationClosingDate = applicationClosingDate;
    }

    /**
     * Sets the maximum number of officer slots. Cannot be set below the current
     * number of approved officers.
     * @param maxOfficerSlots The new maximum number of slots (must be >= 0).
     * @return true if the value was set, false otherwise.
     */
    public boolean setMaxOfficerSlots(int maxOfficerSlots) {
        if (maxOfficerSlots < 0) {
             System.err.println("Warning: Max officer slots cannot be negative. Value not changed.");
             return false;
        }
        if (maxOfficerSlots < this.approvedOfficerNrics.size()) {
            System.err.println("Warning: Cannot set max officer slots ("+ maxOfficerSlots +") below current approved count (" + this.approvedOfficerNrics.size() + "). Value not changed.");
            return false;
        }
        this.maxOfficerSlots = maxOfficerSlots;
        return true;
    }

    public void setVisibility(boolean visibility) { this.visibility = visibility; }

    // --- List Management Methods ---

    /**
     * Adds an officer NRIC to the list of approved officers if slots are available
     * and the officer is not already approved.
     * @param officerNric The NRIC of the officer to add.
     * @return true if the officer was successfully added, false otherwise.
     */
    public boolean addApprovedOfficer(String officerNric) {
        Objects.requireNonNull(officerNric, "Officer NRIC cannot be null");
        if (officerNric.trim().isEmpty()) return false; // Cannot add empty NRIC

        if (getRemainingOfficerSlots() > 0 && !approvedOfficerNrics.contains(officerNric.trim())) {
            approvedOfficerNrics.add(officerNric.trim());
            return true;
        } else if (approvedOfficerNrics.contains(officerNric.trim())) {
             System.err.println("Info: Officer " + officerNric + " is already approved for project " + this.projectName);
             return false; // Or return true if already present is considered success? Let's say false.
        } else { // No remaining slots
             System.err.println("Warning: No remaining officer slots to add " + officerNric + " to project " + this.projectName);
             return false;
        }
    }

    /**
     * Removes an officer NRIC from the list of approved officers.
     * @param officerNric The NRIC of the officer to remove.
     * @return true if the officer was found and removed, false otherwise.
     */
    public boolean removeApprovedOfficer(String officerNric) {
        if (officerNric == null) return false;
        return approvedOfficerNrics.remove(officerNric.trim());
    }

    // Internal method for synchronization service to bypass unmodifiable list
    // Use with caution!
    protected void internal_setApprovedOfficers(List<String> officers) {
         this.approvedOfficerNrics = new ArrayList<>(officers);
    }


    // --- State Check Methods ---

    /**
     * Checks if the project's application period is currently active based on the provided date.
     * The period includes the opening date and the closing date.
     * @param currentDate The date to check against.
     * @return true if the application period is active, false otherwise.
     */
    public boolean isApplicationPeriodActive(Date currentDate) {
        if (currentDate == null || applicationOpeningDate == null || applicationClosingDate == null) return false;

        // Normalize dates to avoid time-of-day issues if necessary, or compare directly.
        // Let's compare directly: Active if currentDate >= openingDate AND currentDate <= closingDate (inclusive)
        // To make closingDate inclusive, we check if currentDate is *not after* the end of the closing day.
        Date startOfDayOpening = DateUtils.getStartOfDay(applicationOpeningDate);
        Date endOfDayClosing = DateUtils.getEndOfDay(applicationClosingDate); // Get 23:59:59... of closing day

        return !currentDate.before(startOfDayOpening) && !currentDate.after(endOfDayClosing);
    }

    /**
     * Checks if the project's application period has expired based on the provided date.
     * @param currentDate The date to check against.
     * @return true if the application period has expired, false otherwise.
     */
    public boolean isApplicationPeriodExpired(Date currentDate) {
         if (currentDate == null || applicationClosingDate == null) return false; // Cannot be expired if no closing date or current date
         Date endOfDayClosing = DateUtils.getEndOfDay(applicationClosingDate);
         return currentDate.after(endOfDayClosing);
    }

    // --- Flat Type Details Access ---

    /**
     * Gets the details for a specific flat type.
     * @param type The FlatType enum.
     * @return The FlatTypeDetails object, or null if the type doesn't exist in this project.
     */
    public FlatTypeDetails getFlatTypeDetails(FlatType type) {
        // Returns the actual object, but since the map is internal, it's okay.
        // If we returned the unmodifiable map's value, it would still be the same object.
        return flatTypes.get(type);
    }

    /**
     * Gets a *mutable* reference to the FlatTypeDetails for a specific type.
     * Use with caution, intended for services that need to modify unit counts (e.g., ApplicationService).
     * @param type The FlatType enum.
     * @return The mutable FlatTypeDetails object, or null if the type doesn't exist.
     */
    public FlatTypeDetails getMutableFlatTypeDetails(FlatType type) {
        return flatTypes.get(type);
    }

    // --- Standard overrides ---
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         Project project = (Project) o;
         // Equality based on the unique project name identifier
         return projectNameIdentifier.equals(project.projectNameIdentifier);
     }

     @Override
     public int hashCode() {
         return Objects.hash(projectNameIdentifier);
     }

     @Override
     public String toString() {
         return "Project{" +
                 "projectName='" + projectName + '\'' +
                 ", neighborhood='" + neighborhood + '\'' +
                 ", openingDate=" + DateUtils.formatDate(applicationOpeningDate) +
                 ", closingDate=" + DateUtils.formatDate(applicationClosingDate) +
                 ", visibility=" + visibility +
                 '}';
     }
}
```

Models/User.java
```java
package Models;

import Enums.MaritalStatus;
import Enums.UserRole;
import java.util.Objects;

public abstract class User {
    private final String nric; // Unique identifier, should be final
    private String password; // Mutable
    private final String name; // Should be final? Assume yes for simplicity.
    private final int age; // Should be final? Assume yes.
    private final MaritalStatus maritalStatus; // Should be final? Assume yes.

    public User(String nric, String password, String name, int age, MaritalStatus maritalStatus) {
        // Use Objects.requireNonNull for cleaner null checks
        Objects.requireNonNull(nric, "NRIC cannot be null");
        Objects.requireNonNull(password, "Password cannot be null");
        Objects.requireNonNull(name, "Name cannot be null");
        Objects.requireNonNull(maritalStatus, "Marital Status cannot be null");

        // Basic validation
        if (nric.trim().isEmpty()) throw new IllegalArgumentException("NRIC cannot be empty");
        if (password.isEmpty()) throw new IllegalArgumentException("Password cannot be empty"); // Allow spaces? No.
        if (name.trim().isEmpty()) throw new IllegalArgumentException("Name cannot be empty");
        if (age <= 0) throw new IllegalArgumentException("Age must be positive");

        // Consider NRIC format validation here or rely on external validation (like NricValidator)
        this.nric = nric.trim().toUpperCase(); // Store NRIC consistently
        this.password = password;
        this.name = name.trim();
        this.age = age;
        this.maritalStatus = maritalStatus;
    }

    // --- Getters ---
    public String getNric() { return nric; }
    public String getPassword() { return password; }
    public String getName() { return name; }
    public int getAge() { return age; }
    public MaritalStatus getMaritalStatus() { return maritalStatus; }

    // --- Setters ---
    public void setPassword(String password) {
        Objects.requireNonNull(password, "Password cannot be null");
        if (password.isEmpty()) {
             System.err.println("Warning: Attempted to set empty password for NRIC: " + nric + ". Password not changed.");
             // Or throw new IllegalArgumentException("Password cannot be empty");
             return;
        }
        this.password = password;
    }

    // Abstract method to be implemented by subclasses
    public abstract UserRole getRole();

    // --- Standard overrides ---
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false; // Check class equality for distinct roles
        User user = (User) o;
        return nric.equals(user.nric); // NRIC is the unique identifier
    }

    @Override
    public int hashCode() {
        return Objects.hash(nric);
    }

    @Override
    public String toString() {
        return "User{" +
                "nric='" + nric + '\'' +
                ", name='" + name + '\'' +
                ", age=" + age +
                ", maritalStatus=" + maritalStatus +
                ", role=" + getRole() + // Include role from subclass
                '}';
    }
}
```

**Enums (Unchanged)**

Enums/ApplicationStatus.java
```java
package Enums;

import java.util.Comparator;

public enum ApplicationStatus {
    // Define priority for sorting/comparison (higher value = higher priority/later stage)
    PENDING(3),
    SUCCESSFUL(5),
    BOOKED(6),
    PENDING_WITHDRAWAL(4), // Higher than PENDING, lower than SUCCESSFUL/BOOKED
    WITHDRAWN(2),          // Approved withdrawal from PENDING
    UNSUCCESSFUL(1);       // Rejected or withdrawn after SUCCESSFUL/BOOKED

    private final int priority;

    ApplicationStatus(int priority) {
        this.priority = priority;
    }

    public int getPriority() {
        return priority;
    }

    // Optional: Comparator for sorting by priority
    public static Comparator<ApplicationStatus> priorityComparator() {
        return Comparator.comparingInt(ApplicationStatus::getPriority);
    }
}
```

Enums/FlatType.java
```java
package Enums;

public enum FlatType {
    TWO_ROOM("2-Room"),
    THREE_ROOM("3-Room");

    private final String displayName;

    FlatType(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }

    /**
     * Parses a string to find the corresponding FlatType enum constant.
     * Case-insensitive matching against enum name and display name.
     * @param text The string to parse.
     * @return The matching FlatType, or null if no match is found.
     */
    public static FlatType fromString(String text) {
        if (text != null) {
            String trimmedText = text.trim();
            for (FlatType b : FlatType.values()) {
                // Check against enum constant name (e.g., "TWO_ROOM")
                if (trimmedText.equalsIgnoreCase(b.name())) {
                    return b;
                }
                // Check against display name (e.g., "2-Room")
                if (trimmedText.equalsIgnoreCase(b.displayName)) {
                    return b;
                }
            }
            // Add specific common variations if needed, though covered by displayName check now
            // if ("2-Room".equalsIgnoreCase(trimmedText)) return TWO_ROOM;
            // if ("3-Room".equalsIgnoreCase(trimmedText)) return THREE_ROOM;
        }
        // Return null if no match found or input is null
        return null;
    }
}
```

Enums/MaritalStatus.java
```java
package Enums;

public enum MaritalStatus {
    SINGLE, MARRIED
    // Add other statuses like DIVORCED, WIDOWED if needed by eligibility rules
}
```

Enums/OfficerRegistrationStatus.java
```java
package Enums;

public enum OfficerRegistrationStatus {
    PENDING, APPROVED, REJECTED
}
```

Enums/UserRole.java
```java
package Enums;

public enum UserRole {
    APPLICANT, HDB_OFFICER, HDB_MANAGER
}
```

**Parsers (Unchanged, used by Repositories)**

Parsers/Dparse.java
```java
package Parsers;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Dparse {
    // Make format public for use by DateUtils and Repositories
    public static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");

    static {
        // Set lenient to false globally for this format instance
        DATE_FORMAT.setLenient(false);
    }

    /**
     * Parses a date string in "yyyy-MM-dd" format.
     * @param dateString The string to parse.
     * @return The parsed Date object, or null if the string is null, empty, "null", or invalid format.
     */
    public static Date parseDate(String dateString) {
        if (dateString == null || dateString.trim().isEmpty() || dateString.trim().equalsIgnoreCase("null")) {
            return null;
        }
        try {
            // Lenient is already set to false
            return DATE_FORMAT.parse(dateString.trim());
        } catch (ParseException e) {
            // Log the error for debugging purposes
            System.err.println("Warning: Invalid date format encountered: '" + dateString + "'. Expected yyyy-MM-dd.");
            return null; // Return null for invalid format
        }
    }
}
```

Parsers/LSparse.java
```java
package Parsers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class LSparse {
    // Delimiter used within a single CSV field to represent a list
    private static final String LIST_DELIMITER = ";";

    /**
     * Parses a string containing a delimited list into a List of strings.
     * Handles quoted strings containing the delimiter.
     * @param listString The string representation of the list (e.g., "item1;item2;\"item3;with;delimiter\"").
     * @return A List of strings, or an empty list if the input is null or empty.
     */
    public static List<String> parseListString(String listString) {
        if (listString == null || listString.trim().isEmpty()) {
            return new ArrayList<>(); // Return empty list for null/empty input
        }

        String effectiveList = listString.trim();

        // Basic handling for CSV quoting (remove surrounding quotes if present)
        // This assumes the *entire* list field might be quoted if it contains delimiters/quotes.
        // More robust CSV parsing would handle quotes around individual items if needed.
        if (effectiveList.startsWith("\"") && effectiveList.endsWith("\"")) {
            // Remove surrounding quotes and unescape double quotes ("") inside
            effectiveList = effectiveList.substring(1, effectiveList.length() - 1).replace("\"\"", "\"");
        }

        // Split by the delimiter, trim each part, and filter out empty strings
        return Arrays.stream(effectiveList.split(LIST_DELIMITER))
                     .map(String::trim) // Trim whitespace from each potential item
                     .filter(s -> !s.isEmpty()) // Remove any empty items resulting from split (e.g., ";;")
                     .collect(Collectors.toList());
    }
}
```

**Controllers (Depend on Interfaces)**

Controllers/ApplicantController.java
```java
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Enums.OfficerRegistrationStatus;
import Interfaces.Services.*; // Import all service interfaces
import Models.Applicant;
import Models.BTOApplication;
import Models.Enquiry;
import Models.HDBOfficer;
import Models.Project;
import Models.User;
import Utils.DateUtils;
import Utils.InputUtils; // Use InputUtils

public class ApplicantController {

    protected final Scanner scanner;
    protected final User currentUser;
    // Service Dependencies (Injected)
    protected final IAuthService authService;
    protected final IProjectService projectService;
    protected final IApplicationService applicationService;
    protected final IEnquiryService enquiryService;
    protected final IEligibilityService eligibilityService;
    protected final IFilterService filterService;
    protected final IProjectDisplayService projectDisplayService;
    // Officer specific service needed for apply check
    protected final IOfficerRegistrationService officerRegistrationService;


    public ApplicantController(Scanner scanner, User currentUser, IAuthService authService,
                               IProjectService projectService, IApplicationService applicationService,
                               IEnquiryService enquiryService, IEligibilityService eligibilityService,
                               IFilterService filterService, IProjectDisplayService projectDisplayService,
                               IOfficerRegistrationService officerRegistrationService) {
        this.scanner = scanner;
        this.currentUser = currentUser;
        this.authService = authService;
        this.projectService = projectService;
        this.applicationService = applicationService;
        this.enquiryService = enquiryService;
        this.eligibilityService = eligibilityService;
        this.filterService = filterService;
        this.projectDisplayService = projectDisplayService;
        this.officerRegistrationService = officerRegistrationService; // Added
    }

    public void viewOpenProjects() {
        System.out.println("\n--- Viewing Available BTO Projects ---");
        // Get projects that are visible, active, eligible, and have units
        List<Project> availableProjects = projectService.getOpenProjects(currentUser);
        projectDisplayService.displayProjectList(availableProjects, "Available BTO Projects", currentUser);
    }

    public void applyForProject() {
        // Ensure current user is an Applicant (or subclass like Officer)
        if (!(currentUser instanceof Applicant)) {
            System.out.println("Error: Only Applicants or Officers can apply for projects.");
            return;
        }
        Applicant applicant = (Applicant) currentUser;

        // Pre-checks using Applicant model state
        if (applicant.hasBooked()) {
            System.out.println("You have already booked a flat for project '" + applicant.getAppliedProjectName()
                    + "'. You cannot apply again.");
            return;
        }
        if (applicant.hasActiveApplication()) {
            System.out.println("You have an active application for project '" + applicant.getAppliedProjectName()
                    + "' with status: " + applicant.getApplicationStatus());
            System.out.println("You must withdraw (and have it approved) or be unsuccessful before applying again.");
            return;
        }
        if (applicant.hasPendingWithdrawal()) {
            System.out.println("You have a withdrawal request pending manager approval for project '"
                    + applicant.getAppliedProjectName() + "'.");
            System.out.println("You cannot apply for a new project until the withdrawal is processed.");
            return;
        }

        System.out.println("\n--- Apply for BTO Project ---");
        // Get projects eligible for application (Visible, Active, Eligible, Available Units)
        List<Project> eligibleProjects = projectService.getOpenProjects(currentUser);

        if (eligibleProjects.isEmpty()) {
            System.out.println(
                    "There are currently no open projects you are eligible to apply for based on filters, eligibility, and unit availability.");
            return;
        }

        // Display and select project
        projectDisplayService.displayProjectList(eligibleProjects, "Select Project to Apply For", currentUser);
        Project selectedProject = projectDisplayService.selectProjectFromList(eligibleProjects, scanner);
        if (selectedProject == null) return; // User cancelled

        // --- Officer-Specific Checks ---
        if (currentUser instanceof HDBOfficer) {
            HDBOfficer officer = (HDBOfficer) currentUser;
            // Check if officer is handling the selected project
            Project handlingProject = eligibilityService.getOfficerHandlingProject(officer);
            if (handlingProject != null && selectedProject.equals(handlingProject)) {
                System.out.println("Error: You cannot apply for a project you are currently handling as an Officer.");
                return;
            }
            // Check if officer has a pending registration for the selected project
            boolean hasPendingRegistration = officerRegistrationService.getRegistrationsByOfficer(officer.getNric())
                    .stream()
                    .anyMatch(reg -> reg.getProjectName().equals(selectedProject.getProjectName()) &&
                                    reg.getStatus() == OfficerRegistrationStatus.PENDING);
            if (hasPendingRegistration) {
                System.out.println("Error: You cannot apply for a project you have a pending registration for.");
                return;
            }
        }
        // --- End Officer Checks ---

        // Select Flat Type
        FlatType selectedFlatType = selectEligibleFlatType(selectedProject);
        if (selectedFlatType == null) return; // User cancelled or no eligible types

        // Submit application via service
        boolean success = applicationService.submitApplication(applicant, selectedProject, selectedFlatType);
        // Success message is printed within the service
    }

    private FlatType selectEligibleFlatType(Project project) {
        // Find types the user is eligible for AND have available units
        List<FlatType> eligibleAndAvailableTypes = project.getFlatTypes().entrySet().stream()
                .filter(entry -> eligibilityService.canApplyForFlatType(currentUser, entry.getKey())
                                 && entry.getValue().getAvailableUnits() > 0)
                .map(Map.Entry::getKey)
                .sorted() // Sort by enum order
                .collect(Collectors.toList());

        if (eligibleAndAvailableTypes.isEmpty()) {
            System.out.println("There are no flat types available in this project that you are eligible for.");
            return null;
        }

        if (eligibleAndAvailableTypes.size() == 1) {
            FlatType onlyOption = eligibleAndAvailableTypes.get(0);
            System.out.println("You will be applying for the only eligible and available type: "
                    + onlyOption.getDisplayName() + ".");
            return onlyOption;
        } else {
            System.out.println("Select the flat type you want to apply for:");
            for (int i = 0; i < eligibleAndAvailableTypes.size(); i++) {
                System.out.println((i + 1) + ". " + eligibleAndAvailableTypes.get(i).getDisplayName());
            }
            int typeChoice = InputUtils.getIntInput(scanner, "Enter choice (or 0 to cancel): ", 0, eligibleAndAvailableTypes.size());

            if (typeChoice == 0) {
                System.out.println("Application cancelled.");
                return null;
            }
            return eligibleAndAvailableTypes.get(typeChoice - 1);
        }
    }

    public void viewMyApplication() {
        if (!(currentUser instanceof Applicant)) return;
        Applicant applicant = (Applicant) currentUser;

        // Ensure applicant state is up-to-date (optional, depends on sync strategy)
        // applicationService.synchronizeApplicantStatus(applicant);

        String projectName = applicant.getAppliedProjectName();
        ApplicationStatus status = applicant.getApplicationStatus();

        if (projectName == null || status == null) {
            System.out.println("\nYou do not have any current or past BTO application records.");
            return;
        }

        // Find the detailed application record using the service
        BTOApplication application = applicationService.findApplicationByApplicantAndProject(applicant.getNric(), projectName);
        if (application == null) {
            // This indicates an inconsistency between Applicant object state and repository data
            System.err.println(
                    "Error: Your profile indicates an application, but the detailed record could not be found. Please contact support or try again later.");
            // Optionally clear the applicant's state?
            // applicant.clearApplicationState();
            return;
        }

        // Find project details (might be null if project was deleted)
        Project project = projectService.findProjectByName(projectName);

        System.out.println("\n--- Your BTO Application ---");
        System.out.println("Project Name: " + projectName);
        System.out.println("Neighborhood: " + (project != null ? project.getNeighborhood() : "(Project details not found)"));
        System.out.println("Flat Type Applied For: "
                + (application.getFlatTypeApplied() != null ? application.getFlatTypeApplied().getDisplayName() : "N/A"));
        System.out.println("Application Status: " + status); // Use status from Applicant object (should match application.getStatus())
        if (status == ApplicationStatus.BOOKED && applicant.getBookedFlatType() != null) {
            System.out.println("Booked Flat Type: " + applicant.getBookedFlatType().getDisplayName());
        }
        System.out.println("Application Date: " + DateUtils.formatDate(application.getApplicationDate()));
    }

    public void requestWithdrawal() {
        if (!(currentUser instanceof Applicant)) return;
        Applicant applicant = (Applicant) currentUser;

        // Ensure applicant state is up-to-date before checking eligibility
        // applicationService.synchronizeApplicantStatus(applicant);

        String currentProject = applicant.getAppliedProjectName();
        ApplicationStatus currentStatus = applicant.getApplicationStatus();

        if (currentProject == null || currentStatus == null) {
            System.out.println("You do not have an application to withdraw.");
            return;
        }

        // Check eligibility based on current status
        if (currentStatus != ApplicationStatus.PENDING &&
            currentStatus != ApplicationStatus.SUCCESSFUL &&
            currentStatus != ApplicationStatus.BOOKED) {
            System.out.println("Your application status (" + currentStatus + ") is not eligible for withdrawal request.");
            System.out.println("You can only request withdrawal if your status is PENDING, SUCCESSFUL, or BOOKED.");
            return;
        }

        // Confirm with user
        System.out.println("\n--- Request Application Withdrawal ---");
        System.out.println("Project: " + currentProject);
        System.out.println("Current Status: " + currentStatus);
        boolean confirm = InputUtils.getConfirmation(scanner, "Are you sure you want to request withdrawal for this application? Manager approval is required.");

        if (confirm) {
            // Delegate withdrawal request to the service
            boolean success = applicationService.requestWithdrawal(applicant);
            // Success/error message printed within the service
        } else {
            System.out.println("Withdrawal request cancelled.");
        }
    }

    public void submitEnquiry() {
        System.out.println("\n--- Submit Enquiry ---");
        // Get projects visible to the user (not necessarily open/active)
        List<Project> viewableProjects = projectService.getVisibleProjects(currentUser);
        Project selectedProject = null;

        if (!viewableProjects.isEmpty()) {
            projectDisplayService.displayProjectList(viewableProjects, "Select Project to Enquire About (Optional)", currentUser);
            selectedProject = projectDisplayService.selectProjectFromList(viewableProjects, scanner);
        } else {
            System.out.println("No projects currently visible to you.");
        }

        String projectNameInput;
        if (selectedProject != null) {
            projectNameInput = selectedProject.getProjectName();
            System.out.println("Enquiring about: " + projectNameInput);
        } else {
            if (!viewableProjects.isEmpty()) {
                System.out.println("No project selected from list, or you cancelled.");
            }
            // Allow manual entry even if no projects are visible/selected
            projectNameInput = InputUtils.getStringInput(scanner, "Enter the exact Project Name you want to enquire about: ", false);
            if (projectService.findProjectByName(projectNameInput) == null) {
                System.out.println("Warning: Project '" + projectNameInput
                        + "' not found in current listings, but submitting enquiry anyway.");
            }
        }

        String text = InputUtils.getStringInput(scanner, "Enter your enquiry text: ", false);

        // Submit via service
        boolean success = enquiryService.submitEnquiry(currentUser, projectNameInput, text);
        // Success message printed within service
    }

    public void viewMyEnquiries() {
        System.out.println("\n--- Your Enquiries ---");
        List<Enquiry> myEnquiries = enquiryService.getEnquiriesByApplicant(currentUser.getNric());

        if (myEnquiries.isEmpty()) {
            System.out.println("You have not submitted any enquiries.");
            return;
        }

        for (int i = 0; i < myEnquiries.size(); i++) {
            Enquiry e = myEnquiries.get(i);
            System.out.printf("%d. ID: %s | Project: %s | Date: %s\n",
                    i + 1, e.getEnquiryId(), e.getProjectName(), DateUtils.formatDate(e.getEnquiryDate()));
            System.out.println("   Enquiry: " + e.getEnquiryText());
            if (e.isReplied()) {
                System.out.printf("   Reply (by %s on %s): %s\n",
                        e.getRepliedByNric() != null ? e.getRepliedByNric() : "N/A",
                        e.getReplyDate() != null ? DateUtils.formatDate(e.getReplyDate()) : "N/A",
                        e.getReplyText());
            } else {
                System.out.println("   Reply: (Pending)");
            }
            System.out.println("----------------------------------------");
        }
    }

    public void editMyEnquiry() {
        System.out.println("\n--- Edit Enquiry ---");
        // Get user's unreplied enquiries
        List<Enquiry> editableEnquiries = enquiryService.getEnquiriesByApplicant(currentUser.getNric())
                .stream()
                .filter(e -> !e.isReplied())
                .collect(Collectors.toList()); // Already sorted by date descending from getEnquiriesByApplicant

        if (editableEnquiries.isEmpty()) {
            System.out.println("You have no enquiries that can be edited (must not be replied to yet).");
            return;
        }

        System.out.println("Select enquiry to edit:");
        for (int i = 0; i < editableEnquiries.size(); i++) {
            Enquiry e = editableEnquiries.get(i);
            // Limit text display length if needed
            String snippet = e.getEnquiryText().length() > 50 ? e.getEnquiryText().substring(0, 47) + "..." : e.getEnquiryText();
            System.out.printf("%d. ID: %s | Project: %s | Text: %s\n",
                    i + 1, e.getEnquiryId(), e.getProjectName(), snippet);
        }

        int choice = InputUtils.getIntInput(scanner, "Enter choice (or 0 to cancel): ", 0, editableEnquiries.size());
        if (choice == 0) {
            System.out.println("Operation cancelled.");
            return;
        }

        Enquiry enquiryToEdit = editableEnquiries.get(choice - 1);
        String newText = InputUtils.getStringInput(scanner, "Enter new enquiry text: ", false);

        // Edit via service
        boolean success = enquiryService.editEnquiry(enquiryToEdit, newText);
        // Success/error message printed within service
    }

    public void deleteMyEnquiry() {
        System.out.println("\n--- Delete Enquiry ---");
        // Get user's unreplied enquiries
        List<Enquiry> deletableEnquiries = enquiryService.getEnquiriesByApplicant(currentUser.getNric())
                .stream()
                .filter(e -> !e.isReplied())
                .collect(Collectors.toList()); // Already sorted

        if (deletableEnquiries.isEmpty()) {
            System.out.println("You have no enquiries that can be deleted (must not be replied to yet).");
            return;
        }

        System.out.println("Select enquiry to delete:");
         for (int i = 0; i < deletableEnquiries.size(); i++) {
            Enquiry e = deletableEnquiries.get(i);
            String snippet = e.getEnquiryText().length() > 50 ? e.getEnquiryText().substring(0, 47) + "..." : e.getEnquiryText();
            System.out.printf("%d. ID: %s | Project: %s | Text: %s\n",
                    i + 1, e.getEnquiryId(), e.getProjectName(), snippet);
        }

        int choice = InputUtils.getIntInput(scanner, "Enter choice (or 0 to cancel): ", 0, deletableEnquiries.size());
        if (choice == 0) {
            System.out.println("Operation cancelled.");
            return;
        }

        Enquiry enquiryToDelete = deletableEnquiries.get(choice - 1);
        boolean confirm = InputUtils.getConfirmation(scanner, "Are you sure you want to delete enquiry " + enquiryToDelete.getEnquiryId() + "?");

        if (confirm) {
            // Delete via service
            boolean success = enquiryService.deleteEnquiry(enquiryToDelete);
            // Success/error message printed within service
        } else {
            System.out.println("Deletion cancelled.");
        }
    }

    // Method to apply filters (delegated to FilterService)
    public void applyFilters() {
        System.out.println("\n--- Apply/Clear Filters ---");
        System.out.print("Enter neighborhood to filter by (current: "
                + (filterService.getLocationFilter() == null ? "Any" : filterService.getLocationFilter()) + ", leave blank to clear): ");
        String loc = scanner.nextLine().trim();
        filterService.setLocationFilter(loc); // Service handles empty string logic

        System.out.print("Enter flat type to filter by (TWO_ROOM, THREE_ROOM, current: "
                + (filterService.getFlatTypeFilter() == null ? "Any" : filterService.getFlatTypeFilter()) + ", leave blank to clear): ");
        String typeStr = scanner.nextLine().trim();
        if (typeStr.isEmpty()) {
            filterService.setFlatTypeFilter(null);
        } else {
            try {
                FlatType parsedType = FlatType.fromString(typeStr); // Use enum parser
                if (parsedType != null) {
                    filterService.setFlatTypeFilter(parsedType);
                } else {
                    System.out.println("Invalid flat type entered. Filter not changed.");
                }
            } catch (IllegalArgumentException e) {
                // Should not happen with fromString returning null, but good practice
                System.out.println("Invalid flat type format. Filter not changed.");
            }
        }
        System.out.println("Filters updated. Current filters: " + filterService.getCurrentFilterStatus());
    }

     // Method to change password (delegated to AuthService)
     public boolean changePassword() {
         System.out.println("\n--- Change Password ---");
         System.out.print("Enter current password: ");
         String oldPassword = scanner.nextLine();
         System.out.print("Enter new password: ");
         String newPassword = scanner.nextLine();
         System.out.print("Confirm new password: ");
         String confirmPassword = scanner.nextLine();

         if (!newPassword.equals(confirmPassword)) {
             System.out.println("New passwords do not match. Password not changed.");
             return false;
         }
         // Other checks (empty, same as old) handled by AuthService.changePassword

         // Delegate to auth service
         return authService.changePassword(currentUser, oldPassword, newPassword);
         // Success/error messages printed within service
     }
}
```

Controllers/ManagerController.java
```java
package Controllers;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.FlatType;
import Enums.MaritalStatus;
import Enums.OfficerRegistrationStatus;
import Enums.ApplicationStatus;
import Interfaces.Services.*; // Import all service interfaces
import Models.*; // Import all models
import Utils.DateUtils;
import Utils.InputUtils;

public class ManagerController {

    private final Scanner scanner;
    private final User currentUser; // Should be HDBManager
    // Service Dependencies (Injected)
    private final IAuthService authService;
    private final IProjectService projectService;
    private final IApplicationService applicationService;
    private final IEnquiryService enquiryService;
    private final IEligibilityService eligibilityService;
    private final IFilterService filterService;
    private final IProjectDisplayService projectDisplayService;
    private final IOfficerRegistrationService officerRegistrationService;
    private final IReportService reportService;
    private final IUserRepository userRepository; // Needed for officer/applicant details

    public ManagerController(Scanner scanner, User currentUser, IAuthService authService,
                             IProjectService projectService, IApplicationService applicationService,
                             IEnquiryService enquiryService, IEligibilityService eligibilityService,
                             IFilterService filterService, IProjectDisplayService projectDisplayService,
                             IOfficerRegistrationService officerRegistrationService, IReportService reportService,
                             IUserRepository userRepository) {
        this.scanner = scanner;
        this.currentUser = currentUser;
        this.authService = authService;
        this.projectService = projectService;
        this.applicationService = applicationService;
        this.enquiryService = enquiryService;
        this.eligibilityService = eligibilityService;
        this.filterService = filterService;
        this.projectDisplayService = projectDisplayService;
        this.officerRegistrationService = officerRegistrationService;
        this.reportService = reportService;
        this.userRepository = userRepository;

        if (!(currentUser instanceof HDBManager)) {
            // This should not happen if controller is instantiated correctly
            throw new IllegalStateException("ManagerController initialized with non-manager user.");
        }
    }

    private HDBManager getCurrentManager() {
        return (HDBManager) currentUser;
    }

    public void createProject() {
        System.out.println("\n--- Create New BTO Project ---");

        String projectName;
        while (true) {
            projectName = InputUtils.getStringInput(scanner, "Enter Project Name: ", false);
            if (projectService.findProjectByName(projectName) != null) {
                System.out.println("Project name already exists. Please choose a unique name.");
            } else {
                break;
            }
        }

        String neighborhood = InputUtils.getStringInput(scanner, "Enter Neighborhood: ", false);

        Map<FlatType, FlatTypeDetails> flatTypes = new HashMap<>();
        System.out.println("--- Flat Type Details ---");
        int units2Room = InputUtils.getIntInput(scanner, "Enter total number of 2-Room units (0 if none): ", 0, 9999);
        if (units2Room > 0) {
            double price2Room = InputUtils.getDoubleInput(scanner, "Enter selling price for 2-Room units: $", 0, Double.MAX_VALUE);
            flatTypes.put(FlatType.TWO_ROOM, new FlatTypeDetails(units2Room, units2Room, price2Room)); // Available = Total initially
        }
        int units3Room = InputUtils.getIntInput(scanner, "Enter total number of 3-Room units (0 if none): ", 0, 9999);
        if (units3Room > 0) {
            double price3Room = InputUtils.getDoubleInput(scanner, "Enter selling price for 3-Room units: $", 0, Double.MAX_VALUE);
            flatTypes.put(FlatType.THREE_ROOM, new FlatTypeDetails(units3Room, units3Room, price3Room)); // Available = Total initially
        }

        if (flatTypes.isEmpty()) {
            System.out.println("Error: Project must have at least one type of flat (2-Room or 3-Room). Creation cancelled.");
            return;
        }

        Date openingDate;
        Date closingDate;
        while (true) {
            openingDate = InputUtils.getDateInput(scanner, "Enter Application Opening Date (yyyy-MM-dd): ", false);
            closingDate = InputUtils.getDateInput(scanner, "Enter Application Closing Date (yyyy-MM-dd): ", false);

            if (closingDate.before(openingDate)) {
                System.out.println("Closing date cannot be before opening date. Please re-enter.");
                continue;
            }

            // Check for overlap before proceeding
            Project tempProject = new Project("__temp__", "__temp__", flatTypes, openingDate, closingDate, getCurrentManager().getNric(), 1, List.of(), false);
            boolean overlaps = projectService.getAllProjects().stream()
                .filter(p -> p.getManagerNric().equals(getCurrentManager().getNric()))
                .anyMatch(existingProject -> projectService.checkDateOverlap(tempProject, existingProject));

            if (overlaps) {
                 System.out.println("Error: The specified application period overlaps with another project you manage. Please enter different dates.");
            } else {
                 break; // Dates are valid and don't overlap
            }
        }

        int maxOfficers = InputUtils.getIntInput(scanner, "Enter Maximum HDB Officer Slots (1-10): ", 1, 10);

        // Delegate creation to the service
        boolean success = projectService.createProject(projectName, neighborhood, flatTypes, openingDate, closingDate, getCurrentManager(), maxOfficers);
        // Success/error message printed by service
    }

    public void editProject() {
        System.out.println("\n--- Edit BTO Project ---");
        // Get projects managed by this manager (filters applied by service)
        List<Project> myProjects = projectService.getManagedProjects(currentUser.getNric());
        if (myProjects.isEmpty()) {
            System.out.println("You are not managing any projects" + (!filterService.getCurrentFilterStatus().contains("Any") ? " matching the current filters." : "."));
            return;
        }

        projectDisplayService.displayProjectList(myProjects, "Select Project to Edit", currentUser);
        Project projectToEdit = projectDisplayService.selectProjectFromList(myProjects, scanner);
        if (projectToEdit == null) return;

        System.out.println("Editing Project: " + projectToEdit.getProjectName() + " (Leave blank to keep current value)");

        // --- Neighborhood ---
        System.out.print("Enter new Neighborhood [" + projectToEdit.getNeighborhood() + "]: ");
        String newNeighborhoodInput = scanner.nextLine().trim();
        String newNeighborhood = newNeighborhoodInput.isEmpty() ? null : newNeighborhoodInput; // Null if blank

        // --- Flat Types (Prices only) ---
        Map<FlatType, FlatTypeDetails> currentFlatTypes = projectToEdit.getFlatTypes();
        // Create a mutable copy to modify prices
        Map<FlatType, FlatTypeDetails> newFlatTypesMap = new HashMap<>();
        currentFlatTypes.forEach((type, details) -> newFlatTypesMap.put(type,
                new FlatTypeDetails(details.getTotalUnits(), details.getAvailableUnits(), details.getSellingPrice())));

        for (FlatType type : FlatType.values()) {
            FlatTypeDetails currentDetails = newFlatTypesMap.get(type);
            if (currentDetails != null) {
                System.out.println("--- Edit " + type.getDisplayName() + " ---");
                double currentPrice = currentDetails.getSellingPrice();
                System.out.print("Enter new selling price [" + String.format("%.2f", currentPrice)
                        + "] (leave blank to keep): $");
                String priceInput = scanner.nextLine().trim();
                if (!priceInput.isEmpty()) {
                    try {
                        double newPrice = Double.parseDouble(priceInput);
                        if (newPrice >= 0) {
                            currentDetails.setSellingPrice(newPrice); // Modify the copy
                        } else {
                            System.out.println("Price cannot be negative. Keeping original price.");
                        }
                    } catch (NumberFormatException e) {
                        System.out.println("Invalid price format. Keeping original price.");
                    }
                }
            }
        }
        // Use the modified map if prices changed, otherwise null
        Map<FlatType, FlatTypeDetails> newFlatTypes = newFlatTypesMap.equals(currentFlatTypes) ? null : newFlatTypesMap;


        // --- Dates ---
        Date originalOpening = projectToEdit.getApplicationOpeningDate();
        Date originalClosing = projectToEdit.getApplicationClosingDate();
        Date newOpeningDate = InputUtils.getDateInput(scanner, "Enter new Opening Date (yyyy-MM-dd) ["
                + DateUtils.formatDate(originalOpening) + "] (leave blank to keep): ", true); // Allow blank
        Date newClosingDate = InputUtils.getDateInput(scanner, "Enter new Closing Date (yyyy-MM-dd) ["
                + DateUtils.formatDate(originalClosing) + "] (leave blank to keep): ", true); // Allow blank

        // --- Max Officer Slots ---
        int currentMaxSlots = projectToEdit.getMaxOfficerSlots();
        int currentApprovedCount = projectToEdit.getApprovedOfficerNrics().size();
        System.out.print("Enter new Max Officer Slots [" + currentMaxSlots + "] (min " + currentApprovedCount
                + ", max 10, leave blank to keep): ");
        String slotsInput = scanner.nextLine().trim();
        int newMaxSlots = -1; // Indicate no change
        if (!slotsInput.isEmpty()) {
            try {
                int inputSlots = Integer.parseInt(slotsInput);
                 if (inputSlots >= currentApprovedCount && inputSlots <= 10) {
                     newMaxSlots = inputSlots;
                 } else {
                     System.out.println("Max slots must be between " + currentApprovedCount + " and 10. Keeping original value.");
                     newMaxSlots = -2; // Indicate invalid input, keep original
                 }
            } catch (NumberFormatException e) {
                System.out.println("Invalid number format. Max slots not changed.");
                newMaxSlots = -2; // Indicate invalid input, keep original
            }
        }
        if (newMaxSlots == -1 || newMaxSlots == -2) { // If blank or invalid
             newMaxSlots = projectToEdit.getMaxOfficerSlots(); // Keep original
        }


        // --- Call Service to Edit ---
        boolean success = projectService.editProjectDetails(projectToEdit, newNeighborhood, newFlatTypes, newOpeningDate, newClosingDate, newMaxSlots);
        // Success/error messages handled by service
    }

    public void deleteProject() {
        System.out.println("\n--- Delete BTO Project ---");
        // Get managed projects (ignoring filters for deletion)
        List<Project> myProjects = projectService.getAllProjects().stream()
                                     .filter(p -> p.getManagerNric().equals(currentUser.getNric()))
                                     .collect(Collectors.toList());
        if (myProjects.isEmpty()) {
            System.out.println("You are not managing any projects.");
            return;
        }

        projectDisplayService.displayProjectList(myProjects, "Select Project to Delete", currentUser);
        Project projectToDelete = projectDisplayService.selectProjectFromList(myProjects, scanner);
        if (projectToDelete == null) return;

        // Confirmation
        boolean confirm = InputUtils.getConfirmation(scanner, "Are you sure you want to permanently delete project '" + projectToDelete.getProjectName()
                + "'? This will also remove associated historical applications/registrations/enquiries.");

        if (confirm) {
            // Delegate deletion to the service (handles checks and cascading)
            boolean success = projectService.deleteProject(projectToDelete);
            // Success/error messages printed by service
        } else {
            System.out.println("Deletion cancelled.");
        }
    }

    public void toggleProjectVisibility() {
        System.out.println("\n--- Toggle Project Visibility ---");
        // Get managed projects (ignoring filters)
        List<Project> myProjects = projectService.getAllProjects().stream()
                                     .filter(p -> p.getManagerNric().equals(currentUser.getNric()))
                                     .collect(Collectors.toList());
        if (myProjects.isEmpty()) {
            System.out.println("You are not managing any projects.");
            return;
        }

        projectDisplayService.displayProjectList(myProjects, "Select Project to Toggle Visibility", currentUser);
        Project projectToToggle = projectDisplayService.selectProjectFromList(myProjects, scanner);
        if (projectToToggle == null) return;

        // Delegate toggle to service
        boolean success = projectService.toggleProjectVisibility(projectToToggle);
        // Message printed by service
    }

    public void viewAllProjects() {
        System.out.println("\n--- View All Projects (Manager View) ---");
        // Get all projects and apply current view filters
        List<Project> allProjects = projectService.getAllProjects();
        List<Project> filteredProjects = filterService.applyFilters(allProjects);
        projectDisplayService.displayProjectList(filteredProjects, "All BTO Projects", currentUser);
    }

    public void viewMyProjects() {
        System.out.println("\n--- View My Managed Projects ---");
        // Service method already gets managed projects and applies filters
        List<Project> myProjects = projectService.getManagedProjects(currentUser.getNric());
        projectDisplayService.displayProjectList(myProjects, "Projects Managed By You", currentUser);
         if (myProjects.isEmpty()) {
             System.out.println("You are not managing any projects" + (!filterService.getCurrentFilterStatus().contains("Any") ? " matching the current filters." : "."));
         }
    }

    public void manageOfficerRegistrations() {
        System.out.println("\n--- Manage HDB Officer Registrations ---");
        // Get managed projects (ignore filters for selection)
        List<Project> myProjects = projectService.getAllProjects().stream()
                                     .filter(p -> p.getManagerNric().equals(currentUser.getNric()))
                                     .collect(Collectors.toList());
        if (myProjects.isEmpty()) {
            System.out.println("You are not managing any projects.");
            return;
        }

        System.out.println("Select project to manage registrations for:");
        projectDisplayService.displayProjectList(myProjects, "Select Project", currentUser);
        Project selectedProject = projectDisplayService.selectProjectFromList(myProjects, scanner);
        if (selectedProject == null) return;

        System.out.println("\n--- Registrations for Project: " + selectedProject.getProjectName() + " ---");
        System.out.println("Officer Slots: " + selectedProject.getApprovedOfficerNrics().size() + " / "
                + selectedProject.getMaxOfficerSlots() + " (Remaining: " + selectedProject.getRemainingOfficerSlots() + ")");

        // Get pending registrations for this project
        List<OfficerRegistration> pendingRegistrations = officerRegistrationService.getPendingRegistrationsForProject(selectedProject.getProjectName());

        System.out.println("\n--- Pending Registrations ---");
        if (pendingRegistrations.isEmpty()) {
            System.out.println("(None)");
        } else {
            Map<String, User> allUsers = userRepository.getAllUsers(); // Get users for name lookup
            for (int i = 0; i < pendingRegistrations.size(); i++) {
                OfficerRegistration reg = pendingRegistrations.get(i);
                User officerUser = allUsers.get(reg.getOfficerNric());
                System.out.printf("%d. NRIC: %s | Name: %-15s | Date: %s\n",
                        i + 1, reg.getOfficerNric(),
                        officerUser != null ? officerUser.getName() : "N/A",
                        DateUtils.formatDate(reg.getRegistrationDate()));
            }

            int choice = InputUtils.getIntInput(scanner, "Enter number to Approve/Reject (or 0 to skip): ", 0, pendingRegistrations.size());
            if (choice >= 1) {
                OfficerRegistration regToProcess = pendingRegistrations.get(choice - 1);
                User officerUser = userRepository.findUserByNric(regToProcess.getOfficerNric()); // Find specific user

                // Validate user is still an officer
                if (!(officerUser instanceof HDBOfficer)) {
                    System.out.println("Error: User " + regToProcess.getOfficerNric()
                            + " is no longer a valid Officer. Rejecting registration.");
                    officerRegistrationService.rejectRegistration(regToProcess);
                    return; // Exit after processing one
                }
                HDBOfficer officer = (HDBOfficer) officerUser;

                // Check for overlap before prompting A/R
                 if (eligibilityService.isOfficerHandlingOverlappingProject(officer, selectedProject)) {
                     System.out.println("Cannot approve. Officer is already handling another project with overlapping dates.");
                     // Optionally auto-reject or just prevent approval? Let's prevent and let manager decide.
                 } else {
                     System.out.print("Approve or Reject? (A/R): ");
                     String action = scanner.nextLine().trim().toUpperCase();

                     if (action.equals("A")) {
                         // Approve via service (handles slot check again, updates project and reg)
                         boolean success = officerRegistrationService.approveRegistration(regToProcess, selectedProject);
                         // Message printed by service
                     } else if (action.equals("R")) {
                         // Reject via service
                         boolean success = officerRegistrationService.rejectRegistration(regToProcess);
                         // Message printed by service
                     } else {
                         System.out.println("Invalid action.");
                     }
                 }
            }
        }

        // Display other statuses for context
        System.out.println("\n--- Approved Officers for this Project ---");
        List<String> approvedNrics = selectedProject.getApprovedOfficerNrics();
        if (approvedNrics.isEmpty()) {
            System.out.println("(None)");
        } else {
            Map<String, User> allUsers = userRepository.getAllUsers();
            approvedNrics.forEach(nric -> System.out.println("- NRIC: " + nric
                    + (allUsers.containsKey(nric) ? " (Name: " + allUsers.get(nric).getName() + ")" : " (Name: N/A)")));
        }

        System.out.println("\n--- Rejected Registrations for this Project ---");
        List<OfficerRegistration> rejected = officerRegistrationService.getRegistrationsByProject(selectedProject.getProjectName())
                .stream()
                .filter(r -> r.getStatus() == OfficerRegistrationStatus.REJECTED)
                .collect(Collectors.toList());
        if (rejected.isEmpty()) {
            System.out.println("(None)");
        } else {
            rejected.forEach(reg -> System.out.println(
                    "- NRIC: " + reg.getOfficerNric() + " | Date: " + DateUtils.formatDate(reg.getRegistrationDate())));
        }
    }

    public void manageApplications() {
        System.out.println("\n--- Manage BTO Applications ---");
        // Get managed projects (ignore filters for selection)
        List<Project> myProjects = projectService.getAllProjects().stream()
                                     .filter(p -> p.getManagerNric().equals(currentUser.getNric()))
                                     .collect(Collectors.toList());
        if (myProjects.isEmpty()) {
            System.out.println("You are not managing any projects.");
            return;
        }

        System.out.println("Select project to manage applications for:");
        projectDisplayService.displayProjectList(myProjects, "Select Project", currentUser);
        Project selectedProject = projectDisplayService.selectProjectFromList(myProjects, scanner);
        if (selectedProject == null) return;

        System.out.println("\n--- Applications for Project: " + selectedProject.getProjectName() + " ---");

        // Get all applications for the project
        List<BTOApplication> projectApplications = applicationService.getAllApplications().values().stream()
                .filter(app -> app.getProjectName().equals(selectedProject.getProjectName()))
                .sorted(Comparator.comparing(BTOApplication::getApplicationDate))
                .collect(Collectors.toList());

        if (projectApplications.isEmpty()) {
            System.out.println("No applications found for this project.");
            return;
        }

        // Filter for PENDING applications
        List<BTOApplication> pendingApps = projectApplications.stream()
                .filter(app -> app.getStatus() == ApplicationStatus.PENDING)
                .collect(Collectors.toList());

        System.out.println("--- Pending Applications ---");
        if (pendingApps.isEmpty()) {
            System.out.println("(None)");
        } else {
            Map<String, User> allUsers = userRepository.getAllUsers(); // For name lookup
            for (int i = 0; i < pendingApps.size(); i++) {
                BTOApplication app = pendingApps.get(i);
                User applicant = allUsers.get(app.getApplicantNric());
                System.out.printf("%d. NRIC: %s | Name: %-15s | Type: %-8s | Date: %s\n",
                        i + 1, app.getApplicantNric(),
                        applicant != null ? applicant.getName() : "N/A",
                        app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A",
                        DateUtils.formatDate(app.getApplicationDate()));
            }

            int choice = InputUtils.getIntInput(scanner, "Enter number to Approve/Reject (or 0 to skip): ", 0, pendingApps.size());
            if (choice >= 1) {
                BTOApplication appToProcess = pendingApps.get(choice - 1);
                User applicantUser = userRepository.findUserByNric(appToProcess.getApplicantNric());

                // Validate applicant exists and is Applicant type
                if (!(applicantUser instanceof Applicant)) {
                    System.out.println("Error: Applicant data not found or invalid for NRIC "
                            + appToProcess.getApplicantNric() + ". Rejecting application.");
                    applicationService.rejectApplication(appToProcess); // Reject via service
                    return; // Exit after processing one
                }
                // Applicant applicant = (Applicant) applicantUser; // Not strictly needed here

                System.out.print("Approve or Reject? (A/R): ");
                String action = scanner.nextLine().trim().toUpperCase();

                if (action.equals("A")) {
                    // Approve via service (handles checks)
                    boolean success = applicationService.approveApplication(appToProcess);
                    // Message printed by service
                } else if (action.equals("R")) {
                    // Reject via service
                    boolean success = applicationService.rejectApplication(appToProcess);
                    // Message printed by service
                } else {
                    System.out.println("Invalid action.");
                }
            }
        }

        // Display other statuses
        System.out.println("\n--- Other Application Statuses ---");
        Map<String, User> allUsers = userRepository.getAllUsers(); // For name lookup
        projectApplications.stream()
                .filter(app -> app.getStatus() != ApplicationStatus.PENDING)
                .forEach(app -> {
                    User applicant = allUsers.get(app.getApplicantNric());
                    System.out.printf("- NRIC: %s | Name: %-15s | Type: %-8s | Status: %s\n",
                            app.getApplicantNric(),
                            applicant != null ? applicant.getName() : "N/A",
                            app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A",
                            app.getStatus());
                });
    }

    public void manageWithdrawalRequests() {
        System.out.println("\n--- Manage Withdrawal Requests ---");
        // Get names of projects managed by current user
        List<String> myProjectNames = projectService.getAllProjects().stream()
                .filter(p -> p.getManagerNric().equals(currentUser.getNric()))
                .map(Project::getProjectName)
                .collect(Collectors.toList());

        if (myProjectNames.isEmpty()) {
            System.out.println("You are not managing any projects.");
            return;
        }

        // Find applications pending withdrawal for managed projects
        List<BTOApplication> pendingWithdrawals = applicationService.getAllApplications().values().stream()
                .filter(app -> app.getStatus() == ApplicationStatus.PENDING_WITHDRAWAL)
                .filter(app -> myProjectNames.contains(app.getProjectName()))
                .sorted(Comparator.comparing(BTOApplication::getApplicationDate))
                .collect(Collectors.toList());

        if (pendingWithdrawals.isEmpty()) {
            System.out.println("No pending withdrawal requests found for the projects you manage.");
            return;
        }

        System.out.println("--- Pending Withdrawal Requests ---");
        Map<String, User> allUsers = userRepository.getAllUsers(); // For name lookup
        for (int i = 0; i < pendingWithdrawals.size(); i++) {
            BTOApplication app = pendingWithdrawals.get(i);
            User applicantUser = allUsers.get(app.getApplicantNric());
            ApplicationStatus statusBefore = app.getStatusBeforeWithdrawal(); // Get stored status

            System.out.printf("%d. NRIC: %s | Name: %-15s | Project: %-15s | Type: %-8s | App Date: %s | Original Status: %s\n",
                    i + 1,
                    app.getApplicantNric(),
                    applicantUser != null ? applicantUser.getName() : "N/A",
                    app.getProjectName(),
                    app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A",
                    DateUtils.formatDate(app.getApplicationDate()),
                    statusBefore != null ? statusBefore : "(Unknown/Infer)"); // Indicate if status was stored
        }

        int choice = InputUtils.getIntInput(scanner, "Enter number to Approve/Reject withdrawal (or 0 to skip): ", 0, pendingWithdrawals.size());
        if (choice >= 1) {
            BTOApplication appToProcess = pendingWithdrawals.get(choice - 1);
            User applicantUser = userRepository.findUserByNric(appToProcess.getApplicantNric());

            // Validate applicant
            if (!(applicantUser instanceof Applicant)) {
                System.out.println("Error: Applicant data not found or invalid for NRIC "
                        + appToProcess.getApplicantNric() + ". Cannot process withdrawal.");
                return; // Exit after processing one
            }
            // Applicant applicant = (Applicant) applicantUser; // Not needed directly here

            System.out.print("Approve or Reject withdrawal request? (A/R): ");
            String action = scanner.nextLine().trim().toUpperCase();

            if (action.equals("A")) {
                // Approve via service (handles unit release, status updates)
                boolean success = applicationService.approveWithdrawal(appToProcess);
                // Message printed by service
            } else if (action.equals("R")) {
                // Reject via service (handles reverting status)
                boolean success = applicationService.rejectWithdrawal(appToProcess);
                // Message printed by service
            } else {
                System.out.println("Invalid action.");
            }
        }
    }

    public void generateApplicantReport() {
        System.out.println("\n--- Generate Applicant Report (Booked Flats) ---");

        System.out.println("Filter by project:");
        System.out.println("1. All Projects Managed By You (Respecting View Filters)");
        System.out.println("2. A Specific Project Managed By You");
        System.out.println("0. Cancel");
        int projectFilterChoice = InputUtils.getIntInput(scanner, "Enter choice: ", 0, 2);

        List<String> projectNamesToReportOn;
        if (projectFilterChoice == 0) return;

        if (projectFilterChoice == 1) {
            // Get managed projects respecting current view filters
            projectNamesToReportOn = projectService.getManagedProjects(currentUser.getNric())
                                        .stream()
                                        .map(Project::getProjectName)
                                        .collect(Collectors.toList());
            if (projectNamesToReportOn.isEmpty()) {
                 System.out.println("You are not managing any projects" + (!filterService.getCurrentFilterStatus().contains("Any") ? " matching the current filters." : "."));
                 return;
            }
            System.out.println("Reporting on all projects you manage"
                    + (!filterService.getCurrentFilterStatus().contains("Any") ? " (matching current view filters)." : "."));
        } else { // Specific project
            // Get managed projects ignoring view filters for selection
            List<Project> myProjectsAll = projectService.getAllProjects().stream()
                                     .filter(p -> p.getManagerNric().equals(currentUser.getNric()))
                                     .collect(Collectors.toList());
             if (myProjectsAll.isEmpty()) {
                System.out.println("You are not managing any projects.");
                return;
            }
            projectDisplayService.displayProjectList(myProjectsAll, "Select Specific Project to Report On", currentUser);
            Project specificProject = projectDisplayService.selectProjectFromList(myProjectsAll, scanner);
            if (specificProject == null) return;
            projectNamesToReportOn = List.of(specificProject.getProjectName());
            System.out.println("Reporting specifically for project: " + specificProject.getProjectName());
        }

        // Get report filters
        System.out.print("Filter report by Flat Type (TWO_ROOM, THREE_ROOM, or leave blank for all): ");
        String typeStr = scanner.nextLine().trim();
        FlatType filterReportFlatType = typeStr.isEmpty() ? null : FlatType.fromString(typeStr);
        if (!typeStr.isEmpty() && filterReportFlatType == null) {
            System.out.println("Invalid flat type entered. Reporting for all types.");
        }

        System.out.print("Filter report by Marital Status (SINGLE, MARRIED, or leave blank for all): ");
        String maritalStr = scanner.nextLine().trim().toUpperCase();
        MaritalStatus filterMaritalStatus = null;
        if (!maritalStr.isEmpty()) {
            try {
                filterMaritalStatus = MaritalStatus.valueOf(maritalStr);
            } catch (IllegalArgumentException e) {
                System.out.println("Invalid marital status. Reporting for all statuses.");
            }
        }

        int minAge = InputUtils.getIntInput(scanner, "Filter report by Minimum Age (e.g., 21, or 0 for no minimum): ", 0, 120);
        int maxAge = InputUtils.getIntInput(scanner, "Filter report by Maximum Age (e.g., 40, or 0 for no maximum): ", 0, 120);

        // Generate report data using service
        List<BTOApplication> reportData = reportService.generateBookedApplicantReport(
                projectNamesToReportOn, filterReportFlatType, filterMaritalStatus, minAge, maxAge);

        // Display report using service
        reportService.displayApplicantReport(reportData, filterReportFlatType, filterMaritalStatus, minAge, maxAge);
    }

    public void viewAllEnquiries() {
        System.out.println("\n--- View Enquiries (ALL Projects) ---");
        List<Enquiry> allEnquiries = enquiryService.getAllEnquiries(); // Already sorted by service

        if (allEnquiries.isEmpty()) {
            System.out.println("No enquiries found in the system.");
            return;
        }

        allEnquiries.forEach(e -> {
            printEnquiryDetails(e);
            System.out.println("----------------------------------------");
        });
    }

    public void viewAndReplyToManagedEnquiries() {
        System.out.println("\n--- View/Reply Enquiries (Managed Projects) ---");
        // Get names of projects managed by current user, respecting view filters
        List<String> myManagedProjectNames = projectService.getManagedProjects(currentUser.getNric())
                                                .stream()
                                                .map(Project::getProjectName)
                                                .collect(Collectors.toList());

        if (myManagedProjectNames.isEmpty()) {
             System.out.println("You are not managing any projects" + (!filterService.getCurrentFilterStatus().contains("Any") ? " matching the current filters." : "."));
            return;
        }

        // Get unreplied enquiries for these projects
        List<Enquiry> unrepliedEnquiries = enquiryService.getUnrepliedEnquiriesForProjects(myManagedProjectNames);

        System.out.println("--- Unreplied Enquiries (Managed Projects" + (!filterService.getCurrentFilterStatus().contains("Any") ? " - Filtered" : "") + ") ---");
        if (unrepliedEnquiries.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (int i = 0; i < unrepliedEnquiries.size(); i++) {
                Enquiry e = unrepliedEnquiries.get(i);
                System.out.printf("%d. ", i + 1);
                printEnquiryDetails(e); // Use helper to print
                System.out.println("---");
            }
            int choice = InputUtils.getIntInput(scanner, "Enter the number of the enquiry to reply to (or 0 to skip): ", 0, unrepliedEnquiries.size());
            if (choice >= 1) {
                Enquiry enquiryToReply = unrepliedEnquiries.get(choice - 1);
                String replyText = InputUtils.getStringInput(scanner, "Enter your reply: ", false);
                // Reply via service
                boolean success = enquiryService.replyToEnquiry(enquiryToReply, replyText, currentUser);
                // Message printed by service
            }
        }

        // Get replied enquiries for these projects
        List<Enquiry> repliedEnquiries = enquiryService.getRepliedEnquiriesForProjects(myManagedProjectNames);
        System.out.println("\n--- Replied Enquiries (Managed Projects" + (!filterService.getCurrentFilterStatus().contains("Any") ? " - Filtered" : "") + ") ---");
        if (repliedEnquiries.isEmpty()) {
            System.out.println("(None)");
        } else {
            repliedEnquiries.forEach(e -> {
                printEnquiryDetails(e);
                System.out.println("----------------------------------------");
            });
        }
    }

    // Helper method to print enquiry details consistently
    private void printEnquiryDetails(Enquiry e) {
        if (e == null) return;
        // Optional: Look up applicant name
        User applicant = userRepository.findUserByNric(e.getApplicantNric());
        String applicantNameInfo = (applicant != null) ? " (" + applicant.getName() + ")" : "";

        System.out.printf("ID: %s | Project: %s | Applicant: %s%s | Date: %s\n",
                e.getEnquiryId(), e.getProjectName(), e.getApplicantNric(), applicantNameInfo, DateUtils.formatDate(e.getEnquiryDate()));
        System.out.println("   Enquiry: " + e.getEnquiryText());
        if (e.isReplied()) {
             // Optional: Look up replier name
             User replier = userRepository.findUserByNric(e.getRepliedByNric());
             String replierNameInfo = (replier != null) ? " (" + replier.getName() + ")" : "";
            System.out.printf("   Reply (by %s%s on %s): %s\n",
                    e.getRepliedByNric() != null ? e.getRepliedByNric() : "N/A",
                    replierNameInfo,
                    e.getReplyDate() != null ? DateUtils.formatDate(e.getReplyDate()) : "N/A",
                    e.getReplyText());
        } else {
            System.out.println("   Reply: (Pending)");
        }
    }

    // Method to apply filters (delegated to FilterService)
    public void applyFilters() {
        // Same implementation as in ApplicantController
        System.out.println("\n--- Apply/Clear Filters ---");
        System.out.print("Enter neighborhood to filter by (current: "
                + (filterService.getLocationFilter() == null ? "Any" : filterService.getLocationFilter()) + ", leave blank to clear): ");
        String loc = scanner.nextLine().trim();
        filterService.setLocationFilter(loc);

        System.out.print("Enter flat type to filter by (TWO_ROOM, THREE_ROOM, current: "
                + (filterService.getFlatTypeFilter() == null ? "Any" : filterService.getFlatTypeFilter()) + ", leave blank to clear): ");
        String typeStr = scanner.nextLine().trim();
        if (typeStr.isEmpty()) {
            filterService.setFlatTypeFilter(null);
        } else {
            try {
                FlatType parsedType = FlatType.fromString(typeStr);
                if (parsedType != null) {
                    filterService.setFlatTypeFilter(parsedType);
                } else {
                    System.out.println("Invalid flat type entered. Filter not changed.");
                }
            } catch (IllegalArgumentException e) {
                System.out.println("Invalid flat type format. Filter not changed.");
            }
        }
        System.out.println("Filters updated. Current filters: " + filterService.getCurrentFilterStatus());
    }

     // Method to change password (delegated to AuthService)
     public boolean changePassword() {
         // Same implementation as in ApplicantController
         System.out.println("\n--- Change Password ---");
         System.out.print("Enter current password: ");
         String oldPassword = scanner.nextLine();
         System.out.print("Enter new password: ");
         String newPassword = scanner.nextLine();
         System.out.print("Confirm new password: ");
         String confirmPassword = scanner.nextLine();

         if (!newPassword.equals(confirmPassword)) {
             System.out.println("New passwords do not match. Password not changed.");
             return false;
         }

         return authService.changePassword(currentUser, oldPassword, newPassword);
     }
}
```

Controllers/OfficerController.java
```java
package Controllers;

import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Interfaces.Services.*; // Import all service interfaces
import Models.*; // Import all models
import Utils.DateUtils;
import Utils.InputUtils;

// OfficerController inherits from ApplicantController to reuse applicant actions
public class OfficerController extends ApplicantController {

    // OfficerController has access to all services via ApplicantController's protected fields
    // Or we can redefine them here if needed (but inheritance makes them available)

    public OfficerController(Scanner scanner, User currentUser, IAuthService authService,
                             IProjectService projectService, IApplicationService applicationService,
                             IEnquiryService enquiryService, IEligibilityService eligibilityService,
                             IFilterService filterService, IProjectDisplayService projectDisplayService,
                             IOfficerRegistrationService officerRegistrationService,
                             IUserRepository userRepository) { // Added userRepository for booking receipt
        super(scanner, currentUser, authService, projectService, applicationService, enquiryService,
              eligibilityService, filterService, projectDisplayService, officerRegistrationService);
        // Add userRepository if needed specifically here, though ApplicantController doesn't have it.
        // Let's add it to the base constructor if needed by inherited methods, or inject separately.
        // For now, assume ApplicantController doesn't need it directly.

         if (!(currentUser instanceof HDBOfficer)) {
            throw new IllegalStateException("OfficerController initialized with non-officer user.");
        }
    }

    private HDBOfficer getCurrentOfficer() {
        return (HDBOfficer) currentUser;
    }

    public void registerForProject() {
        HDBOfficer officer = getCurrentOfficer();

        // Pre-checks using EligibilityService or officer state
        if (officer.hasActiveApplication() || officer.hasPendingWithdrawal()) {
             System.out.println("Error: Cannot register to handle a project while you have an active BTO application or pending withdrawal.");
             return;
        }

        System.out.println("\n--- Register to Handle Project ---");

        // Find projects the officer is eligible to register for
        List<Project> availableProjects = projectService.getAllProjects().stream()
                .filter(p -> eligibilityService.canOfficerRegisterForProject(officer, p))
                .sorted(Comparator.comparing(Project::getProjectName))
                .collect(Collectors.toList());

        if (availableProjects.isEmpty()) {
            System.out.println("No projects currently available for you to register for based on eligibility criteria:");
            System.out.println("- Project must have open officer slots and not be expired.");
            System.out.println("- You must not already have a registration (Pending/Approved/Rejected) for the project.");
            System.out.println("- You cannot have an active BTO application or Pending Withdrawal.");
            System.out.println("- Project dates cannot overlap with a project you handle or have a pending registration for.");
            System.out.println("- You cannot register for a project you have previously applied for.");
            return;
        }

        projectDisplayService.displayProjectList(availableProjects, "Select Project to Register For", currentUser);
        Project selectedProject = projectDisplayService.selectProjectFromList(availableProjects, scanner);

        if (selectedProject != null) {
            // Delegate registration submission to the service
            boolean success = officerRegistrationService.submitRegistration(officer, selectedProject);
            // Message printed by service
        }
    }

    public void viewRegistrationStatus() {
        HDBOfficer officer = getCurrentOfficer();
        System.out.println("\n--- Your HDB Officer Registration Status ---");

        // Get currently handled project
        Project handlingProject = eligibilityService.getOfficerHandlingProject(officer);
        if (handlingProject != null) {
            System.out.println("You are currently APPROVED and HANDLING project: " + handlingProject.getProjectName());
            System.out.println("----------------------------------------");
        }

        // Get other registrations
        List<OfficerRegistration> myRegistrations = officerRegistrationService.getRegistrationsByOfficer(officer.getNric());

        // Filter out the currently handled one if it exists
        List<OfficerRegistration> otherRegistrations = myRegistrations.stream()
                .filter(reg -> handlingProject == null || !reg.getProjectName().equals(handlingProject.getProjectName()))
                .collect(Collectors.toList()); // Already sorted by date descending from service

        if (otherRegistrations.isEmpty() && handlingProject == null) {
            System.out.println("You have no past or pending registration requests.");
        } else if (!otherRegistrations.isEmpty()) {
            System.out.println("Other Registration History/Requests:");
            for (OfficerRegistration reg : otherRegistrations) {
                System.out.printf("- Project: %-15s | Status: %-10s | Date: %s\n",
                        reg.getProjectName(), reg.getStatus(), DateUtils.formatDate(reg.getRegistrationDate()));
            }
        }
    }

    public void viewHandlingProjectDetails() {
        HDBOfficer officer = getCurrentOfficer();
        Project project = eligibilityService.getOfficerHandlingProject(officer);

        if (project == null) {
            System.out.println("You are not currently handling any project. Register for one first.");
            return;
        }

        System.out.println("\n--- Details for Handling Project: " + project.getProjectName() + " ---");
        // Display just this one project using the display service
        projectDisplayService.displayProjectList(Collections.singletonList(project), "Project Details", currentUser);
    }

    public void viewAndReplyToEnquiries() {
        HDBOfficer officer = getCurrentOfficer();
        Project handlingProject = eligibilityService.getOfficerHandlingProject(officer);

        if (handlingProject == null) {
            System.out.println("You need to be handling a project to view and reply to its enquiries.");
            return;
        }
        String handlingProjectName = handlingProject.getProjectName();

        System.out.println("\n--- Enquiries for Project: " + handlingProjectName + " ---");

        // Get unreplied enquiries for this project
        List<Enquiry> unrepliedEnquiries = enquiryService.getAllEnquiries().stream()
                .filter(e -> e.getProjectName().equalsIgnoreCase(handlingProjectName) && !e.isReplied())
                .sorted(Comparator.comparing(Enquiry::getEnquiryDate)) // Show oldest first?
                .collect(Collectors.toList());

        System.out.println("--- Unreplied Enquiries ---");
        if (unrepliedEnquiries.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (int i = 0; i < unrepliedEnquiries.size(); i++) {
                Enquiry e = unrepliedEnquiries.get(i);
                // Use helper from ManagerController? Or duplicate print logic? Let's duplicate for now.
                printOfficerEnquiryDetails(e);
                System.out.println("---");
            }
            int choice = InputUtils.getIntInput(scanner, "Enter the number of the enquiry to reply to (or 0 to skip): ", 0, unrepliedEnquiries.size());
            if (choice >= 1) {
                Enquiry enquiryToReply = unrepliedEnquiries.get(choice - 1);
                String replyText = InputUtils.getStringInput(scanner, "Enter your reply: ", false);
                // Reply via service
                boolean success = enquiryService.replyToEnquiry(enquiryToReply, replyText, currentUser);
                // Message printed by service
            }
        }

        // Get replied enquiries
        List<Enquiry> repliedEnquiries = enquiryService.getAllEnquiries().stream()
                .filter(e -> e.getProjectName().equalsIgnoreCase(handlingProjectName) && e.isReplied())
                .sorted(Comparator.comparing(Enquiry::getReplyDate).reversed()) // Show newest replies first
                .collect(Collectors.toList());

        System.out.println("\n--- Replied Enquiries ---");
        if (repliedEnquiries.isEmpty()) {
            System.out.println("(None)");
        } else {
            repliedEnquiries.forEach(e -> {
                printOfficerEnquiryDetails(e);
                System.out.println("--------------------");
            });
        }
    }

    // Specific print helper for officer view (might differ slightly from manager's)
    private void printOfficerEnquiryDetails(Enquiry e) {
         if (e == null) return;
         System.out.printf("ID: %s | Applicant: %s | Date: %s\n",
                 e.getEnquiryId(), e.getApplicantNric(), DateUtils.formatDate(e.getEnquiryDate()));
         System.out.println("   Enquiry: " + e.getEnquiryText());
         if (e.isReplied()) {
             System.out.printf("   Reply (by %s on %s): %s\n",
                     e.getRepliedByNric() != null ? e.getRepliedByNric() : "N/A",
                     e.getReplyDate() != null ? DateUtils.formatDate(e.getReplyDate()) : "N/A",
                     e.getReplyText());
         } else {
             System.out.println("   Reply: (Pending)");
         }
    }


    public void manageFlatBooking() {
        HDBOfficer officer = getCurrentOfficer();
        Project project = eligibilityService.getOfficerHandlingProject(officer);

        if (project == null) {
            System.out.println("You need to be handling a project to manage flat bookings.");
            return;
        }
        String handlingProjectName = project.getProjectName();

        System.out.println("\n--- Flat Booking Management for Project: " + handlingProjectName + " ---");

        // Find applications for this project with SUCCESSFUL status
        List<BTOApplication> successfulApps = applicationService.getAllApplications().values().stream()
                .filter(app -> app.getProjectName().equals(handlingProjectName)
                        && app.getStatus() == ApplicationStatus.SUCCESSFUL)
                .sorted(Comparator.comparing(BTOApplication::getApplicationDate)) // Process oldest first
                .collect(Collectors.toList());

        if (successfulApps.isEmpty()) {
            System.out.println("No applicants with status SUCCESSFUL found for this project.");
            return;
        }

        System.out.println("Applicants with SUCCESSFUL status (ready for booking):");
        Map<String, User> allUsers = userRepository.getAllUsers(); // For name lookup
        for (int i = 0; i < successfulApps.size(); i++) {
            BTOApplication app = successfulApps.get(i);
            User applicantUser = allUsers.get(app.getApplicantNric());
            System.out.printf("%d. NRIC: %s | Name: %-15s | Applied Type: %s | App Date: %s\n",
                    i + 1,
                    app.getApplicantNric(),
                    applicantUser != null ? applicantUser.getName() : "N/A",
                    app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A",
                    DateUtils.formatDate(app.getApplicationDate()));
        }

        int choice = InputUtils.getIntInput(scanner, "Enter the number of the applicant to process booking for (or 0 to cancel): ", 0, successfulApps.size());
        if (choice == 0) {
            System.out.println("Operation cancelled.");
            return;
        }

        BTOApplication applicationToBook = successfulApps.get(choice - 1);
        User applicantUser = userRepository.findUserByNric(applicationToBook.getApplicantNric());

        // Validate applicant data
        if (!(applicantUser instanceof Applicant)) {
            System.out.println("Error: Applicant data not found or invalid for NRIC " + applicationToBook.getApplicantNric());
            return;
        }
        Applicant applicant = (Applicant) applicantUser;

        // Re-check status and booking state before proceeding
        // Ensure applicant state is synced before check? Or rely on application status?
        // Let's rely on application status primarily, but check applicant.hasBooked() too.
        applicationService.synchronizeApplicantStatus(applicant); // Sync just in case
        if (applicationToBook.getStatus() != ApplicationStatus.SUCCESSFUL) {
            System.out.println("Error: Applicant status is no longer SUCCESSFUL (Current: "
                    + applicationToBook.getStatus() + "). Cannot proceed.");
            return;
        }
        if (applicant.hasBooked()) {
            System.out.println("Error: Applicant " + applicant.getNric()
                    + " has already booked a flat according to their profile.");
            // This indicates a data inconsistency if application status is still SUCCESSFUL
            return;
        }

        FlatType appliedFlatType = applicationToBook.getFlatTypeApplied();
        if (appliedFlatType == null) {
            System.out.println("Error: Application record does not have a valid flat type specified. Cannot book.");
            return;
        }

        // Check availability again just before booking
        FlatTypeDetails details = project.getMutableFlatTypeDetails(appliedFlatType); // Get mutable details
        if (details == null || details.getAvailableUnits() <= 0) {
            System.out.println("Error: No available units for the applied flat type ("
                    + appliedFlatType.getDisplayName() + ") at this moment. Booking cannot proceed.");
            return;
        }

        // Confirm booking details
        System.out.println("\n--- Confirm Booking ---");
        System.out.println("Applicant: " + applicant.getName() + " (" + applicant.getNric() + ")");
        System.out.println("Project: " + applicationToBook.getProjectName());
        System.out.println("Flat Type: " + appliedFlatType.getDisplayName());
        System.out.println("Available Units Before Booking: " + details.getAvailableUnits());
        System.out.printf("Selling Price: $%.2f\n", details.getSellingPrice());

        boolean confirm = InputUtils.getConfirmation(scanner, "\nConfirm booking for this applicant?");

        if (confirm) {
            // Delegate booking to the service (handles unit decrement, status updates, saving)
            boolean success = applicationService.bookFlat(applicationToBook, applicant, project);

            if (success) {
                // Generate receipt after successful booking
                generateBookingReceipt(applicant, applicationToBook, project);
            } else {
                // Error message printed by service
                System.out.println("Booking failed.");
            }
        } else {
            System.out.println("Booking cancelled.");
        }
    }

    // Receipt generation remains in the controller as it's a presentation concern
    private void generateBookingReceipt(Applicant applicant, BTOApplication application, Project project) {
        System.out.println("\n================ BTO Booking Receipt ================");
        System.out.println(" Receipt Generated: " + DateUtils.formatDate(DateUtils.getCurrentDate()) + " by Officer "
                + currentUser.getNric()); // Use currentUser (Officer)
        System.out.println("-----------------------------------------------------");
        System.out.println(" Applicant Details:");
        System.out.println("   Name:          " + applicant.getName());
        System.out.println("   NRIC:          " + applicant.getNric());
        System.out.println("   Age:           " + applicant.getAge());
        System.out.println("   Marital Status:" + applicant.getMaritalStatus());
        System.out.println("-----------------------------------------------------");
        System.out.println(" Booking Details:");
        System.out.println("   Project Name:  " + project.getProjectName());
        System.out.println("   Neighborhood:  " + project.getNeighborhood());
        System.out.println("   Booked Flat:   "
                + (application.getFlatTypeApplied() != null ? application.getFlatTypeApplied().getDisplayName() : "N/A"));
        // Get details again for price (project object might have been updated)
        FlatTypeDetails details = project.getFlatTypeDetails(application.getFlatTypeApplied());
        if (details != null) {
            System.out.printf("   Selling Price: $%.2f\n", details.getSellingPrice());
        } else {
            System.out.println("   Selling Price: N/A"); // Should not happen if booking succeeded
        }
        System.out.println("   Booking Status:" + application.getStatus()); // Should be BOOKED
        System.out.println("   Application ID:" + application.getApplicationId());
        System.out.println("-----------------------------------------------------");
        System.out.println(" Thank you for choosing HDB!");
        System.out.println("=====================================================");
    }

    // Inherited methods like applyFilters(), changePassword() are available from ApplicantController
}
```

**Views (Depend on Controllers and some Services)**

Views/ApplicantView.java
```java
package Views;

import java.util.Scanner;
import Models.User;
import Controllers.ApplicantController;
import Interfaces.Services.IAuthService; // Needed for BaseView constructor
import Interfaces.Services.IFilterService; // Needed for BaseView constructor

public class ApplicantView extends BaseView {
    private final ApplicantController applicantController;

    public ApplicantView(Scanner scanner, User currentUser, ApplicantController controller,
                         IAuthService authService, IFilterService filterService) {
        // Pass services needed by BaseView
        super(scanner, currentUser, authService, filterService);
        this.applicantController = controller;
    }

    @Override
    public void displayMenu() {
        boolean logout = false;
        while (!logout) {
            System.out.println("\n=========== Applicant Menu ===========");
            System.out.println("Welcome, " + currentUser.getName() + "!");
            System.out.println(" 1. View Available BTO Projects");
            System.out.println(" 2. Apply for BTO Project");
            System.out.println(" 3. View My Application Status");
            System.out.println(" 4. Request Application Withdrawal");
            System.out.println(" 5. Submit Enquiry");
            System.out.println(" 6. View My Enquiries");
            System.out.println(" 7. Edit My Enquiry");
            System.out.println(" 8. Delete My Enquiry");
            System.out.println(" 9. Apply/Clear Project Filters");
            System.out.println("10. Change Password");
            System.out.println(" 0. Logout");
            System.out.println("======================================");

            int choice = getMenuChoice(0, 10);

            switch (choice) {
                case 1: applicantController.viewOpenProjects(); break;
                case 2: applicantController.applyForProject(); break;
                case 3: applicantController.viewMyApplication(); break;
                case 4: applicantController.requestWithdrawal(); break;
                case 5: applicantController.submitEnquiry(); break;
                case 6: applicantController.viewMyEnquiries(); break;
                case 7: applicantController.editMyEnquiry(); break;
                case 8: applicantController.deleteMyEnquiry(); break;
                case 9: applyFilters(); break; // Call BaseView method
                case 10:
                    if (changePassword()) { // Call BaseView method
                        logout = true; // Log out after successful password change
                    }
                    break;
                case 0:
                    logout = true;
                    System.out.println("Logging out...");
                    break;
                default: System.out.println("Invalid choice."); break;
            }
             if (!logout && choice != 0) {
                 pause(); // Use BaseView pause method
             }
        }
    }
}
```

Views/BaseView.java
```java
package Views;

import java.util.Scanner;
import Models.User;
import Interfaces.Services.IAuthService;
import Interfaces.Services.IFilterService;
import Utils.InputUtils; // Use InputUtils

public abstract class BaseView {
    protected final Scanner scanner;
    protected final User currentUser;
    // Services needed by base view actions
    protected final IAuthService authService;
    protected final IFilterService filterService;

    public BaseView(Scanner scanner, User currentUser, IAuthService authService, IFilterService filterService) {
        this.scanner = scanner;
        this.currentUser = currentUser;
        this.authService = authService;
        this.filterService = filterService;
    }

    // Abstract method for subclasses to implement their specific menu
    public abstract void displayMenu();

    /**
     * Gets a valid menu choice from the user within the specified range.
     * @param min Minimum valid choice number.
     * @param max Maximum valid choice number.
     * @return The valid integer choice entered by the user.
     */
    protected int getMenuChoice(int min, int max) {
        // Delegate to InputUtils
        return InputUtils.getIntInput(scanner, "Enter your choice: ", min, max);
    }

     /**
      * Handles the process of changing the current user's password.
      * Delegates the actual password change logic to the AuthService.
      * @return true if the password was successfully changed (requires re-login), false otherwise.
      */
     protected boolean changePassword() {
         System.out.println("\n--- Change Password ---");
         System.out.print("Enter current password: ");
         String oldPassword = scanner.nextLine();
         System.out.print("Enter new password: ");
         String newPassword = scanner.nextLine();
         System.out.print("Confirm new password: ");
         String confirmPassword = scanner.nextLine();

         if (!newPassword.equals(confirmPassword)) {
             System.out.println("New passwords do not match. Password not changed.");
             return false;
         }
         // Other checks (empty, same as old) handled by AuthService.changePassword

         // Delegate to auth service
         boolean success = authService.changePassword(currentUser, oldPassword, newPassword);
         // Success/error messages printed within service
         return success; // Return success status (true means logout needed)
     }

     /**
      * Handles applying or clearing project view filters.
      * Delegates the logic to the FilterService.
      */
     protected void applyFilters() {
         // This method now belongs more logically in the specific controllers
         // as it interacts with the FilterService state.
         // Keeping it here requires passing FilterService, which we did.
         System.out.println("\n--- Apply/Clear Filters ---");
         System.out.print("Enter neighborhood to filter by (current: "
                 + (filterService.getLocationFilter() == null ? "Any" : filterService.getLocationFilter()) + ", leave blank to clear): ");
         String loc = scanner.nextLine().trim();
         filterService.setLocationFilter(loc); // Service handles empty string logic

         System.out.print("Enter flat type to filter by (TWO_ROOM, THREE_ROOM, current: "
                 + (filterService.getFlatTypeFilter() == null ? "Any" : filterService.getFlatTypeFilter()) + ", leave blank to clear): ");
         String typeStr = scanner.nextLine().trim();
         if (typeStr.isEmpty()) {
             filterService.setFlatTypeFilter(null);
         } else {
             try {
                 Enums.FlatType parsedType = Enums.FlatType.fromString(typeStr); // Use enum parser
                 if (parsedType != null) {
                     filterService.setFlatTypeFilter(parsedType);
                 } else {
                     System.out.println("Invalid flat type entered. Filter not changed.");
                 }
             } catch (IllegalArgumentException e) {
                 System.out.println("Invalid flat type format. Filter not changed.");
             }
         }
         System.out.println("Filters updated. Current filters: " + filterService.getCurrentFilterStatus());
     }

     /**
      * Pauses execution and waits for the user to press Enter.
      */
     protected void pause() {
          System.out.println("\nPress Enter to continue...");
          scanner.nextLine(); // Consume the Enter key
     }
}
```

Views/ManagerView.java
```java
package Views;

import java.util.Scanner;
import Models.User;
import Controllers.ManagerController;
import Interfaces.Services.IAuthService; // Needed for BaseView
import Interfaces.Services.IFilterService; // Needed for BaseView

public class ManagerView extends BaseView {
    private final ManagerController managerController;

    public ManagerView(Scanner scanner, User currentUser, ManagerController controller,
                       IAuthService authService, IFilterService filterService) {
        super(scanner, currentUser, authService, filterService); // Pass services to BaseView
        this.managerController = controller;
    }

    @Override
    public void displayMenu() {
        boolean logout = false;
        while (!logout) {
            System.out.println("\n=========== HDB Manager Menu ===========");
            System.out.println("Welcome, Manager " + currentUser.getName() + "!");
            System.out.println("--- Project Management ---");
            System.out.println(" 1. Create New BTO Project");
            System.out.println(" 2. Edit My Project Details");
            System.out.println(" 3. Delete My Project");
            System.out.println(" 4. Toggle Project Visibility");
            System.out.println(" 5. View All Projects (Manager Oversight)");
            System.out.println(" 6. View My Managed Projects");
            System.out.println("--- Staff & Application Management ---");
            System.out.println(" 7. Manage Officer Registrations (Approve/Reject)");
            System.out.println(" 8. Manage BTO Applications (Approve/Reject)");
            System.out.println(" 9. Manage Withdrawal Requests (Approve/Reject)");
            System.out.println("--- Reporting & Enquiries ---");
            System.out.println("10. Generate Applicant Report (Booked Flats)");
            System.out.println("11. View Enquiries (ALL Projects)");
            System.out.println("12. View/Reply Enquiries (My Managed Projects)");
            System.out.println("--- Common Actions ---");
            System.out.println("13. Apply/Clear Project Filters (Affects Views 5, 6, 10, 12)");
            System.out.println("14. Change Password");
            System.out.println(" 0. Logout");
            System.out.println("========================================");

            int choice = getMenuChoice(0, 14);

            switch (choice) {
                case 1: managerController.createProject(); break;
                case 2: managerController.editProject(); break;
                case 3: managerController.deleteProject(); break;
                case 4: managerController.toggleProjectVisibility(); break;
                case 5: managerController.viewAllProjects(); break;
                case 6: managerController.viewMyProjects(); break;
                case 7: managerController.manageOfficerRegistrations(); break;
                case 8: managerController.manageApplications(); break;
                case 9: managerController.manageWithdrawalRequests(); break;
                case 10: managerController.generateApplicantReport(); break;
                case 11: managerController.viewAllEnquiries(); break;
                case 12: managerController.viewAndReplyToManagedEnquiries(); break;
                case 13: applyFilters(); break; // Call BaseView method
                case 14:
                    if (changePassword()) { // Call BaseView method
                        logout = true; // Log out after successful password change
                    }
                    break;
                case 0:
                    logout = true;
                    System.out.println("Logging out...");
                    break;
                default: System.out.println("Invalid choice."); break;
            }
             if (!logout && choice != 0) {
                 pause(); // Use BaseView pause method
             }
        }
    }
}
```

Views/OfficerView.java
```java
package Views;

import Controllers.OfficerController;
import Interfaces.Services.IAuthService; // Needed for BaseView
import Interfaces.Services.IFilterService; // Needed for BaseView
import Interfaces.Services.IEligibilityService; // Needed to display handling project
import Models.HDBOfficer;
import Models.Project;
import Models.User;

import java.util.Scanner;

public class OfficerView extends BaseView {
    private final OfficerController officerController;
    private final IEligibilityService eligibilityService; // Inject service needed for display

    public OfficerView(Scanner scanner, User currentUser, OfficerController controller,
                       IAuthService authService, IFilterService filterService,
                       IEligibilityService eligibilityService) { // Inject eligibility service
        super(scanner, currentUser, authService, filterService); // Pass base services
        this.officerController = controller;
        this.eligibilityService = eligibilityService; // Store eligibility service
    }

    @Override
    public void displayMenu() {
        boolean logout = false;
        while (!logout) {
            System.out.println("\n=========== HDB Officer Menu ===========");
            System.out.println("Welcome, Officer " + currentUser.getName() + "!");

            // Display currently handling project using injected service
            Project handlingProject = eligibilityService.getOfficerHandlingProject((HDBOfficer)currentUser);
            if (handlingProject != null) {
                 System.out.println("--> Currently Handling Project: " + handlingProject.getProjectName() + " <--");
            } else {
                 System.out.println("--> Not currently handling any project <--");
            }

            System.out.println("--- Officer Actions ---");
            System.out.println(" 1. Register to Handle Project");
            System.out.println(" 2. View My Registration Status");
            System.out.println(" 3. View Handling Project Details");
            System.out.println(" 4. View/Reply Enquiries (Handling Project)");
            System.out.println(" 5. Manage Flat Booking (Process Successful Applicants)");
            System.out.println("--- Applicant Actions (Inherited) ---");
            System.out.println(" 6. View Available BTO Projects");
            System.out.println(" 7. Apply for BTO Project");
            System.out.println(" 8. View My Application Status");
            System.out.println(" 9. Request Application Withdrawal");
            System.out.println("10. Submit Enquiry");
            System.out.println("11. View My Enquiries");
            System.out.println("12. Edit My Enquiry");
            System.out.println("13. Delete My Enquiry");
            System.out.println("--- Common Actions ---");
            System.out.println("14. Apply/Clear Project Filters");
            System.out.println("15. Change Password");
            System.out.println(" 0. Logout");
            System.out.println("========================================");

            int choice = getMenuChoice(0, 15); // Use BaseView method

            switch (choice) {
                // Officer Actions
                case 1: officerController.registerForProject(); break;
                case 2: officerController.viewRegistrationStatus(); break;
                case 3: officerController.viewHandlingProjectDetails(); break;
                case 4: officerController.viewAndReplyToEnquiries(); break;
                case 5: officerController.manageFlatBooking(); break;
                // Applicant Actions (Inherited - OfficerController extends ApplicantController)
                case 6: officerController.viewOpenProjects(); break;
                case 7: officerController.applyForProject(); break;
                case 8: officerController.viewMyApplication(); break;
                case 9: officerController.requestWithdrawal(); break;
                case 10: officerController.submitEnquiry(); break;
                case 11: officerController.viewMyEnquiries(); break;
                case 12: officerController.editMyEnquiry(); break;
                case 13: officerController.deleteMyEnquiry(); break;
                // Common Actions
                case 14: applyFilters(); break; // Call BaseView method
                case 15:
                    if (changePassword()) { // Call BaseView method
                        logout = true; // Log out after successful password change
                    }
                    break;
                case 0:
                    logout = true;
                    System.out.println("Logging out...");
                    break;
                default: System.out.println("Invalid choice."); break;
            }
             if (!logout && choice != 0) {
                 pause(); // Use BaseView pause method
             }
        }
    }
}
```

**Main Application (Dependency Injection Setup)**

BTOApp.java
```java
import java.util.List;
import java.util.Map;
import java.util.Scanner;

// Models
import Models.User;
import Models.Project;
import Models.BTOApplication;
import Models.Enquiry;
import Models.OfficerRegistration;

// Controllers
import Controllers.ApplicantController;
import Controllers.OfficerController;
import Controllers.ManagerController;

// Views
import Views.ApplicantView;
import Views.BaseView;
import Views.OfficerView;
import Views.ManagerView;

// Services (Concrete Implementations)
import Services.ApplicationService;
import Services.AuthService;
import Services.DataSynchronizationService;
import Services.EligibilityService;
import Services.EnquiryService;
import Services.FilterService;
import Services.OfficerRegistrationService;
import Services.ProjectDisplayService;
import Services.ProjectService;
import Services.ReportService;

// Repositories (Concrete Implementations)
import Repositories.CsvApplicationRepository;
import Repositories.CsvEnquiryRepository;
import Repositories.CsvOfficerRegistrationRepository;
import Repositories.CsvProjectRepository;
import Repositories.CsvUserRepository;

// Interfaces
import Interfaces.Repositories.*;
import Interfaces.Services.*;

public class BTOApp {

    // Repositories (using Interfaces)
    private IUserRepository userRepository;
    private IProjectRepository projectRepository;
    private IApplicationRepository applicationRepository;
    private IEnquiryRepository enquiryRepository;
    private IOfficerRegistrationRepository officerRegistrationRepository;

    // Services (using Interfaces)
    private IAuthService authService;
    private IFilterService filterService;
    private IEligibilityService eligibilityService;
    private IProjectService projectService;
    private IApplicationService applicationService;
    private IOfficerRegistrationService officerRegService;
    private IEnquiryService enquiryService;
    private IProjectDisplayService projectDisplayService;
    private IReportService reportService;
    private IDataSynchronizationService dataSyncService;

    private Scanner scanner;

    public BTOApp() {
        scanner = new Scanner(System.in);
    }

    public void initialize() {
        System.out.println("Initializing BTO Management System...");

        // --- Instantiate Concrete Repositories ---
        userRepository = new CsvUserRepository();
        projectRepository = new CsvProjectRepository();
        applicationRepository = new CsvApplicationRepository();
        enquiryRepository = new CsvEnquiryRepository();
        officerRegistrationRepository = new CsvOfficerRegistrationRepository();

        // --- Load Initial Data (Repositories handle loading) ---
        // Trigger initial load by accessing getAll methods or specific load methods
        userRepository.getAllUsers();
        projectRepository.getAllProjects();
        applicationRepository.getAllApplications();
        enquiryRepository.getAllEnquiries();
        officerRegistrationRepository.getAllRegistrations();

        // --- Instantiate Concrete Services (Injecting Dependencies) ---
        // Services that only need their own repository
        authService = new AuthService(userRepository);
        filterService = new FilterService(); // No repository needed

        // Services needing multiple repositories/services
        eligibilityService = new EligibilityService(userRepository, officerRegistrationRepository, projectRepository);
        enquiryService = new EnquiryService(enquiryRepository); // Needs only its repo for basic ops
        applicationService = new ApplicationService(applicationRepository, projectRepository, userRepository);
        officerRegService = new OfficerRegistrationService(officerRegistrationRepository, projectRepository, eligibilityService);
        projectService = new ProjectService(projectRepository, eligibilityService, filterService, applicationService, officerRegService, enquiryService);
        projectDisplayService = new ProjectDisplayService(filterService, eligibilityService);
        reportService = new ReportService(applicationRepository, userRepository);
        dataSyncService = new DataSynchronizationService(userRepository, projectRepository, applicationRepository, officerRegistrationRepository, applicationService);

        // --- Perform Initial Data Synchronization ---
        dataSyncService.synchronizeAllData();

        System.out.println("Initialization complete. System ready.");
    }

    public void run() {
        User currentUser = null;
        while (true) {
             // Optional: Re-synchronize data before each login? Might be overkill.
             // dataSyncService.synchronizeAllData();

            currentUser = loginScreen();
            if (currentUser != null) {
                showRoleMenu(currentUser);
                currentUser = null; // Clear user on logout
                System.out.println("\nReturning to Login Screen...");
            } else {
                // Login failed message handled by authService
                System.out.print("Try again? (yes/no): ");
                String retry = scanner.nextLine().trim().toLowerCase();
                if (!retry.equals("yes")) {
                    break; // Exit loop if user doesn't want to retry
                }
            }
        }
        System.out.println("Exiting application.");
        // Optional: Save all data on exit? Repositories save on modification now.
    }

    private User loginScreen() {
        System.out.println("\n--- BTO Management System Login ---");
        System.out.print("Enter NRIC: ");
        String nric = scanner.nextLine(); // Let AuthService handle trimming/casing
        System.out.print("Enter Password: ");
        String password = scanner.nextLine();

        User user = authService.login(nric, password);
        if (user != null) {
            System.out.println("Login successful! Welcome, " + user.getName() + " (" + user.getRole() + ")");
        }
        // Error messages (invalid NRIC, wrong password, not found) handled by AuthService
        return user;
    }

    private void showRoleMenu(User user) {
        BaseView view;

        // Instantiate Controllers with necessary services
        switch (user.getRole()) {
            case APPLICANT:
                ApplicantController appController = new ApplicantController(scanner, user, authService,
                        projectService, applicationService, enquiryService, eligibilityService,
                        filterService, projectDisplayService, officerRegService);
                // Instantiate View with Controller and services needed by BaseView
                view = new ApplicantView(scanner, user, appController, authService, filterService);
                break;
            case HDB_OFFICER:
                 OfficerController offController = new OfficerController(scanner, user, authService,
                         projectService, applicationService, enquiryService, eligibilityService,
                         filterService, projectDisplayService, officerRegService, userRepository); // Pass user repo if needed
                 // Instantiate View with Controller and services needed by BaseView + OfficerView specific
                 view = new OfficerView(scanner, user, offController, authService, filterService, eligibilityService);
                break;
            case HDB_MANAGER:
                 ManagerController manController = new ManagerController(scanner, user, authService,
                         projectService, applicationService, enquiryService, eligibilityService,
                         filterService, projectDisplayService, officerRegService, reportService, userRepository);
                 // Instantiate View with Controller and services needed by BaseView
                 view = new ManagerView(scanner, user, manController, authService, filterService);
                break;
            default:
                System.err.println("FATAL Error: Unknown user role encountered: " + user.getRole());
                return; // Exit method if role is unknown
        }
        // Display the menu for the selected role
        view.displayMenu();
    }

    public static void main(String[] args) {
        BTOApp app = new BTOApp();
        try {
            app.initialize();
            app.run();
        } catch (Exception e) {
             // Catch unexpected errors during initialization or run
             System.err.println("\n!!! An unexpected critical error occurred: " + e.getMessage() + " !!!");
             e.printStackTrace(); // Print stack trace for debugging
             System.err.println("Application will now exit.");
        } finally {
            // Ensure scanner is closed if needed, though System.in usually isn't closed.
            // if (app.scanner != null) {
            //     app.scanner.close();
            // }
        }
         System.exit(1); // Exit with error code if exception occurred, 0 otherwise (handled by run loop exit)
    }
}
```

Services/CsvRW.java
```java
package Services;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.List;
import java.util.stream.Collectors;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

public class CsvRW {
    private static final String DATA_DIR = "data"; // Keep consistent
    private static final String DELIMITER = ",";
    // LIST_DELIMITER is handled by LSparse now
    // Headers are now defined in the respective Repositories

    /**
     * Reads a CSV file, skipping the header row.
     * Handles basic CSV quoting for fields containing the delimiter.
     * @param filename The path to the CSV file.
     * @param expectedColumns The number of columns expected per row (used for validation).
     * @return A List of String arrays, where each array represents a row (excluding header).
     */
    public static List<String[]> readCsv(String filename, int expectedColumns) {
        List<String[]> data = new ArrayList<>();
        Path path = Paths.get(filename);

        // Check if file exists, create if not (with appropriate header if possible)
        if (!Files.exists(path)) {
            System.err.println("Warning: File not found - " + filename + ". Attempting to create.");
            try {
                Path parent = path.getParent();
                if (parent != null) {
                    Files.createDirectories(parent); // Ensure data directory exists
                }
                Files.createFile(path);
                // Cannot reliably get header here anymore, Repositories handle headers on save
                System.out.println("Created empty file: " + filename);
                // Write header? No, let the first save operation write the header.
            } catch (IOException e) {
                System.err.println("FATAL: Error creating file: " + filename + " - " + e.getMessage() + ". Application might not function correctly.");
                // Return empty list, subsequent operations might fail
            }
            return data; // Return empty list if file was just created or creation failed
        }

        // Read existing file
        try (BufferedReader br = Files.newBufferedReader(path)) {
            String line;
            boolean isFirstLine = true; // To skip header
            int lineNumber = 0;
            while ((line = br.readLine()) != null) {
                lineNumber++;
                // Skip header row and any blank lines
                if (isFirstLine || line.trim().isEmpty()) {
                    isFirstLine = false;
                    continue;
                }

                // Basic CSV split respecting quotes (may not handle all edge cases)
                String[] values = line.split(DELIMITER + "(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", -1);

                // Trim and unquote values
                for (int i = 0; i < values.length; i++) {
                    values[i] = values[i].trim();
                    // Remove surrounding quotes and unescape double quotes ("")
                    if (values[i].startsWith("\"") && values[i].endsWith("\"")) {
                        values[i] = values[i].substring(1, values[i].length() - 1).replace("\"\"", "\"");
                    }
                }

                // --- Column Count Validation ---
                // Specific handling for ProjectList potentially missing 'Visibility' (column 14, index 13)
                boolean isProjectFile = filename.endsWith("ProjectList.csv"); // Simple check
                if (isProjectFile && values.length == expectedColumns - 1) {
                     // Pad with default visibility "0" (Off) if missing
                     String[] paddedValues = Arrays.copyOf(values, expectedColumns);
                     paddedValues[expectedColumns - 1] = "0"; // Default visibility
                     values = paddedValues;
                     System.out.println("Info: Line " + lineNumber + " in " + filename + " missing 'Visibility'. Assuming '0' (Off).");
                } else if (values.length != expectedColumns) {
                     // General mismatch warning
                     System.err.println("Warning: Malformed line " + lineNumber + " in " + filename + ". Expected " + expectedColumns + " columns, found " + values.length + ". Skipping line: " + line);
                     continue; // Skip this malformed row
                }
                // --- End Validation ---

                data.add(values);
            }
        } catch (IOException e) {
            // Log fatal error if reading fails
            System.err.println("FATAL: Error reading file: " + filename + " - " + e.getMessage());
        }
        return data;
    }

    /**
     * Writes data to a CSV file, overwriting existing content.
     * Automatically quotes fields containing delimiters, quotes, or newlines.
     * @param filename The path to the CSV file.
     * @param data A List of String arrays, where each array represents a row (including header).
     */
    public static void writeCsv(String filename, List<String[]> data) {
        Path path = Paths.get(filename);
        try {
             // Ensure parent directory exists
             Path parent = path.getParent();
             if (parent != null) {
                 Files.createDirectories(parent);
             }

             // Write using try-with-resources for automatic closing
             try (BufferedWriter bw = Files.newBufferedWriter(path, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {
                for (String[] row : data) {
                    // Escape each field and join with delimiter
                    String line = Arrays.stream(row)
                                        .map(CsvRW::escapeCsvField) // Use helper method
                                        .collect(Collectors.joining(DELIMITER));
                    bw.write(line);
                    bw.newLine(); // Add newline character after each row
                }
            }
        } catch (IOException e) {
            // Log error if writing fails
            System.err.println("Error writing file: " + filename + " - " + e.getMessage());
        }
    }

    /**
     * Escapes a string field for CSV output if necessary.
     * Adds surrounding quotes if the field contains the delimiter, double quotes, or newline characters.
     * Escapes existing double quotes within the field by doubling them ("").
     * @param field The string field to escape.
     * @return The escaped string, ready for CSV output.
     */
    private static String escapeCsvField(String field) {
        if (field == null) {
            return ""; // Represent null as empty string in CSV
        }
        // Check if escaping is needed
        if (field.contains(DELIMITER) || field.contains("\"") || field.contains("\n") || field.contains("\r")) {
            // Escape double quotes within the field and add surrounding quotes
            return "\"" + field.replace("\"", "\"\"") + "\"";
        }
        // No escaping needed, return original field
        return field;
    }

    // getHeaderForFile method is removed as headers are now managed by Repositories
}
```