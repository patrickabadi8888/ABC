Okay, I will refactor the Controllers, Services, and BTOApp.java to improve SOLID adherence by breaking down large classes and using interfaces where appropriate. The core logic, menu structure, and output will remain identical.

**Refactoring Strategy:**

1.  **Services:** Convert static service classes (except `CsvRW` and parts of `DataService`) into instance-based services holding their respective data collections. Introduce interfaces for these services (`IProjectService`, `IApplicationService`, etc.). `DataService` will retain static methods for loading/saving users and synchronization, operating on the data held by the service instances.
2.  **Controllers:**
    *   Break down `ManagerController` into smaller, focused controllers (e.g., `ProjectManagerController`, `ApplicationManagerController`, `EnquiryManagerController`, `ReportManagerController`, `OfficerRegistrationManagerController`).
    *   Break down `OfficerController` into `OfficerActionController` (handling registration, status), `BookingOfficerController`, and `EnquiryOfficerController`. It will still inherit Applicant actions via its base class.
    *   Break down `ApplicantController` into `ApplicantActionController` (handling application, status, withdrawal) and `EnquiryApplicantController`.
    *   `BaseController` will retain common filtering, finding, and input utility methods, injecting necessary services.
    *   Introduce interfaces for controller actions where appropriate (e.g., `IProjectViewer`, `IEnquirySubmitter`).
3.  **BTOApp:** Instantiate the services, load data into them, perform synchronization, instantiate controllers (injecting services), and pass the relevant controllers to the views.

---

Services/IUserService.java
```java
package Services;

import java.util.Map;
import Models.User;

public interface IUserService {
    Map<String, User> loadUsers();
    void saveUsers(Map<String, User> users);
    User findUserByNric(String nric);
    Map<String, User> getAllUsers(); // Added to facilitate saving and synchronization
}
```

Services/UserService.java
```java
package Services;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import Enums.MaritalStatus;
import Models.Applicant;
import Models.HDBManager;
import Models.HDBOfficer;
import Models.User;

public class UserService implements IUserService {
    private static final String DATA_DIR = "data";
    private static final String APPLICANT_LIST_FILE = DATA_DIR + File.separator + "ApplicantList.csv";
    private static final String OFFICER_LIST_FILE = DATA_DIR + File.separator + "OfficerList.csv";
    private static final String MANAGER_LIST_FILE = DATA_DIR + File.separator + "ManagerList.csv";
    private static final String DELIMITER = ",";
    private static final String[] APPLICANT_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };
    private static final String[] OFFICER_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };
    private static final String[] MANAGER_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };

    private Map<String, User> users;

    public UserService() {
        this.users = new HashMap<>();
    }

    @Override
    public Map<String, User> loadUsers() {
        this.users.clear(); // Clear existing users before loading

        CsvRW.readCsv(APPLICANT_LIST_FILE, APPLICANT_HEADER.length).forEach(data -> {
            try {
                String nric = data[1].trim();
                if (!Utils.NricValidator.isValidNric(nric) || this.users.containsKey(nric)) {
                    if (this.users.containsKey(nric))
                        System.err.println("Duplicate NRIC found in ApplicantList: " + nric + ". Skipping duplicate.");
                    else
                        System.err.println("Invalid NRIC format in ApplicantList: " + nric + ". Skipping.");
                    return;
                }
                int age = Integer.parseInt(data[2].trim());
                MaritalStatus status = MaritalStatus.valueOf(data[3].trim().toUpperCase());
                Applicant applicant = new Applicant(nric, data[4].trim(), data[0].trim(), age, status);
                this.users.put(nric, applicant);
            } catch (Exception e) {
                System.err.println(
                        "Error parsing applicant data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        });

        CsvRW.readCsv(OFFICER_LIST_FILE, OFFICER_HEADER.length).forEach(data -> {
            try {
                String nric = data[1].trim();
                if (!Utils.NricValidator.isValidNric(nric)) {
                    System.err.println("Invalid NRIC format in OfficerList: " + nric + ". Skipping.");
                    return;
                }
                int age = Integer.parseInt(data[2].trim());
                MaritalStatus status = MaritalStatus.valueOf(data[3].trim().toUpperCase());
                HDBOfficer officer = new HDBOfficer(nric, data[4].trim(), data[0].trim(), age, status);
                if (this.users.containsKey(nric) && !(this.users.get(nric) instanceof HDBOfficer)) {
                    System.out.println(
                            "Info: User " + nric + " found in both Applicant and Officer lists. Using Officer role.");
                } else if (this.users.containsKey(nric)) {
                    System.err.println("Duplicate NRIC found in OfficerList: " + nric + ". Skipping duplicate.");
                    return;
                }
                this.users.put(nric, officer);
            } catch (Exception e) {
                System.err.println(
                        "Error parsing officer data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        });

        CsvRW.readCsv(MANAGER_LIST_FILE, MANAGER_HEADER.length).forEach(data -> {
            try {
                String nric = data[1].trim();
                if (!Utils.NricValidator.isValidNric(nric)) {
                    System.err.println("Invalid NRIC format in ManagerList: " + nric + ". Skipping.");
                    return;
                }
                int age = Integer.parseInt(data[2].trim());
                MaritalStatus status = MaritalStatus.valueOf(data[3].trim().toUpperCase());
                HDBManager manager = new HDBManager(nric, data[4].trim(), data[0].trim(), age, status);
                if (this.users.containsKey(nric) && !(this.users.get(nric) instanceof HDBManager)) {
                    System.out.println("Info: User " + nric + " found in other lists. Using Manager role.");
                } else if (this.users.containsKey(nric)) {
                    System.err.println("Duplicate NRIC found in ManagerList: " + nric + ". Skipping duplicate.");
                    return;
                }
                this.users.put(nric, manager);
            } catch (Exception e) {
                System.err.println(
                        "Error parsing manager data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        });

        System.out.println("Loaded " + this.users.size() + " unique users.");
        return this.users; // Return the map after loading
    }

    @Override
    public void saveUsers(Map<String, User> usersToSave) { // Accept map to save
        List<String[]> applicantData = new ArrayList<>();
        List<String[]> officerData = new ArrayList<>();
        List<String[]> managerData = new ArrayList<>();

        applicantData.add(APPLICANT_HEADER);
        officerData.add(OFFICER_HEADER);
        managerData.add(MANAGER_HEADER);

        usersToSave.values().forEach(user -> {
            String[] userData = {
                    user.getName(),
                    user.getNric(),
                    String.valueOf(user.getAge()),
                    user.getMaritalStatus().name(),
                    user.getPassword()
            };
            switch (user.getRole()) {
                case HDB_MANAGER:
                    managerData.add(userData);
                    break;
                case HDB_OFFICER:
                    officerData.add(userData);
                    break;
                case APPLICANT:
                    applicantData.add(userData);
                    break;
            }
        });

        CsvRW.writeCsv(APPLICANT_LIST_FILE, applicantData);
        CsvRW.writeCsv(OFFICER_LIST_FILE, officerData);
        CsvRW.writeCsv(MANAGER_LIST_FILE, managerData);
        System.out.println("Saved users.");
        // Update internal state if the saved map is the one managed by this service
        if (usersToSave == this.users) {
             this.users = new HashMap<>(usersToSave);
        } else {
             // If an external map was passed, update the internal map as well
             // Or decide if saveUsers should *only* save the internal state.
             // For simplicity, let's assume it saves what's passed.
             // If callers modify the map returned by loadUsers/getAllUsers,
             // they should call saveUsers with that modified map.
        }
    }

     @Override
     public User findUserByNric(String nric) {
         return this.users.get(nric);
     }

     @Override
     public Map<String, User> getAllUsers() {
         // Return a copy to prevent external modification of the internal map
         return new HashMap<>(this.users);
     }
}
```

Services/IProjectService.java
```java
package Services;

import java.util.List;
import java.util.Map;
import Models.Project;
import Models.User;
import Enums.FlatType;

public interface IProjectService {
    List<Project> loadProjects(Map<String, User> users); // Pass users for validation during load
    void saveProjects(List<Project> projects);
    Project findProjectByName(String name);
    List<Project> getAllProjects();
    List<Project> getProjectsManagedBy(String managerNric);
    void addProject(Project project);
    boolean removeProject(Project project);
}
```

Services/ProjectService.java
```java
package Services;
import java.io.File;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import Enums.FlatType;
import Models.FlatTypeDetails;
import Models.HDBManager;
import Models.HDBOfficer;
import Models.Project;
import Models.User;
import Utils.DateUtils;
import Parsers.Dparse;
import Parsers.LSparse;


public class ProjectService implements IProjectService {
    private static final String DELIMITER = ",";
    private static final String DATA_DIR = "data";
    private static final String LIST_DELIMITER = ";";
    private static final String[] PROJECT_HEADER = {
        "Project Name", "Neighborhood", "Type 1", "Number of units for Type 1", "Selling price for Type 1",
        "Type 2", "Number of units for Type 2", "Selling price for Type 2",
        "Application opening date", "Application closing date", "Manager", "Officer Slot", "Officer", "Visibility"
    };
    private static final String PROJECT_FILE = DATA_DIR + File.separator + "ProjectList.csv";

    private List<Project> projects;

    public ProjectService() {
        this.projects = new ArrayList<>();
    }

    @Override
    public List<Project> loadProjects(Map<String, User> users) {
        this.projects.clear(); // Clear before loading
        Set<String> projectNames = new HashSet<>();

        CsvRW.readCsv(PROJECT_FILE, PROJECT_HEADER.length).forEach(data -> {
            try {
                String projectName = data[0].trim();
                if (projectName.isEmpty() || !projectNames.add(projectName.toLowerCase())) {
                     if (!projectName.isEmpty()) System.err.println("Skipping duplicate project name: " + projectName);
                    return;
                }

                String neighborhood = data[1].trim();
                Map<FlatType, FlatTypeDetails> flatTypes = new HashMap<>();

                if (data[2] != null && !data[2].trim().isEmpty()) {
                    FlatType type1 = FlatType.fromString(data[2].trim());
                    if (type1 != null) {
                        int units1 = Integer.parseInt(data[3].trim());
                        double price1 = Double.parseDouble(data[4].trim());
                        // Assuming available units = total units initially when loading from file
                        flatTypes.put(type1, new FlatTypeDetails(units1, units1, price1));
                    } else {
                         System.err.println("Warning: Unknown flat type '" + data[2] + "' in project '" + projectName + "'. Skipping type.");
                    }
                }

                 if (data[5] != null && !data[5].trim().isEmpty()) {
                    FlatType type2 = FlatType.fromString(data[5].trim());
                     if (type2 != null) {
                        int units2 = Integer.parseInt(data[6].trim());
                        double price2 = Double.parseDouble(data[7].trim());
                        // Assuming available units = total units initially when loading from file
                        flatTypes.put(type2, new FlatTypeDetails(units2, units2, price2));
                     } else {
                          System.err.println("Warning: Unknown flat type '" + data[5] + "' in project '" + projectName + "'. Skipping type.");
                     }
                }

                Date openingDate = Dparse.parseDate(data[8].trim());
                Date closingDate = Dparse.parseDate(data[9].trim());
                String managerNric = data[10].trim();
                int officerSlots = Integer.parseInt(data[11].trim());

                List<String> officers = LSparse.parseListString(data[12]);

                boolean visibility = false;
                if (data.length > 13 && data[13] != null) {
                     String visibilityStr = data[13].trim();
                     if (visibilityStr.equals("1")) {
                         visibility = true;
                     } else if (!visibilityStr.equals("0") && !visibilityStr.isEmpty()) {
                         System.err.println("Warning: Invalid visibility value '" + visibilityStr + "' for project '" + projectName + "'. Assuming false.");
                     }
                }


                if (!users.containsKey(managerNric) || !(users.get(managerNric) instanceof HDBManager)) {
                    System.err.println("Warning: Project '" + projectName + "' has invalid or non-manager NRIC: " + managerNric + ". Skipping project.");
                    projectNames.remove(projectName.toLowerCase());
                    return;
                }
                 if (openingDate == null || closingDate == null || closingDate.before(openingDate)) {
                     System.err.println("Warning: Project '" + projectName + "' has invalid application dates (Open: " + data[8] + ", Close: " + data[9] + "). Skipping project.");
                     projectNames.remove(projectName.toLowerCase());
                     return;
                 }
                 List<String> validOfficers = new ArrayList<>();
                 List<String> invalidOfficers = new ArrayList<>();
                 for (String nric : officers) {
                     if (users.containsKey(nric) && users.get(nric) instanceof HDBOfficer) {
                         validOfficers.add(nric);
                     } else {
                         invalidOfficers.add(nric);
                     }
                 }
                 if (!invalidOfficers.isEmpty()) {
                     System.err.println("Warning: Project '" + projectName + "' contains invalid or non-officer NRICs in its officer list: " + invalidOfficers + ". Only valid officers retained.");
                 }
                 if (validOfficers.size() > officerSlots) {
                      System.err.println("Warning: Project '" + projectName + "' has more approved officers ("+validOfficers.size()+") than slots ("+officerSlots+"). Check data. Using officer list as is.");
                 }


                Project project = new Project(projectName, neighborhood, flatTypes, openingDate, closingDate, managerNric, officerSlots, validOfficers, visibility);
                this.projects.add(project);

            } catch (NumberFormatException e) {
                System.err.println("Error parsing number in project data: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            } catch (IllegalArgumentException e) {
                System.err.println("Error parsing enum/data in project data: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            } catch (Exception e) {
                 System.err.println("Unexpected error parsing project data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
                 e.printStackTrace();
            }
        });

        System.out.println("Loaded " + this.projects.size() + " projects.");
        return new ArrayList<>(this.projects); // Return a copy
    }

    @Override
    public void saveProjects(List<Project> projectsToSave) {
        List<String[]> dataList = new ArrayList<>();
        dataList.add(PROJECT_HEADER);

        projectsToSave.forEach(project -> {
            String[] data = new String[PROJECT_HEADER.length];
            data[0] = project.getProjectName();
            data[1] = project.getNeighborhood();

            FlatTypeDetails twoRoomDetails = project.getFlatTypeDetails(FlatType.TWO_ROOM);
            FlatTypeDetails threeRoomDetails = project.getFlatTypeDetails(FlatType.THREE_ROOM);

            // Save TOTAL units, not available units, to the file. Availability is derived.
            if (twoRoomDetails != null) {
                data[2] = FlatType.TWO_ROOM.getDisplayName();
                data[3] = String.valueOf(twoRoomDetails.getTotalUnits());
                data[4] = String.valueOf(twoRoomDetails.getSellingPrice());
            } else {
                 data[2] = ""; data[3] = "0"; data[4] = "0";
            }

            if (threeRoomDetails != null) {
                data[5] = FlatType.THREE_ROOM.getDisplayName();
                data[6] = String.valueOf(threeRoomDetails.getTotalUnits());
                data[7] = String.valueOf(threeRoomDetails.getSellingPrice());
            } else {
                 data[5] = ""; data[6] = "0"; data[7] = "0";
            }

            data[8] = DateUtils.formatDate(project.getApplicationOpeningDate());
            data[9] = DateUtils.formatDate(project.getApplicationClosingDate());
            data[10] = project.getManagerNric();
            data[11] = String.valueOf(project.getMaxOfficerSlots());
            String officers = String.join(LIST_DELIMITER, project.getApprovedOfficerNrics());
            data[12] = officers;

            data[13] = project.isVisible() ? "1" : "0";

            dataList.add(data);
        });
        CsvRW.writeCsv(PROJECT_FILE, dataList);
        System.out.println("Saved projects.");
        // Update internal list if the saved list is the one managed by this service
         this.projects = new ArrayList<>(projectsToSave);
    }

     @Override
     public Project findProjectByName(String name) {
        if (name == null || name.trim().isEmpty())
            return null;
        return this.projects.stream()
                .filter(p -> p.getProjectName().equalsIgnoreCase(name.trim()))
                .findFirst()
                .orElse(null);
    }

    @Override
    public List<Project> getAllProjects() {
        return new ArrayList<>(this.projects); // Return copy
    }

     @Override
     public List<Project> getProjectsManagedBy(String managerNric) {
        if (managerNric == null) return new ArrayList<>();
         return this.projects.stream()
            .filter(p -> managerNric.equals(p.getManagerNric()))
            .collect(Collectors.toList());
     }

     @Override
     public void addProject(Project project) {
         if (project != null && findProjectByName(project.getProjectName()) == null) {
             this.projects.add(project);
         } else if (project != null) {
              System.err.println("Project with name '" + project.getProjectName() + "' already exists. Cannot add duplicate.");
         }
     }

     @Override
     public boolean removeProject(Project project) {
         if (project != null) {
             return this.projects.removeIf(p -> p.getProjectName().equals(project.getProjectName()));
         }
         return false;
     }
}
```

Services/IApplicationService.java
```java
package Services;

import java.util.List;
import java.util.Map;
import Models.BTOApplication;
import Models.Project; // Needed for adjusting units during load
import Enums.ApplicationStatus;
import Enums.FlatType;

public interface IApplicationService {
    Map<String, BTOApplication> loadApplications(List<Project> projects); // Pass projects to adjust units
    void saveApplications(Map<String, BTOApplication> applications);
    BTOApplication findApplicationById(String applicationId);
    BTOApplication findApplicationByApplicantAndProject(String nric, String projectName);
    List<BTOApplication> getApplicationsByProject(String projectName);
    List<BTOApplication> getApplicationsByStatus(ApplicationStatus status);
    List<BTOApplication> getApplicationsByApplicant(String nric);
    void addApplication(BTOApplication application);
    boolean removeApplication(String applicationId);
    Map<String, BTOApplication> getAllApplications(); // To get the map for saving/syncing
}
```

Services/ApplicationService.java
```java
package Services;

import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Models.BTOApplication;
import Models.FlatTypeDetails;
import Models.Project;
import Parsers.Dparse;
import Utils.DateUtils;

public class ApplicationService implements IApplicationService {
    private static final String DATA_DIR = "data";
    private static final String APPLICATION_FILE = DATA_DIR + File.separator + "applications.csv";
    private static final String[] APPLICATION_HEADER = { "ApplicationID", "ApplicantNRIC", "ProjectName",
            "FlatTypeApplied", "Status", "ApplicationDate" };
    private static final String DELIMITER = ",";

    private Map<String, BTOApplication> applications;

    public ApplicationService() {
        this.applications = new HashMap<>();
    }

    @Override
    public Map<String, BTOApplication> loadApplications(List<Project> projects) {
        this.applications.clear(); // Clear before loading
        Map<Project, Map<FlatType, Integer>> bookedCounts = new HashMap<>();

        CsvRW.readCsv(APPLICATION_FILE, APPLICATION_HEADER.length).forEach(data -> {
            try {
                String appId = data[0].trim();
                if (appId.isEmpty() || this.applications.containsKey(appId)) {
                    if (!appId.isEmpty())
                        System.err.println("Skipping duplicate application ID: " + appId);
                    return;
                }
                String applicantNric = data[1].trim();
                String projectName = data[2].trim();
                FlatType flatType = FlatType.fromString(data[3].trim());
                ApplicationStatus status = ApplicationStatus.valueOf(data[4].trim().toUpperCase());
                Date appDate = Dparse.parseDate(data[5].trim());

                if (appDate == null) {
                    System.err.println("Skipping application with invalid date: " + appId);
                    return;
                }
                if (flatType == null && (status == ApplicationStatus.BOOKED || status == ApplicationStatus.SUCCESSFUL
                        || status == ApplicationStatus.PENDING_WITHDRAWAL)) {
                    System.err.println("Warning: Application " + appId + " is " + status
                            + " but has invalid/missing flat type '" + data[3] + "'. Status might be inconsistent.");
                }
                if (status == ApplicationStatus.PENDING_WITHDRAWAL) {
                     // We can load it, but original status isn't stored persistently in this design
                     // The BTOApplication constructor warns about this.
                }

                BTOApplication application = new BTOApplication(appId, applicantNric, projectName, flatType, status,
                        appDate);
                this.applications.put(application.getApplicationId(), application);

                // Track booked counts to adjust project units later
                if (status == ApplicationStatus.BOOKED && flatType != null) {
                    Project project = projects.stream()
                            .filter(p -> p.getProjectName().equalsIgnoreCase(projectName))
                            .findFirst().orElse(null);
                    if (project != null) {
                        bookedCounts.computeIfAbsent(project, k -> new HashMap<>())
                                .merge(flatType, 1, Integer::sum);
                    } else {
                        System.err.println("Warning: Booked application " + appId + " refers to non-existent project '"
                                + projectName + "'. Unit count cannot be adjusted.");
                    }
                }

            } catch (IllegalArgumentException e) {
                System.err.println("Error parsing enum/data in application data: " + String.join(DELIMITER, data)
                        + " - " + e.getMessage());
            } catch (Exception e) {
                System.err.println("Error parsing application data line: " + String.join(DELIMITER, data) + " - "
                        + e.getMessage());
            }
        });

        // Adjust available units in Project objects based on loaded booked applications
        bookedCounts.forEach((project, typeCounts) -> {
            typeCounts.forEach((type, count) -> {
                FlatTypeDetails details = project.getMutableFlatTypeDetails(type); // Use mutable getter
                if (details != null) {
                    int initialAvailable = details.getTotalUnits(); // Assume file loads total, derive available
                    int finalAvailable = Math.max(0, initialAvailable - count);
                    details.setAvailableUnits(finalAvailable); // Update the project object directly
                    if (count > details.getTotalUnits()) {
                        System.err.println("Error: More flats booked (" + count + ") than total units ("
                                + details.getTotalUnits() + ") for " + project.getProjectName() + "/"
                                + type.getDisplayName() + ". Available units set to 0.");
                    }
                } else {
                    System.err.println("Warning: Trying to adjust units for non-existent flat type "
                            + type.getDisplayName() + " in project " + project.getProjectName());
                }
            });
        });

        System.out.println("Loaded " + this.applications.size() + " applications.");
        return new HashMap<>(this.applications); // Return a copy
    }

    @Override
    public void saveApplications(Map<String, BTOApplication> applicationsToSave) {
        List<String[]> dataList = new ArrayList<>();
        dataList.add(APPLICATION_HEADER);
        applicationsToSave.values().stream()
                .sorted(Comparator.comparing(BTOApplication::getApplicationId))
                .forEach(app -> {
                    dataList.add(new String[] {
                            app.getApplicationId(),
                            app.getApplicantNric(),
                            app.getProjectName(),
                            app.getFlatTypeApplied() == null ? "" : app.getFlatTypeApplied().name(), // Use name() for consistency
                            app.getStatus().name(),
                            DateUtils.formatDate(app.getApplicationDate())
                    });
                });
        CsvRW.writeCsv(APPLICATION_FILE, dataList);
        System.out.println("Saved applications.");
        this.applications = new HashMap<>(applicationsToSave); // Update internal map
    }

     @Override
     public BTOApplication findApplicationById(String applicationId) {
         return this.applications.get(applicationId);
     }

     @Override
     public BTOApplication findApplicationByApplicantAndProject(String nric, String projectName) {
         if (nric == null || projectName == null) return null;
         String appId = nric + "_" + projectName;
         return findApplicationById(appId);
     }

     @Override
     public List<BTOApplication> getApplicationsByProject(String projectName) {
         if (projectName == null) return new ArrayList<>();
         return this.applications.values().stream()
             .filter(app -> projectName.equals(app.getProjectName()))
             .collect(Collectors.toList());
     }

     @Override
     public List<BTOApplication> getApplicationsByStatus(ApplicationStatus status) {
          if (status == null) return new ArrayList<>();
          return this.applications.values().stream()
              .filter(app -> status.equals(app.getStatus()))
              .collect(Collectors.toList());
     }

    @Override
     public List<BTOApplication> getApplicationsByApplicant(String nric) {
         if (nric == null) return new ArrayList<>();
         return this.applications.values().stream()
             .filter(app -> nric.equals(app.getApplicantNric()))
             .collect(Collectors.toList());
     }

     @Override
     public void addApplication(BTOApplication application) {
         if (application != null && !this.applications.containsKey(application.getApplicationId())) {
             this.applications.put(application.getApplicationId(), application);
         } else if (application != null) {
             System.err.println("Application with ID " + application.getApplicationId() + " already exists.");
         }
     }

     @Override
     public boolean removeApplication(String applicationId) {
         if (applicationId != null) {
             return this.applications.remove(applicationId) != null;
         }
         return false;
     }

     @Override
     public Map<String, BTOApplication> getAllApplications() {
         return new HashMap<>(this.applications); // Return copy
     }
}
```

Services/IEnquiryService.java
```java
package Services;

import java.util.List;
import Models.Enquiry;

public interface IEnquiryService {
    List<Enquiry> loadEnquiries();
    void saveEnquiries(List<Enquiry> enquiries);
    void addEnquiry(Enquiry enquiry);
    boolean removeEnquiry(String enquiryId);
    Enquiry findEnquiryById(String enquiryId);
    List<Enquiry> getEnquiriesByApplicant(String applicantNric);
    List<Enquiry> getEnquiriesByProject(String projectName);
    List<Enquiry> getAllEnquiries(); // To get list for saving/syncing
}
```

Services/EnquiryService.java
```java
package Services;

import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import Models.Enquiry;
import Parsers.Dparse;
import Utils.DateUtils;

public class EnquiryService implements IEnquiryService {
    private static final String DATA_DIR = "data";
    private static final String DELIMITER = ",";
    private static final String ENQUIRY_FILE = DATA_DIR + File.separator + "enquiries.csv";
    private static final String[] ENQUIRY_HEADER = {"EnquiryID", "ApplicantNRIC", "ProjectName", "EnquiryText", "ReplyText", "RepliedByNRIC", "EnquiryDate", "ReplyDate"};

    private List<Enquiry> enquiries;

    public EnquiryService() {
        this.enquiries = new ArrayList<>();
    }

    @Override
    public List<Enquiry> loadEnquiries() {
        this.enquiries.clear(); // Clear before loading
        Set<String> enquiryIds = new HashSet<>(); // Track IDs during load

        CsvRW.readCsv(ENQUIRY_FILE, ENQUIRY_HEADER.length).forEach(data -> {
            try {
                String id = data[0].trim();
                 if (id.isEmpty() || !enquiryIds.add(id)) { // Use the temporary set for check
                     if (!id.isEmpty()) System.err.println("Skipping duplicate enquiry ID: " + id);
                    return;
                 }
                String applicantNric = data[1].trim();
                String projectName = data[2].trim();
                String text = data[3].trim();
                String reply = data[4].trim();
                String repliedBy = data[5].trim();
                Date enqDate = Dparse.parseDate(data[6].trim());
                Date replyDate = Dparse.parseDate(data[7].trim());

                 if (text.isEmpty() || enqDate == null) {
                     System.err.println("Skipping enquiry with missing text or invalid date: " + id);
                     enquiryIds.remove(id); // Remove invalid ID from tracking set
                     return;
                 }
                 if ((reply != null && !reply.isEmpty()) && (repliedBy == null || repliedBy.isEmpty() || replyDate == null)) {
                     System.err.println("Warning: Enquiry " + id + " seems replied but missing replier NRIC or reply date. Loading reply as is.");
                 }

                // Use the constructor that takes all fields including ID
                Enquiry enquiry = new Enquiry(id, applicantNric, projectName, text, reply, repliedBy, enqDate, replyDate);
                this.enquiries.add(enquiry);
                 // The Enquiry constructor now handles updating the static nextId internally
            } catch (IllegalArgumentException e) {
                 System.err.println("Error parsing enum/data in enquiry data: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            } catch (Exception e) {
                System.err.println("Error parsing enquiry data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        });
        Enquiry.finalizeNextIdInitialization(); // Call static method after loading all
        System.out.println("Loaded " + this.enquiries.size() + " enquiries.");
        return new ArrayList<>(this.enquiries); // Return copy
    }

    @Override
    public void saveEnquiries(List<Enquiry> enquiriesToSave) {
        List<String[]> dataList = new ArrayList<>();
        dataList.add(ENQUIRY_HEADER);
        enquiriesToSave.stream()
            .sorted(Comparator.comparing(Enquiry::getEnquiryId))
            .forEach(enq -> {
                dataList.add(new String[]{
                    enq.getEnquiryId(),
                    enq.getApplicantNric(),
                    enq.getProjectName(),
                    enq.getEnquiryText(),
                    enq.getReplyText() == null ? "" : enq.getReplyText(),
                    enq.getRepliedByNric() == null ? "" : enq.getRepliedByNric(),
                    DateUtils.formatDate(enq.getEnquiryDate()),
                    enq.getReplyDate() == null ? "" : DateUtils.formatDate(enq.getReplyDate()) // Handle null reply date
                });
            });
        CsvRW.writeCsv(ENQUIRY_FILE, dataList);
        System.out.println("Saved enquiries.");
        this.enquiries = new ArrayList<>(enquiriesToSave); // Update internal list
    }

     @Override
     public void addEnquiry(Enquiry enquiry) {
         if (enquiry != null && findEnquiryById(enquiry.getEnquiryId()) == null) {
             this.enquiries.add(enquiry);
         } else if (enquiry != null) {
             System.err.println("Enquiry with ID " + enquiry.getEnquiryId() + " already exists.");
         }
     }

     @Override
     public boolean removeEnquiry(String enquiryId) {
         if (enquiryId != null) {
             return this.enquiries.removeIf(e -> enquiryId.equals(e.getEnquiryId()));
         }
         return false;
     }

     @Override
     public Enquiry findEnquiryById(String enquiryId) {
         if (enquiryId == null) return null;
         return this.enquiries.stream()
             .filter(e -> enquiryId.equals(e.getEnquiryId()))
             .findFirst()
             .orElse(null);
     }

     @Override
     public List<Enquiry> getEnquiriesByApplicant(String applicantNric) {
         if (applicantNric == null) return new ArrayList<>();
         return this.enquiries.stream()
             .filter(e -> applicantNric.equals(e.getApplicantNric()))
             .collect(Collectors.toList());
     }

     @Override
     public List<Enquiry> getEnquiriesByProject(String projectName) {
         if (projectName == null) return new ArrayList<>();
         return this.enquiries.stream()
             .filter(e -> projectName.equals(e.getProjectName()))
             .collect(Collectors.toList());
     }

     @Override
     public List<Enquiry> getAllEnquiries() {
         return new ArrayList<>(this.enquiries); // Return copy
     }
}
```

Services/IOfficerRegistrationService.java
```java
package Services;

import java.util.List;
import java.util.Map;
import Models.OfficerRegistration;
import Models.Project; // Needed for validation during load
import Models.User; // Needed for validation during load
import Enums.OfficerRegistrationStatus;

public interface IOfficerRegistrationService {
    Map<String, OfficerRegistration> loadOfficerRegistrations(Map<String, User> users, List<Project> projects); // Pass dependencies for validation
    void saveOfficerRegistrations(Map<String, OfficerRegistration> registrations);
    OfficerRegistration findRegistrationById(String registrationId);
    List<OfficerRegistration> getRegistrationsByOfficer(String officerNric);
    List<OfficerRegistration> getRegistrationsByProject(String projectName);
    List<OfficerRegistration> getRegistrationsByStatus(OfficerRegistrationStatus status);
    OfficerRegistration getApprovedRegistrationForOfficer(String officerNric); // More specific query
    void addRegistration(OfficerRegistration registration);
    boolean removeRegistration(String registrationId);
    Map<String, OfficerRegistration> getAllRegistrations(); // To get map for saving/syncing
}
```

Services/OfficerRegistrationService.java
```java
package Services;

import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import Enums.OfficerRegistrationStatus;
import Models.HDBOfficer;
import Models.OfficerRegistration;
import Models.Project;
import Models.User;
import Parsers.Dparse;
import Utils.DateUtils;

public class OfficerRegistrationService implements IOfficerRegistrationService {
    private static final String DATA_DIR = "data";
    private static final String DELIMITER = ",";
    private static final String OFFICER_REGISTRATION_FILE = DATA_DIR + File.separator + "officer_registrations.csv";
    private static final String[] OFFICER_REGISTRATION_HEADER = {"RegistrationID", "OfficerNRIC", "ProjectName", "Status", "RegistrationDate"};

    private Map<String, OfficerRegistration> registrations;

    public OfficerRegistrationService() {
        this.registrations = new HashMap<>();
    }

    @Override
    public Map<String, OfficerRegistration> loadOfficerRegistrations(Map<String, User> users, List<Project> projects) {
        this.registrations.clear(); // Clear before loading

        CsvRW.readCsv(OFFICER_REGISTRATION_FILE, OFFICER_REGISTRATION_HEADER.length).forEach(data -> {
            try {
                String regId = data[0].trim();
                 if (regId.isEmpty() || this.registrations.containsKey(regId)) {
                     if (!regId.isEmpty()) System.err.println("Skipping duplicate registration ID: " + regId);
                    return;
                 }
                String officerNric = data[1].trim();
                String projectName = data[2].trim();
                OfficerRegistrationStatus status = OfficerRegistrationStatus.valueOf(data[3].trim().toUpperCase());
                Date regDate = Dparse.parseDate(data[4].trim());

                 if (regDate == null) {
                     System.err.println("Skipping registration with invalid date: " + regId);
                     return;
                 }

                 // Validate Officer NRIC using the provided users map
                 if (!users.containsKey(officerNric) || !(users.get(officerNric) instanceof HDBOfficer)) {
                     System.err.println("Warning: Registration " + regId + " refers to invalid or non-officer NRIC: " + officerNric + ". Skipping registration.");
                     return;
                 }
                 // Validate Project Name using the provided projects list
                 boolean projectExists = projects.stream().anyMatch(p -> p.getProjectName().equalsIgnoreCase(projectName));
                 if (!projectExists) {
                      System.err.println("Warning: Registration " + regId + " refers to non-existent project: " + projectName + ". Skipping registration.");
                      return;
                 }

                // Use constructor accepting all fields
                OfficerRegistration registration = new OfficerRegistration(regId, officerNric, projectName, status, regDate);
                this.registrations.put(registration.getRegistrationId(), registration);
            } catch (IllegalArgumentException e) {
                 System.err.println("Error parsing enum/data in officer registration data: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            } catch (Exception e) {
                System.err.println("Error parsing officer registration data line: " + String.join(DELIMITER, data) + " - " + e.getMessage());
            }
        });
        System.out.println("Loaded " + this.registrations.size() + " officer registrations.");
        return new HashMap<>(this.registrations); // Return copy
    }

    @Override
    public void saveOfficerRegistrations(Map<String, OfficerRegistration> registrationsToSave) {
        List<String[]> dataList = new ArrayList<>();
        dataList.add(OFFICER_REGISTRATION_HEADER);
        registrationsToSave.values().stream()
            .sorted(Comparator.comparing(OfficerRegistration::getRegistrationId))
            .forEach(reg -> {
                dataList.add(new String[]{
                    reg.getRegistrationId(),
                    reg.getOfficerNric(),
                    reg.getProjectName(),
                    reg.getStatus().name(),
                    DateUtils.formatDate(reg.getRegistrationDate())
                });
            });
        CsvRW.writeCsv(OFFICER_REGISTRATION_FILE, dataList);
        System.out.println("Saved officer registrations.");
        this.registrations = new HashMap<>(registrationsToSave); // Update internal map
    }

    @Override
    public OfficerRegistration findRegistrationById(String registrationId) {
        return this.registrations.get(registrationId);
    }

    @Override
    public List<OfficerRegistration> getRegistrationsByOfficer(String officerNric) {
        if (officerNric == null) return new ArrayList<>();
        return this.registrations.values().stream()
            .filter(reg -> officerNric.equals(reg.getOfficerNric()))
            .collect(Collectors.toList());
    }

    @Override
    public List<OfficerRegistration> getRegistrationsByProject(String projectName) {
        if (projectName == null) return new ArrayList<>();
        return this.registrations.values().stream()
            .filter(reg -> projectName.equals(reg.getProjectName()))
            .collect(Collectors.toList());
    }

     @Override
     public List<OfficerRegistration> getRegistrationsByStatus(OfficerRegistrationStatus status) {
          if (status == null) return new ArrayList<>();
          return this.registrations.values().stream()
              .filter(reg -> status.equals(reg.getStatus()))
              .collect(Collectors.toList());
     }

    @Override
    public OfficerRegistration getApprovedRegistrationForOfficer(String officerNric) {
         if (officerNric == null) return null;
         return this.registrations.values().stream()
            .filter(reg -> officerNric.equals(reg.getOfficerNric()) && reg.getStatus() == OfficerRegistrationStatus.APPROVED)
            .findFirst() // Assuming an officer can only be approved for one project at a time
            .orElse(null);
    }


    @Override
    public void addRegistration(OfficerRegistration registration) {
        if (registration != null && !this.registrations.containsKey(registration.getRegistrationId())) {
            this.registrations.put(registration.getRegistrationId(), registration);
        } else if (registration != null) {
             System.err.println("Registration with ID " + registration.getRegistrationId() + " already exists.");
        }
    }

    @Override
    public boolean removeRegistration(String registrationId) {
        if (registrationId != null) {
            return this.registrations.remove(registrationId) != null;
        }
        return false;
    }

    @Override
    public Map<String, OfficerRegistration> getAllRegistrations() {
        return new HashMap<>(this.registrations); // Return copy
    }
}
```

Services/DataService.java
```java
package Services;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Date;
import java.util.Comparator;
import java.io.File;

import Enums.MaritalStatus;
import Enums.OfficerRegistrationStatus;
import Enums.ApplicationStatus;

import Models.Project;
import Models.BTOApplication;
import Models.Enquiry;
import Models.OfficerRegistration;
import Models.User;
import Models.Applicant;
import Models.HDBOfficer;
import Models.HDBManager;

// DataService retains static methods for coordination and user file I/O
public class DataService {
    private static final String DATA_DIR = "data";
    private static final String APPLICANT_LIST_FILE = DATA_DIR + File.separator + "ApplicantList.csv";
    private static final String OFFICER_LIST_FILE = DATA_DIR + File.separator + "OfficerList.csv";
    private static final String MANAGER_LIST_FILE = DATA_DIR + File.separator + "ManagerList.csv";

    private static final String DELIMITER = ",";
    public static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");

    private static final String[] APPLICANT_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };
    private static final String[] OFFICER_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };
    private static final String[] MANAGER_HEADER = { "Name", "NRIC", "Age", "Marital Status", "Password" };
    // NricValidator usage moved to where NRICs are actually processed (e.g., UserService, AuthController)

    // loadUsers is now primarily handled by UserService instance
    // This static method could potentially be removed or adapted if needed for a specific bootstrapping scenario.
    // For now, keep the saveUsers static method as it was used by AuthController.
    // And saveAllData for convenience during shutdown.

    public static void synchronizeData(IUserService userService, IProjectService projectService, IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService) {
        System.out.println("Synchronizing loaded data...");

        Map<String, User> users = userService.getAllUsers();
        List<Project> projects = projectService.getAllProjects();
        Map<String, BTOApplication> applications = applicationService.getAllApplications();
        Map<String, OfficerRegistration> officerRegistrations = officerRegistrationService.getAllRegistrations();

        boolean registrationsModified = false;
        boolean projectsModified = false; // Track if project available units were changed

        // Sync Applicant state from Applications
        users.values().stream()
                .filter(u -> u instanceof Applicant)
                .map(u -> (Applicant) u)
                .forEach(applicant -> {
                    BTOApplication relevantApp = applications.values().stream()
                            .filter(app -> app.getApplicantNric().equals(applicant.getNric()))
                            .max(Comparator.comparing(BTOApplication::getStatus,
                                    Comparator.comparingInt(s -> {
                                        // Explicit priority order
                                        switch (s) {
                                            case BOOKED: return 6;
                                            case SUCCESSFUL: return 5;
                                            case PENDING_WITHDRAWAL: return 4;
                                            case PENDING: return 3;
                                            case WITHDRAWN: return 2;
                                            case UNSUCCESSFUL: return 1;
                                            default: return 0;
                                        }
                                    })).thenComparing(BTOApplication::getApplicationDate, Comparator.reverseOrder())) // Prefer latest application for same status
                            .orElse(null);

                    if (relevantApp != null) {
                        applicant.setAppliedProjectName(relevantApp.getProjectName());
                        applicant.setApplicationStatus(relevantApp.getStatus());
                        if (relevantApp.getStatus() == ApplicationStatus.BOOKED) {
                            applicant.setBookedFlatType(relevantApp.getFlatTypeApplied());
                        } else {
                            applicant.setBookedFlatType(null);
                        }
                    } else {
                        applicant.clearApplicationState();
                    }
                });


        // Sync Project approved officers with Officer Registrations
        for (Project project : projects) {
            List<String> approvedNricsFromProject = new ArrayList<>(project.getApprovedOfficerNrics()); // Copy

            // Check officers listed in project against registrations
            for (String officerNric : approvedNricsFromProject) {
                User user = users.get(officerNric);
                if (!(user instanceof HDBOfficer)) {
                    System.err.println("Data Sync Warning: NRIC " + officerNric + " in project '"
                            + project.getProjectName()
                            + "' approved list is not a valid HDB Officer. Consider removing from project CSV.");
                    continue; // Skip this NRIC
                }

                // Check if an APPROVED registration exists for this officer+project
                String expectedRegId = officerNric + "_REG_" + project.getProjectName();
                OfficerRegistration existingReg = officerRegistrations.get(expectedRegId);

                if (existingReg == null || existingReg.getStatus() != OfficerRegistrationStatus.APPROVED) {
                    // If project says officer is approved, but no APPROVED registration exists, create/update one.
                    System.out.println("Info: Auto-creating/updating APPROVED registration for Officer " + officerNric
                            + " for Project '" + project.getProjectName() + "' based on project list.");

                    // Use a placeholder date or project start date
                    Date placeholderDate = project.getApplicationOpeningDate() != null
                            ? project.getApplicationOpeningDate()
                            : new Date(0); // Epoch as fallback

                    OfficerRegistration syncReg = new OfficerRegistration(expectedRegId, officerNric,
                            project.getProjectName(), OfficerRegistrationStatus.APPROVED, placeholderDate);
                    officerRegistrations.put(syncReg.getRegistrationId(), syncReg); // Update the map directly
                    registrationsModified = true;
                }
            }

             // Check approved registrations against the project list
             officerRegistrations.values().stream()
                .filter(reg -> reg.getProjectName().equals(project.getProjectName()) && reg.getStatus() == OfficerRegistrationStatus.APPROVED)
                .forEach(reg -> {
                    if (!project.getApprovedOfficerNrics().contains(reg.getOfficerNric())) {
                         System.err.println("Data Sync Warning: Approved registration " + reg.getRegistrationId()
                                + " exists, but officer " + reg.getOfficerNric() + " is NOT in project '"
                                + project.getProjectName()
                                + "' approved list. Project CSV might be outdated or registration status incorrect.");
                         // Optionally: could remove the officer from the registration here, or change status to pending?
                         // For now, just warn.
                    }
                });
        }

        // Note: Adjusting project available units based on booked applications
        // is now handled within ApplicationService.loadApplications.

        if (registrationsModified) {
            System.out.println("Saving updated officer registrations due to synchronization...");
            // Use the service instance to save the modified map
            officerRegistrationService.saveOfficerRegistrations(officerRegistrations);
        }
         // Saving projects or users happens elsewhere based on user actions or final save.

        System.out.println("Data synchronization complete.");
    }

    // Keep saveAllData for convenience, using the service instances
    public static void saveAllData(IUserService userService, IProjectService projectService, IApplicationService applicationService, IEnquiryService enquiryService, IOfficerRegistrationService officerRegistrationService) {
        System.out.println("Saving all data...");
        userService.saveUsers(userService.getAllUsers()); // Save the current state managed by userService
        projectService.saveProjects(projectService.getAllProjects());
        applicationService.saveApplications(applicationService.getAllApplications());
        enquiryService.saveEnquiries(enquiryService.getAllEnquiries());
        officerRegistrationService.saveOfficerRegistrations(officerRegistrationService.getAllRegistrations());
        System.out.println("All data saved.");
    }

     // Keep saveUsers static as AuthController uses it directly
     public static void saveUsers(Map<String, User> users) {
         // This static method now duplicates the logic in UserService.saveUsers.
         // Ideally, AuthController should use IUserService.
         // For minimal change, we keep this static version functional.
         List<String[]> applicantData = new ArrayList<>();
         List<String[]> officerData = new ArrayList<>();
         List<String[]> managerData = new ArrayList<>();

         applicantData.add(APPLICANT_HEADER);
         officerData.add(OFFICER_HEADER);
         managerData.add(MANAGER_HEADER);

         users.values().forEach(user -> {
             String[] userData = {
                     user.getName(),
                     user.getNric(),
                     String.valueOf(user.getAge()),
                     user.getMaritalStatus().name(),
                     user.getPassword()
             };
             switch (user.getRole()) {
                 case HDB_MANAGER:
                     managerData.add(userData);
                     break;
                 case HDB_OFFICER:
                     officerData.add(userData);
                     break;
                 case APPLICANT:
                     applicantData.add(userData);
                     break;
             }
         });

         CsvRW.writeCsv(APPLICANT_LIST_FILE, applicantData);
         CsvRW.writeCsv(OFFICER_LIST_FILE, officerData);
         CsvRW.writeCsv(MANAGER_LIST_FILE, managerData);
         System.out.println("Saved users (via static DataService method).");
     }
}
```

Services/CsvRW.java
```java
package Services;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.text.SimpleDateFormat;
import java.util.List;
import java.util.stream.Collectors;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

// CsvRW remains a static utility class
public class CsvRW {
    // File paths and headers remain defined here for getHeaderForFile logic
    private static final String DATA_DIR = "data";
    private static final String APPLICANT_LIST_FILE = DATA_DIR + File.separator + "ApplicantList.csv";
    private static final String OFFICER_LIST_FILE = DATA_DIR + File.separator + "OfficerList.csv";
    private static final String MANAGER_LIST_FILE = DATA_DIR + File.separator + "ManagerList.csv";
    private static final String PROJECT_FILE = DATA_DIR + File.separator + "ProjectList.csv";
    private static final String APPLICATION_FILE = DATA_DIR + File.separator + "applications.csv";
    private static final String ENQUIRY_FILE = DATA_DIR + File.separator + "enquiries.csv";
    private static final String OFFICER_REGISTRATION_FILE = DATA_DIR + File.separator + "officer_registrations.csv";

    private static final String DELIMITER = ",";
    private static final String LIST_DELIMITER = ";";
    public static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");

    // Headers are needed internally for file creation logic
    private static final String[] APPLICANT_HEADER = {"Name", "NRIC", "Age", "Marital Status", "Password"};
    private static final String[] OFFICER_HEADER = {"Name", "NRIC", "Age", "Marital Status", "Password"};
    private static final String[] MANAGER_HEADER = {"Name", "NRIC", "Age", "Marital Status", "Password"};
    private static final String[] PROJECT_HEADER = {
        "Project Name", "Neighborhood", "Type 1", "Number of units for Type 1", "Selling price for Type 1",
        "Type 2", "Number of units for Type 2", "Selling price for Type 2",
        "Application opening date", "Application closing date", "Manager", "Officer Slot", "Officer", "Visibility"
    };
    private static final String[] APPLICATION_HEADER = {"ApplicationID", "ApplicantNRIC", "ProjectName", "FlatTypeApplied", "Status", "ApplicationDate"};
    private static final String[] ENQUIRY_HEADER = {"EnquiryID", "ApplicantNRIC", "ProjectName", "EnquiryText", "ReplyText", "RepliedByNRIC", "EnquiryDate", "ReplyDate"};
    private static final String[] OFFICER_REGISTRATION_HEADER = {"RegistrationID", "OfficerNRIC", "ProjectName", "Status", "RegistrationDate"};


    public static List<String[]> readCsv(String filename, int expectedColumns) {
        List<String[]> data = new ArrayList<>();
        Path path = Paths.get(filename);

        if (!Files.exists(path)) {
            System.err.println("Warning: File not found - " + filename + ". Attempting to create.");
            try {
                Path parent = path.getParent();
                if (parent != null) {
                    Files.createDirectories(parent);
                }
                Files.createFile(path);
                String[] header = getHeaderForFile(filename);
                if (header != null) {
                    // Write only the header using the writeCsv method
                    writeCsv(filename, Collections.singletonList(header));
                    System.out.println("Created new file with header: " + filename);
                } else {
                     System.err.println("Could not determine header for new file: " + filename);
                }
            } catch (IOException e) {
                System.err.println("FATAL: Error creating file: " + filename + " - " + e.getMessage() + ". Application might not function correctly.");
            }
            return data; // Return empty list if file was just created or failed to create
        }

        try (BufferedReader br = Files.newBufferedReader(path)) {
            String line;
            boolean isFirstLine = true;
            int lineNumber = 0;
            while ((line = br.readLine()) != null) {
                lineNumber++;
                if (isFirstLine || line.trim().isEmpty()) {
                    isFirstLine = false; // Skip header line
                    continue; // Skip empty lines
                }

                // Regex to handle quoted fields containing delimiters
                String[] values = line.split(DELIMITER + "(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", -1);

                // Trim and unescape quoted values
                for (int i = 0; i < values.length; i++) {
                    values[i] = values[i].trim();
                    // Handle potential quotes properly
                    if (values[i].startsWith("\"") && values[i].endsWith("\"") && values[i].length() >= 2) {
                        values[i] = values[i].substring(1, values[i].length() - 1).replace("\"\"", "\""); // Unescape double quotes
                    }
                }

                // Handle specific case for Project file missing visibility column
                if (values.length < expectedColumns && filename.endsWith(PROJECT_FILE.substring(DATA_DIR.length() + 1)) && values.length == expectedColumns -1) {
                     String[] paddedValues = Arrays.copyOf(values, expectedColumns);
                     paddedValues[expectedColumns - 1] = "0"; // Assume visibility 'Off'
                     values = paddedValues;
                     System.out.println("Info: Line " + lineNumber + " in " + filename + " seems to be missing the 'Visibility' column. Assuming '0' (Off).");
                } else if (values.length != expectedColumns) {
                     System.err.println("Warning: Malformed line " + lineNumber + " in " + filename + ". Expected " + expectedColumns + " columns, found " + values.length + ". Skipping line: " + line);
                     continue; // Skip lines with wrong number of columns
                }

                data.add(values);
            }
        } catch (IOException e) {
            System.err.println("FATAL: Error reading file: " + filename + " - " + e.getMessage());
            // Depending on severity, might want to throw exception or exit
        }
        return data;
    }

    public static void writeCsv(String filename, List<String[]> data) {
        Path path = Paths.get(filename);
        try {
             // Ensure parent directory exists
             Path parent = path.getParent();
             if (parent != null) {
                 Files.createDirectories(parent);
             }

             // Use try-with-resources for BufferedWriter
             // Use TRUNCATE_EXISTING to overwrite the file completely
             try (BufferedWriter bw = Files.newBufferedWriter(path, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {
                for (String[] row : data) {
                    String line = Arrays.stream(row)
                                        .map(CsvRW::escapeCsvField) // Use static method reference
                                        .collect(Collectors.joining(DELIMITER));
                    bw.write(line);
                    bw.newLine(); // Add newline character after each row
                }
            }
        } catch (IOException e) {
            System.err.println("Error writing file: " + filename + " - " + e.getMessage());
             // Depending on severity, might want to throw exception
        }
    }
    // Helper to get header based on filename (relative to DATA_DIR)
    private static String[] getHeaderForFile(String filename) {
        Path p = Paths.get(filename);
        String baseName = p.getFileName().toString();

        // Compare base filenames
        if (baseName.equals(Paths.get(APPLICANT_LIST_FILE).getFileName().toString())) return APPLICANT_HEADER;
        if (baseName.equals(Paths.get(OFFICER_LIST_FILE).getFileName().toString())) return OFFICER_HEADER;
        if (baseName.equals(Paths.get(MANAGER_LIST_FILE).getFileName().toString())) return MANAGER_HEADER;
        if (baseName.equals(Paths.get(PROJECT_FILE).getFileName().toString())) return PROJECT_HEADER;
        if (baseName.equals(Paths.get(APPLICATION_FILE).getFileName().toString())) return APPLICATION_HEADER;
        if (baseName.equals(Paths.get(ENQUIRY_FILE).getFileName().toString())) return ENQUIRY_HEADER;
        if (baseName.equals(Paths.get(OFFICER_REGISTRATION_FILE).getFileName().toString())) return OFFICER_REGISTRATION_HEADER;

        return null; // Unknown file type
    }

    // Helper method to escape fields for CSV writing
    private static String escapeCsvField(String field) {
        if (field == null) return ""; // Represent null as empty string
        // Quote field if it contains delimiter, quote, list delimiter, or newline characters
        if (field.contains(DELIMITER) || field.contains("\"") || field.contains(LIST_DELIMITER) || field.contains("\n") || field.contains("\r")) {
            // Escape existing quotes by doubling them and wrap the whole field in quotes
            return "\"" + field.replace("\"", "\"\"") + "\"";
        }
        // No special characters, return as is
        return field;
    }
}
```

Controllers/BaseController.java
```java
package Controllers;

import Enums.OfficerRegistrationStatus;
import Enums.FlatType;
import Enums.ApplicationStatus;
import Enums.MaritalStatus;
import Enums.UserRole;

import Models.User;
import Parsers.Dparse;
import Models.Project;
import Models.BTOApplication;
import Models.Enquiry;
import Models.HDBManager;
import Models.HDBOfficer;
import Models.Applicant;
import Models.OfficerRegistration;
import Models.FlatTypeDetails;

import Services.IApplicationService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;

import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Comparator;
import java.util.stream.Collectors;

import Utils.DateUtils;

public abstract class BaseController {
    // Services are injected instead of raw data maps
    protected final IUserService userService;
    protected final IProjectService projectService;
    protected final IApplicationService applicationService;
    protected final IOfficerRegistrationService officerRegistrationService;
    // User, Scanner, AuthController remain
    protected final User currentUser;
    protected final Scanner scanner;
    protected final AuthController authController;

    // Filters remain as state within the controller instance (or potentially moved to a separate FilterState object)
    protected String filterLocation = null;
    protected FlatType filterFlatType = null;

    public BaseController(IUserService userService, IProjectService projectService,
                          IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                          User currentUser, Scanner scanner, AuthController authController) {
        this.userService = userService;
        this.projectService = projectService;
        this.applicationService = applicationService;
        this.officerRegistrationService = officerRegistrationService;
        this.currentUser = currentUser;
        this.scanner = scanner;
        this.authController = authController;
    }

    // Finding methods now use injected services
    protected Project findProjectByName(String name) {
        return projectService.findProjectByName(name);
    }

    protected BTOApplication findApplicationByApplicantAndProject(String nric, String projectName) {
        return applicationService.findApplicationByApplicantAndProject(nric, projectName);
    }

    // This logic relies on OfficerRegistrationService now
    public Project getOfficerHandlingProject(HDBOfficer officer) {
        if (officer == null)
            return null;
        Date today = DateUtils.getCurrentDate();
        OfficerRegistration approvedReg = officerRegistrationService.getApprovedRegistrationForOfficer(officer.getNric());

        if (approvedReg != null) {
            Project project = projectService.findProjectByName(approvedReg.getProjectName());
            // Additionally check if the project's application period is still active
            if (project != null && project.isApplicationPeriodActive(today)) {
                return project;
            }
        }
        return null;
    }

    // Date overlap logic remains the same
    protected boolean checkDateOverlap(Project p1, Project p2) {
        if (p1 == null || p2 == null || p1.getApplicationOpeningDate() == null || p1.getApplicationClosingDate() == null
                || p2.getApplicationOpeningDate() == null || p2.getApplicationClosingDate() == null) {
            return false;
        }
        // Check if p1 starts after p2 ends OR p1 ends before p2 starts
        boolean noOverlap = p1.getApplicationOpeningDate().after(p2.getApplicationClosingDate()) ||
                            p1.getApplicationClosingDate().before(p2.getApplicationOpeningDate());
        return !noOverlap; // Overlap exists if 'noOverlap' is false
    }

    // Filtering now operates on the list returned by the service
    protected List<Project> getFilteredProjects(boolean checkVisibility, boolean checkEligibility,
            boolean checkAvailability, boolean checkApplicationPeriod, boolean checkNotExpired) {
        Date currentDate = DateUtils.getCurrentDate();
        List<Project> allProjects = projectService.getAllProjects(); // Get all projects from the service

        return allProjects.stream()
                // Apply location and flat type filters first
                .filter(p -> filterLocation == null || p.getNeighborhood().equalsIgnoreCase(filterLocation))
                .filter(p -> filterFlatType == null || p.getFlatTypes().containsKey(filterFlatType))
                // Apply boolean checks passed as arguments
                .filter(p -> !checkVisibility || isProjectVisibleToCurrentUser(p))
                .filter(p -> !checkApplicationPeriod || p.isApplicationPeriodActive(currentDate))
                .filter(p -> !checkNotExpired || !p.isApplicationPeriodExpired(currentDate))
                // Apply eligibility and availability checks
                .filter(p -> {
                    if (!checkEligibility && !checkAvailability) return true; // Skip if not checking these
                    if (currentUser instanceof HDBManager) return true; // Managers see all regardless

                    // Check if current user is eligible for *any* flat type in this project
                    boolean eligibleForAnyType = p.getFlatTypes().keySet().stream()
                            .anyMatch(flatType -> this.canApplyForFlatType(flatType));
                    if (checkEligibility && !eligibleForAnyType) return false; // Filter out if eligibility check fails

                    if (!checkAvailability) return true; // Skip availability check if not required

                    // Check if there's at least one flat type that the user is eligible for AND has available units
                    boolean eligibleAndAvailableExists = p.getFlatTypes().entrySet().stream()
                            .anyMatch(entry -> {
                                FlatType type = entry.getKey();
                                FlatTypeDetails details = entry.getValue();
                                return canApplyForFlatType(type) && details.getAvailableUnits() > 0;
                            });
                    return eligibleAndAvailableExists; // Must satisfy both eligibility (if checked) and availability (if checked)
                })
                .sorted(Comparator.comparing(Project::getProjectName)) // Sort final filtered list
                .collect(Collectors.toList());
    }

    // Visibility check needs OfficerRegistrationService
    protected boolean isProjectVisibleToCurrentUser(Project project) {
        if (currentUser instanceof HDBManager) return true; // Managers see everything

        boolean appliedToThis = false;
        if (currentUser instanceof Applicant) {
            Applicant appUser = (Applicant) currentUser;
            // Check if applicant applied to *this* project and status is relevant (not failed/withdrawn)
            appliedToThis = project.getProjectName().equals(appUser.getAppliedProjectName()) &&
                            appUser.getApplicationStatus() != null &&
                            appUser.getApplicationStatus() != ApplicationStatus.UNSUCCESSFUL &&
                            appUser.getApplicationStatus() != ApplicationStatus.WITHDRAWN;
        }

        boolean isHandlingOfficer = false;
        if (currentUser instanceof HDBOfficer) {
            // Check registrations service if this officer is approved for this project
             isHandlingOfficer = officerRegistrationService.getRegistrationsByOfficer(currentUser.getNric())
                                    .stream()
                                    .anyMatch(reg -> reg.getProjectName().equals(project.getProjectName()) &&
                                            reg.getStatus() == OfficerRegistrationStatus.APPROVED);

        }

        // Visible if globally visible OR user applied OR user is handling officer
        return project.isVisible() || appliedToThis || isHandlingOfficer;
    }

    // Eligibility check remains based on user type, age, marital status
    protected boolean canApplyForFlatType(FlatType type) {
        if (currentUser instanceof HDBManager) return false; // Managers cannot apply

        // Based on HDB rules (simplified)
        if (currentUser.getMaritalStatus() == MaritalStatus.SINGLE) {
            // Singles >= 35 can apply for 2-Room Flexi (represented as TWO_ROOM here)
            return currentUser.getAge() >= 35 && type == FlatType.TWO_ROOM;
        } else if (currentUser.getMaritalStatus() == MaritalStatus.MARRIED) {
            // Married couples >= 21 can apply for 2-Room or 3-Room
            return currentUser.getAge() >= 21 && (type == FlatType.TWO_ROOM || type == FlatType.THREE_ROOM);
        }
        // Other cases (e.g., divorced, widowed) might have different rules, not covered here
        return false;
    }

    // applyFilters method remains the same, modifying the controller's internal state
    public void applyFilters() {
        System.out.println("\n--- Apply/Clear Filters ---");
        System.out.print("Enter neighborhood to filter by (current: "
                + (filterLocation == null ? "Any" : filterLocation) + ", leave blank to clear): ");
        String loc = scanner.nextLine().trim();
        filterLocation = loc.isEmpty() ? null : loc;

        System.out.print("Enter flat type to filter by (TWO_ROOM, THREE_ROOM, current: "
                + (filterFlatType == null ? "Any" : filterFlatType) + ", leave blank to clear): ");
        String typeStr = scanner.nextLine().trim();
        if (typeStr.isEmpty()) {
            filterFlatType = null;
        } else {
            try {
                FlatType parsedType = FlatType.fromString(typeStr); // Use the enum's parser
                if (parsedType != null) {
                    filterFlatType = parsedType;
                } else {
                    System.out.println("Invalid flat type entered. Filter not changed.");
                }
            } catch (IllegalArgumentException e) {
                // This catch might not be needed if fromString returns null for invalid input
                System.out.println("Invalid flat type format. Filter not changed.");
            }
        }
        System.out.println(
                "Filters updated. Current filters: Location=" + (filterLocation == null ? "Any" : filterLocation)
                        + ", FlatType=" + (filterFlatType == null ? "Any" : filterFlatType));
    }

    // UI Helper: viewAndSelectProject remains largely the same, but uses canApplyForFlatType
    protected void viewAndSelectProject(List<Project> projectList, String prompt) {
        if (projectList.isEmpty()) {
            System.out.println("No projects match the current criteria.");
            return;
        }

        System.out.println("\n--- " + prompt + " ---");
        System.out.println("Current Filters: Location=" + (filterLocation == null ? "Any" : filterLocation)
                + ", FlatType=" + (filterFlatType == null ? "Any" : filterFlatType));
        System.out.println(
                "--------------------------------------------------------------------------------------------------------------------");
        System.out.printf("%-3s %-15s %-12s %-10s %-10s %-8s %-25s\n", "#", "Project Name", "Neighborhood", "Open",
                "Close", "Visible", "Flat Types (Available/Total, Price, Eligibility)");
        System.out.println(
                "--------------------------------------------------------------------------------------------------------------------");

        for (int i = 0; i < projectList.size(); i++) {
            Project p = projectList.get(i);
            System.out.printf("%-3d %-15s %-12s %-10s %-10s %-8s ",
                    i + 1,
                    p.getProjectName(),
                    p.getNeighborhood(),
                    DateUtils.formatDate(p.getApplicationOpeningDate()),
                    DateUtils.formatDate(p.getApplicationClosingDate()),
                    p.isVisible() ? "On" : "Off");

            // Generate flat details string including eligibility check
            String flatDetails = p.getFlatTypes().entrySet().stream()
                    .sorted(Map.Entry.comparingByKey()) // Sort by FlatType enum order
                    .map(entry -> {
                        FlatType type = entry.getKey();
                        FlatTypeDetails details = entry.getValue();
                        String eligibilityMark = "";
                        // Show eligibility only for Applicant/Officer roles
                        if (currentUser instanceof Applicant) { // Includes HDBOfficer
                            if (!canApplyForFlatType(type)) {
                                eligibilityMark = " (Ineligible)";
                            } else if (details.getAvailableUnits() <= 0) { // Check non-negative available units
                                eligibilityMark = " (No Units)";
                            }
                        }
                        // Format: TypeName: Avail/Total ($Price) EligibilityMark
                        return String.format("%s: %d/%d ($%.0f)%s",
                                type.getDisplayName(), details.getAvailableUnits(), details.getTotalUnits(),
                                details.getSellingPrice(), eligibilityMark);
                    })
                    .collect(Collectors.joining(", "));
            System.out.println(flatDetails);

            // Show Manager/Officer info only if user is not just an Applicant
            if (currentUser.getRole() != UserRole.APPLICANT) {
                 int approvedCount = p.getApprovedOfficerNrics().size(); // Get current count
                System.out.printf("%-3s %-15s %-12s %-10s %-10s %-8s %-25s\n", "", "", "", "", "", "", // Align under previous line
                        "Mgr: " + p.getManagerNric() + ", Officers: " + approvedCount + "/" + p.getMaxOfficerSlots());
            }
             if (i < projectList.size() - 1)
                 System.out.println("---"); // Separator between projects

        }
        System.out.println(
                "--------------------------------------------------------------------------------------------------------------------");
    }

    // UI Helper: selectProjectFromList remains the same
    protected Project selectProjectFromList(List<Project> projectList) {
        if (projectList == null || projectList.isEmpty()) return null; // Handle empty list case

        System.out.print("Enter the number of the project (or 0 to cancel): ");
        int choice;
        try {
            choice = Integer.parseInt(scanner.nextLine());
            if (choice == 0) {
                System.out.println("Operation cancelled.");
                return null;
            }
            // Validate choice is within the list bounds (1 to list size)
            if (choice >= 1 && choice <= projectList.size()) {
                return projectList.get(choice - 1); // Adjust for 0-based index
            } else {
                System.out.println("Invalid choice number.");
                return null;
            }
        } catch (NumberFormatException e) {
            System.out.println("Invalid input. Please enter a number.");
            return null;
        }
    }

    // UI Helper: getIntInput remains the same
    protected int getIntInput(String prompt, int min, int max) {
        int value = -1; // Initialize outside the loop
        while (true) {
            System.out.print(prompt); // Print the prompt
            String input = scanner.nextLine(); // Read the whole line
            try {
                value = Integer.parseInt(input);
                if (value >= min && value <= max) {
                    break; // Valid input, exit loop
                } else {
                    System.out.println("Input must be between " + min + " and " + max + ".");
                }
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a whole number.");
            }
        }
        return value;
    }

    // UI Helper: getDoubleInput remains the same
    protected double getDoubleInput(String prompt, double min, double max) {
        double value = -1.0; // Initialize outside the loop
        while (true) {
            System.out.print(prompt); // Print the prompt
            String input = scanner.nextLine(); // Read the whole line
            try {
                value = Double.parseDouble(input);
                if (value >= min && value <= max) {
                    break; // Valid input, exit loop
                } else {
                    System.out.println("Input must be between " + min + " and " + max + ".");
                }
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a number.");
            }
        }
        return value;
    }

    // UI Helper: getDateInput remains the same
    protected Date getDateInput(String prompt, boolean allowBlank) {
        Date date = null;
        while (true) {
            System.out.print(prompt); // Print the prompt
            String input = scanner.nextLine().trim();
            if (input.isEmpty() && allowBlank) {
                return null; // Return null if blank is allowed and input is empty
            }
            if (input.isEmpty() && !allowBlank) {
                 System.out.println("Input cannot be empty.");
                 continue; // Ask again if blank is not allowed
            }
            // Use the Dparse utility to parse the date
            date = Dparse.parseDate(input);
            if (date != null) {
                break; // Valid date parsed, exit loop
            }
            // Dparse already prints an error message, so just loop again
        }
        return date;
    }
}
```

Controllers/ApplicantActionController.java
```java
package Controllers;

import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Enums.OfficerRegistrationStatus;
import Models.Applicant;
import Models.BTOApplication;
import Models.HDBOfficer;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

// Handles core applicant actions related to applications
public class ApplicantActionController extends BaseController {

    public ApplicantActionController(IUserService userService, IProjectService projectService,
                                     IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                                     User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
    }

    public void viewOpenProjects() {
        System.out.println("\n--- Viewing Available BTO Projects ---");
        // Get projects that are visible, eligible, available, active period, and not expired
        List<Project> availableProjects = getFilteredProjects(true, true, true, true, true);
        viewAndSelectProject(availableProjects, "Available BTO Projects");
    }

    public void applyForProject() {
        // Ensure current user is an Applicant (or subclass like HDBOfficer)
        if (!(currentUser instanceof Applicant)) {
            System.out.println("Error: Only applicants can apply for projects.");
            return;
        }
        Applicant applicant = (Applicant) currentUser;

        // Check existing application status
        if (applicant.hasBooked()) {
            System.out.println("You have already booked a flat for project '" + applicant.getAppliedProjectName()
                    + "'. You cannot apply again.");
            return;
        }
        if (applicant.hasActiveApplication()) {
            System.out.println("You have an active application for project '" + applicant.getAppliedProjectName()
                    + "' with status: " + applicant.getApplicationStatus());
            System.out.println("You must withdraw (and have it approved) or be unsuccessful before applying again.");
            return;
        }
         if (applicant.hasPendingWithdrawal()) {
            System.out.println("You have a withdrawal request pending manager approval for project '"
                    + applicant.getAppliedProjectName() + "'.");
            System.out.println("You cannot apply for a new project until the withdrawal is processed.");
            return;
        }


        System.out.println("\n--- Apply for BTO Project ---");
        // Get projects eligible for application (visible, eligible, available, active period, not expired)
        List<Project> eligibleProjects = getFilteredProjects(true, true, true, true, true);

        if (eligibleProjects.isEmpty()) {
            System.out.println(
                    "There are currently no open projects you are eligible to apply for based on filters, eligibility, and unit availability.");
            return;
        }

        viewAndSelectProject(eligibleProjects, "Select Project to Apply For");
        Project selectedProject = selectProjectFromList(eligibleProjects);
        if (selectedProject == null) return; // User cancelled

        // Special check if the applicant is also an Officer
        if (currentUser instanceof HDBOfficer) {
            HDBOfficer officer = (HDBOfficer) currentUser;
            Project handlingProject = getOfficerHandlingProject(officer); // Use BaseController method
            // Check if officer is trying to apply for the project they are handling
            if (handlingProject != null && selectedProject.equals(handlingProject)) {
                System.out.println("Error: You cannot apply for a project you are currently handling as an Officer.");
                return;
            }
            // Check if officer has a PENDING registration for this project
            boolean hasPendingRegistration = officerRegistrationService.getRegistrationsByOfficer(officer.getNric())
                    .stream()
                    .anyMatch(reg -> reg.getProjectName().equals(selectedProject.getProjectName()) &&
                            reg.getStatus() == OfficerRegistrationStatus.PENDING);
            if (hasPendingRegistration) {
                System.out.println("Error: You cannot apply for a project you have a pending registration for.");
                return;
            }
        }

        // Select flat type
        FlatType selectedFlatType = selectEligibleFlatType(selectedProject);
        if (selectedFlatType == null) return; // User cancelled or no eligible types

        // Create and save application
        BTOApplication newApplication = new BTOApplication(currentUser.getNric(), selectedProject.getProjectName(),
                selectedFlatType, DateUtils.getCurrentDate());
        applicationService.addApplication(newApplication); // Add via service

        // Update applicant's status in memory (will be saved later or during sync)
        applicant.setAppliedProjectName(selectedProject.getProjectName());
        applicant.setApplicationStatus(ApplicationStatus.PENDING);
        applicant.setBookedFlatType(null); // Reset booked type

        System.out.println("Application submitted successfully for project '" + selectedProject.getProjectName() + "' ("
                + selectedFlatType.getDisplayName() + "). Status: PENDING.");

        // Save immediately after adding
        applicationService.saveApplications(applicationService.getAllApplications());
        // No need to save users here, sync handles it or final save does.
    }

    private FlatType selectEligibleFlatType(Project project) {
        // Filter flat types in the project: user must be eligible AND units must be available
        List<FlatType> eligibleAndAvailableTypes = project.getFlatTypes().entrySet().stream()
                .filter(entry -> canApplyForFlatType(entry.getKey()) && entry.getValue().getAvailableUnits() > 0)
                .map(Map.Entry::getKey)
                .sorted() // Sort by enum order
                .collect(Collectors.toList());

        if (eligibleAndAvailableTypes.isEmpty()) {
            System.out.println("There are no flat types available in this project that you are eligible for and have units remaining.");
            return null;
        }

        // If only one option, select it automatically
        if (eligibleAndAvailableTypes.size() == 1) {
            FlatType onlyOption = eligibleAndAvailableTypes.get(0);
            System.out.println("You will be applying for the only eligible and available type: "
                    + onlyOption.getDisplayName() + ".");
            return onlyOption;
        } else {
            // Present choices
            System.out.println("Select the flat type you want to apply for:");
            for (int i = 0; i < eligibleAndAvailableTypes.size(); i++) {
                System.out.println((i + 1) + ". " + eligibleAndAvailableTypes.get(i).getDisplayName());
            }
            // Get user choice using utility method
            int typeChoice = getIntInput("Enter choice (or 0 to cancel): ", 0, eligibleAndAvailableTypes.size());

            if (typeChoice == 0) {
                System.out.println("Application cancelled.");
                return null;
            }
            // Return the selected type (adjusting for 1-based index)
            return eligibleAndAvailableTypes.get(typeChoice - 1);
        }
    }

    public void viewMyApplication() {
        if (!(currentUser instanceof Applicant)) return;
        Applicant applicant = (Applicant) currentUser;
        // Sync might be good before viewing, but BTOApp handles sync before menu now.

        String projectName = applicant.getAppliedProjectName();
        ApplicationStatus status = applicant.getApplicationStatus();

        if (projectName == null || status == null) {
            System.out.println("You do not have any current or past BTO application records synced to your profile.");
             // Check the application service directly just in case sync missed something
             List<BTOApplication> historicalApps = applicationService.getApplicationsByApplicant(applicant.getNric());
             if (!historicalApps.isEmpty()) {
                 System.out.println("However, historical application records exist. The latest was:");
                 // Find the latest application by date
                 BTOApplication latestApp = historicalApps.stream()
                                                .max(Comparator.comparing(BTOApplication::getApplicationDate))
                                                .orElse(null);
                 if (latestApp != null) {
                      Project project = projectService.findProjectByName(latestApp.getProjectName());
                      System.out.println("Project Name: " + latestApp.getProjectName());
                      System.out.println("Neighborhood: " + (project != null ? project.getNeighborhood() : "(Project details not found)"));
                      System.out.println("Flat Type Applied For: " + (latestApp.getFlatTypeApplied() != null ? latestApp.getFlatTypeApplied().getDisplayName() : "N/A"));
                      System.out.println("Application Status: " + latestApp.getStatus());
                      System.out.println("Application Date: " + DateUtils.formatDate(latestApp.getApplicationDate()));
                 }
             }
            return;
        }

        // Find the application record using the service
        BTOApplication application = applicationService.findApplicationByApplicantAndProject(applicant.getNric(), projectName);
        if (application == null) {
            // This case indicates an inconsistency between the Applicant object's state and the application records
            System.out.println(
                    "Error: Your profile indicates an application for '" + projectName + "', but the detailed record could not be found. Please contact support.");
            return;
        }

        // Find project details using the service
        Project project = projectService.findProjectByName(projectName);

        System.out.println("\n--- Your BTO Application ---");
        System.out.println("Project Name: " + projectName);
        System.out.println("Neighborhood: " + (project != null ? project.getNeighborhood() : "(Project details not found)"));
        System.out.println("Flat Type Applied For: " + (application.getFlatTypeApplied() != null ? application.getFlatTypeApplied().getDisplayName() : "N/A"));
        System.out.println("Application Status: " + status); // Display status from Applicant object (should match application object after sync)
        // Display booked flat type if applicable
        if (status == ApplicationStatus.BOOKED && applicant.getBookedFlatType() != null) {
            System.out.println("Booked Flat Type: " + applicant.getBookedFlatType().getDisplayName());
        }
        System.out.println("Application Date: " + DateUtils.formatDate(application.getApplicationDate()));
    }

    public void requestWithdrawal() {
         if (!(currentUser instanceof Applicant)) return;
         Applicant applicant = (Applicant) currentUser;
         // Sync data before processing withdrawal request
         // DataService.synchronizeData(users, projects, applications, officerRegistrations); // Sync done in BTOApp loop

        String currentProject = applicant.getAppliedProjectName();
        ApplicationStatus currentStatus = applicant.getApplicationStatus();

        if (currentProject == null || currentStatus == null) {
            System.out.println("You do not have an application to withdraw.");
            return;
        }

        // Check if the application is eligible for withdrawal request
        if (currentStatus != ApplicationStatus.PENDING &&
                currentStatus != ApplicationStatus.SUCCESSFUL &&
                currentStatus != ApplicationStatus.BOOKED) {
            System.out.println("Your application status (" + currentStatus + ") is not eligible for withdrawal request.");
            System.out.println("You can only request withdrawal if your status is PENDING, SUCCESSFUL, or BOOKED.");
            return;
        }

        // Find the corresponding BTOApplication object
        BTOApplication application = applicationService.findApplicationByApplicantAndProject(applicant.getNric(), currentProject);
        if (application == null) {
            System.out.println(
                    "Error: Could not find the application record for project '" + currentProject + "' to request withdrawal. Please contact support.");
            return;
        }
        // Double-check the status in the application record matches the applicant profile
         if (application.getStatus() != currentStatus) {
             System.out.println("Error: Application status mismatch between profile (" + currentStatus + ") and record (" + application.getStatus() + "). Please re-login or contact support.");
             return;
         }

        System.out.println("\n--- Request Application Withdrawal ---");
        System.out.println("Project: " + application.getProjectName());
        System.out.println("Current Status: " + currentStatus);
        System.out.print(
                "Are you sure you want to request withdrawal for this application? Manager approval is required. (yes/no): ");
        String confirm = scanner.nextLine().trim().toLowerCase();

        if (confirm.equals("yes")) {
            // Update the status in the BTOApplication object
            application.setStatus(ApplicationStatus.PENDING_WITHDRAWAL); // This now also sets statusBeforeWithdrawal internally

            // Update the status in the Applicant object
            applicant.setApplicationStatus(ApplicationStatus.PENDING_WITHDRAWAL);

            System.out.println("Withdrawal request submitted successfully.");
            System.out.println("Your application status is now PENDING_WITHDRAWAL and requires Manager approval.");

            // Save the updated application state
            applicationService.saveApplications(applicationService.getAllApplications());
             // Save user state? Not strictly necessary if relying on sync, but safer.
             // userService.saveUsers(userService.getAllUsers()); // Requires userService injection

        } else {
            System.out.println("Withdrawal request cancelled.");
        }
    }
}
```

Controllers/EnquiryApplicantController.java
```java
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Models.Enquiry;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

// Handles applicant actions related to enquiries
public class EnquiryApplicantController extends BaseController {

    private final IEnquiryService enquiryService; // Specific service needed

    public EnquiryApplicantController(IUserService userService, IProjectService projectService,
                                      IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                                      IEnquiryService enquiryService, // Inject enquiry service
                                      User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
        this.enquiryService = enquiryService;
    }

    public void submitEnquiry() {
        System.out.println("\n--- Submit Enquiry ---");
        // Get projects that are visible (don't need other filters for enquiry)
        List<Project> viewableProjects = getFilteredProjects(true, false, false, false, false);
        Project selectedProject = null;
        String projectNameInput;

        // Allow selecting from list or typing name
        if (!viewableProjects.isEmpty()) {
            viewAndSelectProject(viewableProjects, "Select Project to Enquire About (Optional)");
            selectedProject = selectProjectFromList(viewableProjects);
        }

        if (selectedProject != null) {
            projectNameInput = selectedProject.getProjectName();
            System.out.println("Enquiring about project: " + projectNameInput);
        } else {
            // Prompt for name if not selected or list was empty
            if (!viewableProjects.isEmpty()) {
                System.out.println("No project selected from list, or you chose to cancel selection.");
            }
            System.out.print("Enter the exact Project Name you want to enquire about (leave blank to cancel): ");
            projectNameInput = scanner.nextLine().trim();

            if (projectNameInput.isEmpty()) {
                System.out.println("Enquiry cancelled.");
                return;
            }
            // Check if the typed project name exists (optional warning)
            if (projectService.findProjectByName(projectNameInput) == null) {
                System.out.println("Warning: Project '" + projectNameInput
                        + "' not found in current listings. Ensure the name is correct before submitting.");
                // Ask for confirmation? For now, allow submitting anyway.
            }
        }

        // Get enquiry text
        System.out.print("Enter your enquiry text (cannot be empty): ");
        String text = scanner.nextLine().trim();

        if (!text.isEmpty()) {
            // Create Enquiry object - ID is generated internally
            Enquiry newEnquiry = new Enquiry(currentUser.getNric(), projectNameInput, text, DateUtils.getCurrentDate());
            enquiryService.addEnquiry(newEnquiry); // Add using service
            System.out.println("Enquiry submitted successfully (ID: " + newEnquiry.getEnquiryId() + ").");
            enquiryService.saveEnquiries(enquiryService.getAllEnquiries()); // Save immediately
        } else {
            System.out.println("Enquiry text cannot be empty. Enquiry not submitted.");
        }
    }

    public void viewMyEnquiries() {
        System.out.println("\n--- Your Enquiries ---");
        // Get enquiries using the service
        List<Enquiry> myEnquiries = enquiryService.getEnquiriesByApplicant(currentUser.getNric())
                .stream()
                // Sort by date descending (most recent first)
                .sorted(Comparator.comparing(Enquiry::getEnquiryDate).reversed())
                .collect(Collectors.toList());

        if (myEnquiries.isEmpty()) {
            System.out.println("You have not submitted any enquiries.");
            return;
        }

        // Display enquiries
        for (int i = 0; i < myEnquiries.size(); i++) {
            Enquiry e = myEnquiries.get(i);
            System.out.printf("%d. ID: %s | Project: %s | Date: %s\n",
                    i + 1, e.getEnquiryId(), e.getProjectName(), DateUtils.formatDate(e.getEnquiryDate()));
            System.out.println("   Enquiry: " + e.getEnquiryText());
            if (e.isReplied()) {
                System.out.printf("   Reply (by %s on %s): %s\n",
                        e.getRepliedByNric() != null ? e.getRepliedByNric() : "N/A", // Use N/A for null replier NRIC
                        e.getReplyDate() != null ? DateUtils.formatDate(e.getReplyDate()) : "N/A", // Use N/A for null reply date
                        e.getReplyText());
            } else {
                System.out.println("   Reply: (Pending)");
            }
            System.out.println("----------------------------------------"); // Separator
        }
    }

    public void editMyEnquiry() {
        System.out.println("\n--- Edit Enquiry ---");
        // Get editable enquiries (own, not replied) using the service
        List<Enquiry> editableEnquiries = enquiryService.getEnquiriesByApplicant(currentUser.getNric())
                .stream()
                .filter(e -> !e.isReplied())
                .sorted(Comparator.comparing(Enquiry::getEnquiryDate).reversed())
                .collect(Collectors.toList());

        if (editableEnquiries.isEmpty()) {
            System.out.println("You have no enquiries that can be edited (must not be replied to yet).");
            return;
        }

        // Display editable enquiries for selection
        System.out.println("Select enquiry to edit:");
        for (int i = 0; i < editableEnquiries.size(); i++) {
            Enquiry e = editableEnquiries.get(i);
            // Truncate long text for display if needed
            String truncatedText = e.getEnquiryText().length() > 50 ? e.getEnquiryText().substring(0, 47) + "..." : e.getEnquiryText();
            System.out.printf("%d. ID: %s | Project: %s | Text: %s\n",
                    i + 1, e.getEnquiryId(), e.getProjectName(), truncatedText);
        }

        int choice = getIntInput("Enter choice (or 0 to cancel): ", 0, editableEnquiries.size());

        if (choice == 0) {
            System.out.println("Operation cancelled.");
            return;
        }

        Enquiry enquiryToEdit = editableEnquiries.get(choice - 1);
        System.out.println("Current text: " + enquiryToEdit.getEnquiryText());
        System.out.print("Enter new enquiry text (cannot be empty): ");
        String newText = scanner.nextLine().trim();

        // Attempt to set the new text using the Enquiry object's method
        if (enquiryToEdit.setEnquiryText(newText)) {
            System.out.println("Enquiry updated successfully.");
            enquiryService.saveEnquiries(enquiryService.getAllEnquiries()); // Save changes
        } else {
            // Error message is printed within setEnquiryText if failed
            System.out.println("Enquiry not updated.");
        }
    }

    public void deleteMyEnquiry() {
        System.out.println("\n--- Delete Enquiry ---");
        // Get deletable enquiries (own, not replied)
        List<Enquiry> deletableEnquiries = enquiryService.getEnquiriesByApplicant(currentUser.getNric())
                .stream()
                .filter(e -> !e.isReplied())
                .sorted(Comparator.comparing(Enquiry::getEnquiryDate).reversed())
                .collect(Collectors.toList());

        if (deletableEnquiries.isEmpty()) {
            System.out.println("You have no enquiries that can be deleted (must not be replied to yet).");
            return;
        }

        // Display deletable enquiries
        System.out.println("Select enquiry to delete:");
        for (int i = 0; i < deletableEnquiries.size(); i++) {
            Enquiry e = deletableEnquiries.get(i);
            String truncatedText = e.getEnquiryText().length() > 50 ? e.getEnquiryText().substring(0, 47) + "..." : e.getEnquiryText();
            System.out.printf("%d. ID: %s | Project: %s | Text: %s\n",
                    i + 1, e.getEnquiryId(), e.getProjectName(), truncatedText);
        }

        int choice = getIntInput("Enter choice (or 0 to cancel): ", 0, deletableEnquiries.size());

        if (choice == 0) {
            System.out.println("Operation cancelled.");
            return;
        }

        Enquiry enquiryToDelete = deletableEnquiries.get(choice - 1);
        System.out.print(
                "Are you sure you want to permanently delete enquiry " + enquiryToDelete.getEnquiryId() + "? (yes/no): ");
        String confirm = scanner.nextLine().trim().toLowerCase();

        if (confirm.equals("yes")) {
            // Remove using the service
            if (enquiryService.removeEnquiry(enquiryToDelete.getEnquiryId())) {
                System.out.println("Enquiry deleted successfully.");
                enquiryService.saveEnquiries(enquiryService.getAllEnquiries()); // Save changes
            } else {
                // This should ideally not happen if the enquiry was in the list
                System.err.println("Error: Failed to remove enquiry from service layer.");
            }
        } else {
            System.out.println("Deletion cancelled.");
        }
    }
}
```

Controllers/ApplicantController.java
```java
package Controllers;

import java.util.Scanner;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;

// Main controller for Applicant role, delegates actions to specific controllers
public class ApplicantController extends BaseController {

    // Hold instances of the specialized controllers
    private final ApplicantActionController actionController;
    private final EnquiryApplicantController enquiryController;

    public ApplicantController(IUserService userService, IProjectService projectService,
                               IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                               IEnquiryService enquiryService, // Needs enquiry service for its child controller
                               User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);

        // Instantiate the specialized controllers, passing necessary dependencies
        this.actionController = new ApplicantActionController(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
        this.enquiryController = new EnquiryApplicantController(userService, projectService, applicationService, officerRegistrationService, enquiryService, currentUser, scanner, authController);

        // Assign filters from BaseController to sub-controllers if needed, or manage filters centrally.
        // Currently, filters are managed in BaseController and used by getFilteredProjects.
        // this.actionController.filterLocation = this.filterLocation; // Example if needed
        // this.actionController.filterFlatType = this.filterFlatType; // Example if needed
    }

    // --- Delegate methods to specialized controllers ---

    public void viewOpenProjects() {
        actionController.viewOpenProjects();
    }

    public void applyForProject() {
        actionController.applyForProject();
    }

    public void viewMyApplication() {
        actionController.viewMyApplication();
    }

    public void requestWithdrawal() {
        actionController.requestWithdrawal();
    }

    public void submitEnquiry() {
        enquiryController.submitEnquiry();
    }

    public void viewMyEnquiries() {
        enquiryController.viewMyEnquiries();
    }

    public void editMyEnquiry() {
        enquiryController.editMyEnquiry();
    }

    public void deleteMyEnquiry() {
        enquiryController.deleteMyEnquiry();
    }

    // applyFilters is handled by BaseController and accessed via ApplicantView
}
```

Controllers/OfficerActionController.java
```java
package Controllers;

import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;
import java.util.Collections;

import Enums.OfficerRegistrationStatus;
import Models.BTOApplication;
import Models.HDBOfficer;
import Models.OfficerRegistration;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;


// Handles officer-specific actions like registration and status viewing
public class OfficerActionController extends BaseController {

    public OfficerActionController(IUserService userService, IProjectService projectService,
                                   IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                                   User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
    }

    public void registerForProject() {
        if (!(currentUser instanceof HDBOfficer)) {
             System.out.println("Error: Only HDB Officers can register to handle projects.");
             return;
        }
        HDBOfficer officer = (HDBOfficer) currentUser;
        Date currentDate = DateUtils.getCurrentDate();
        // Sync data is handled in BTOApp main loop

        // Check Officer's applicant status first
        if (officer.hasActiveApplication() || officer.hasBooked()) { // Check for booked status as well
            System.out.println("Error: Cannot register to handle a project while you have an active or booked BTO application ("
                    + officer.getAppliedProjectName() + ", Status: " + officer.getApplicationStatus() + ").");
            return;
        }
         if (officer.hasPendingWithdrawal()) {
            System.out.println("Error: Cannot register to handle a project while you have a pending withdrawal request for application '" + officer.getAppliedProjectName() + "'.");
            return;
        }


        System.out.println("\n--- Register to Handle Project ---");

        // Find project currently handled by this officer (if any)
        Project currentlyHandlingProject = getOfficerHandlingProject(officer); // Use BaseController method

        // Find projects this officer has PENDING registrations for
        List<Project> pendingRegistrationProjects = officerRegistrationService.getRegistrationsByOfficer(officer.getNric())
                .stream()
                .filter(reg -> reg.getStatus() == OfficerRegistrationStatus.PENDING)
                .map(reg -> projectService.findProjectByName(reg.getProjectName()))
                .filter(p -> p != null) // Filter out projects that might not exist anymore
                .collect(Collectors.toList());

        // Find projects available for registration
        List<Project> availableProjects = projectService.getAllProjects().stream()
                // 1. Project must have remaining slots
                .filter(p -> p.getRemainingOfficerSlots() > 0)
                // 2. Project's application period must not be expired
                .filter(p -> !p.isApplicationPeriodExpired(currentDate))
                // 3. Officer must not already have *any* registration (Pending, Approved, Rejected) for this project
                .filter(p -> officerRegistrationService.getRegistrationsByOfficer(officer.getNric())
                                .stream()
                                .noneMatch(reg -> reg.getProjectName().equals(p.getProjectName())))
                // 4. Project dates must not overlap with the currently handled project (if any)
                .filter(p -> currentlyHandlingProject == null || !checkDateOverlap(p, currentlyHandlingProject))
                // 5. Project dates must not overlap with any project the officer has a PENDING registration for
                .filter(p -> pendingRegistrationProjects.stream().noneMatch(pendingProject -> checkDateOverlap(p, pendingProject)))
                // 6. Officer must not have *any* past or present BTO application for this project
                .filter(p -> applicationService.getApplicationsByApplicant(officer.getNric())
                                .stream()
                                .noneMatch(app -> app.getProjectName().equals(p.getProjectName())))
                .sorted(Comparator.comparing(Project::getProjectName)) // Sort alphabetically
                .collect(Collectors.toList());

        if (availableProjects.isEmpty()) {
            System.out.println("No projects currently available for you to register for based on eligibility criteria:");
            System.out.println("- Project must have open officer slots and not be expired.");
            System.out.println("- You must not already have any registration (Pending/Approved/Rejected) for the project.");
            System.out.println("- You cannot have an active/booked BTO application or a pending withdrawal request.");
            System.out.println("- Project dates cannot overlap with a project you are already handling.");
            System.out.println("- Project dates cannot overlap with a project you have a PENDING registration for.");
            System.out.println("- You cannot register for a project you have previously applied for (any status).");
            return;
        }

        viewAndSelectProject(availableProjects, "Select Project to Register For");
        Project selectedProject = selectProjectFromList(availableProjects);

        if (selectedProject != null) {
            // Create registration - ID is generated internally based on NRIC and Project Name
            OfficerRegistration newRegistration = new OfficerRegistration(officer.getNric(),
                    selectedProject.getProjectName(), currentDate);
            officerRegistrationService.addRegistration(newRegistration); // Add via service
            System.out.println("Registration request submitted for project '" + selectedProject.getProjectName()
                    + "'. Status: PENDING approval by Manager.");
            // Save immediately
            officerRegistrationService.saveOfficerRegistrations(officerRegistrationService.getAllRegistrations());
        }
    }

    public void viewRegistrationStatus() {
        if (!(currentUser instanceof HDBOfficer)) return;
        HDBOfficer officer = (HDBOfficer) currentUser;
        System.out.println("\n--- Your HDB Officer Registration Status ---");

        // Check currently handled project first
        Project handlingProject = getOfficerHandlingProject(officer); // Use BaseController method
        if (handlingProject != null) {
            System.out.println("You are currently APPROVED and HANDLING project: " + handlingProject.getProjectName());
            System.out.println("  (Application Period: " + DateUtils.formatDate(handlingProject.getApplicationOpeningDate()) + " to " + DateUtils.formatDate(handlingProject.getApplicationClosingDate()) + ")");
            System.out.println("----------------------------------------");
        }

        // Get all other registrations (excluding the currently active 'approved' one if found)
        List<OfficerRegistration> myOtherRegistrations = officerRegistrationService.getRegistrationsByOfficer(officer.getNric())
                .stream()
                // Filter out the one identified as currently handling (if any)
                .filter(reg -> handlingProject == null || !reg.getProjectName().equals(handlingProject.getProjectName()))
                .sorted(Comparator.comparing(OfficerRegistration::getRegistrationDate).reversed()) // Sort by date descending
                .collect(Collectors.toList());

        if (myOtherRegistrations.isEmpty() && handlingProject == null) {
            System.out.println("You have no past or pending registration requests.");
        } else if (!myOtherRegistrations.isEmpty()) {
            System.out.println("Other Registration History/Requests:");
            for (OfficerRegistration reg : myOtherRegistrations) {
                System.out.printf("- Project: %-15s | Status: %-10s | Date: %s\n",
                        reg.getProjectName(), reg.getStatus(), DateUtils.formatDate(reg.getRegistrationDate()));
            }
        } else {
             // This case means handlingProject != null and myOtherRegistrations is empty.
             // The handling project info was already printed. No need to print anything else.
        }
    }

    public void viewHandlingProjectDetails() {
         if (!(currentUser instanceof HDBOfficer)) return;
         HDBOfficer officer = (HDBOfficer) currentUser;

        // Find the project the officer is currently handling
        Project project = getOfficerHandlingProject(officer); // Use BaseController method

        if (project == null) {
            System.out.println("You are not currently handling any active project. Register for one first or check registration status.");
            return;
        }

        System.out.println("\n--- Details for Handling Project: " + project.getProjectName() + " ---");
        // Use the viewAndSelectProject helper, passing a list containing only the handling project
        // This reuses the detailed project display format.
        viewAndSelectProject(Collections.singletonList(project), "Project Details");
    }
}
```

Controllers/EnquiryOfficerController.java
```java
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Models.Enquiry;
import Models.HDBOfficer;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

// Handles Officer actions related to enquiries for their handled project
public class EnquiryOfficerController extends BaseController {

    private final IEnquiryService enquiryService;

    public EnquiryOfficerController(IUserService userService, IProjectService projectService,
                                    IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                                    IEnquiryService enquiryService, // Inject enquiry service
                                    User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
        this.enquiryService = enquiryService;
    }

    public void viewAndReplyToEnquiries() {
        if (!(currentUser instanceof HDBOfficer)) return;
        HDBOfficer officer = (HDBOfficer) currentUser;

        // Find the project the officer is currently handling
        Project handlingProject = getOfficerHandlingProject(officer); // Use BaseController method

        if (handlingProject == null) {
            System.out.println("You need to be handling an active project to view and reply to its enquiries.");
            return;
        }
        String handlingProjectName = handlingProject.getProjectName();

        System.out.println("\n--- Enquiries for Project: " + handlingProjectName + " ---");
        // Get enquiries for this specific project using the service
        List<Enquiry> projectEnquiries = enquiryService.getEnquiriesByProject(handlingProjectName)
                .stream()
                .sorted(Comparator.comparing(Enquiry::getEnquiryDate).reversed()) // Sort by date desc
                .collect(Collectors.toList());

        if (projectEnquiries.isEmpty()) {
            System.out.println("No enquiries found for this project.");
            return;
        }

        // Separate unreplied and replied
        List<Enquiry> unrepliedEnquiries = projectEnquiries.stream()
                .filter(e -> !e.isReplied())
                .collect(Collectors.toList());
        List<Enquiry> repliedEnquiries = projectEnquiries.stream()
                .filter(Enquiry::isReplied)
                .collect(Collectors.toList());

        // --- Handle Unreplied Enquiries ---
        System.out.println("--- Unreplied Enquiries ---");
        if (unrepliedEnquiries.isEmpty()) {
            System.out.println("(None)");
        } else {
            // Display unreplied enquiries for selection
            for (int i = 0; i < unrepliedEnquiries.size(); i++) {
                Enquiry e = unrepliedEnquiries.get(i);
                System.out.printf("%d. ID: %s | Applicant: %s | Date: %s\n",
                        i + 1, e.getEnquiryId(), e.getApplicantNric(), DateUtils.formatDate(e.getEnquiryDate()));
                System.out.println("   Enquiry: " + e.getEnquiryText());
                System.out.println("---"); // Separator
            }
            // Prompt for reply
            int choice = getIntInput("Enter the number of the enquiry to reply to (or 0 to skip): ", 0, unrepliedEnquiries.size());

            if (choice >= 1) {
                Enquiry enquiryToReply = unrepliedEnquiries.get(choice - 1);
                System.out.print("Enter your reply: ");
                String replyText = scanner.nextLine().trim();
                // Set reply using Enquiry object's method
                if (enquiryToReply.setReply(replyText, currentUser.getNric(), DateUtils.getCurrentDate())) {
                    System.out.println("Reply submitted successfully.");
                    enquiryService.saveEnquiries(enquiryService.getAllEnquiries()); // Save changes
                } else {
                    // Error message printed within setReply
                    System.out.println("Reply not submitted.");
                }
            } else if (choice != 0) {
                System.out.println("Invalid choice.");
            }
            // If choice is 0, do nothing (skip)
        }

        // --- Display Replied Enquiries ---
        System.out.println("\n--- Replied Enquiries ---");
        if (repliedEnquiries.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (Enquiry e : repliedEnquiries) {
                System.out.printf("ID: %s | Applicant: %s | Enquiry Date: %s\n",
                        e.getEnquiryId(), e.getApplicantNric(), DateUtils.formatDate(e.getEnquiryDate()));
                System.out.println("   Enquiry: " + e.getEnquiryText());
                System.out.printf("   Reply (by %s on %s): %s\n",
                        e.getRepliedByNric() != null ? e.getRepliedByNric() : "N/A",
                        e.getReplyDate() != null ? DateUtils.formatDate(e.getReplyDate()) : "N/A",
                        e.getReplyText());
                System.out.println("--------------------"); // Separator
            }
        }
    }
}
```

Controllers/BookingOfficerController.java
```java
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Models.Applicant;
import Models.BTOApplication;
import Models.FlatTypeDetails;
import Models.HDBOfficer;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

// Handles Officer actions related to managing flat bookings
public class BookingOfficerController extends BaseController {

    public BookingOfficerController(IUserService userService, IProjectService projectService,
                                   IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                                   User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
    }

    public void manageFlatBooking() {
        if (!(currentUser instanceof HDBOfficer)) return;
        HDBOfficer officer = (HDBOfficer) currentUser;

        // Find the project the officer is currently handling
        Project project = getOfficerHandlingProject(officer); // Use BaseController method

        if (project == null) {
            System.out.println("You need to be handling an active project to manage flat bookings.");
            return;
        }
        String handlingProjectName = project.getProjectName();

        System.out.println("\n--- Flat Booking Management for Project: " + handlingProjectName + " ---");

        // Get applications for this project with SUCCESSFUL status using the service
        List<BTOApplication> successfulApps = applicationService.getApplicationsByProject(handlingProjectName)
                .stream()
                .filter(app -> app.getStatus() == ApplicationStatus.SUCCESSFUL)
                .sorted(Comparator.comparing(BTOApplication::getApplicationDate)) // Sort by application date (FIFO)
                .collect(Collectors.toList());

        if (successfulApps.isEmpty()) {
            System.out.println("No applicants with status SUCCESSFUL found for this project (ready for booking).");
            return;
        }

        // Display successful applicants for selection
        System.out.println("Applicants with SUCCESSFUL status (ready for booking):");
        for (int i = 0; i < successfulApps.size(); i++) {
            BTOApplication app = successfulApps.get(i);
            User applicantUser = userService.findUserByNric(app.getApplicantNric()); // Find user via service
            System.out.printf("%d. NRIC: %s | Name: %-15s | Applied Type: %-8s | App Date: %s\n",
                    i + 1,
                    app.getApplicantNric(),
                    applicantUser != null ? applicantUser.getName() : "N/A",
                    app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A",
                    DateUtils.formatDate(app.getApplicationDate()));
        }

        // Prompt for selection
        int choice = getIntInput("Enter the number of the applicant to process booking for (or 0 to cancel): ", 0, successfulApps.size());

        if (choice == 0) {
            System.out.println("Operation cancelled.");
            return;
        }

        BTOApplication applicationToBook = successfulApps.get(choice - 1);
        User applicantUser = userService.findUserByNric(applicationToBook.getApplicantNric());

        // Validate applicant data
        if (!(applicantUser instanceof Applicant)) {
            System.out.println(
                    "Error: Applicant data not found or invalid for NRIC " + applicationToBook.getApplicantNric() + ". Cannot process booking.");
            return;
        }
        Applicant applicant = (Applicant) applicantUser;

        // --- Pre-booking Checks ---
        // Re-check application status (in case it changed since listing)
        // Refresh application object from service? Might be overkill if sync is frequent. Check current object's status.
        if (applicationToBook.getStatus() != ApplicationStatus.SUCCESSFUL) {
            System.out.println("Error: Applicant status is no longer SUCCESSFUL (Current: "
                    + applicationToBook.getStatus() + "). Cannot proceed with booking.");
            return;
        }
        // Check applicant profile status (redundant if sync works, but safe)
        if (applicant.hasBooked()) {
            System.out.println("Error: Applicant " + applicant.getNric()
                    + " has already booked a flat according to their profile. Booking cancelled.");
            return;
        }
        // Check flat type applied for
        FlatType appliedFlatType = applicationToBook.getFlatTypeApplied();
        if (appliedFlatType == null) {
            System.out.println("Error: Application record does not have a valid flat type specified. Cannot book.");
            return;
        }
        // Check unit availability using the *mutable* details from the Project object
        // Need to get the project object again as the one from getOfficerHandlingProject might be stale if units changed.
        Project currentProjectState = projectService.findProjectByName(handlingProjectName);
        if (currentProjectState == null) {
             System.out.println("Error: Could not retrieve current project state. Booking cancelled.");
             return;
        }
        FlatTypeDetails details = currentProjectState.getMutableFlatTypeDetails(appliedFlatType);
        if (details == null) {
             System.out.println("Error: Flat type details not found for " + appliedFlatType.getDisplayName() + " in project " + currentProjectState.getProjectName() +". Cannot book.");
             return;
        }
        if (details.getAvailableUnits() <= 0) {
            System.out.println("Error: No available units for the applied flat type ("
                    + appliedFlatType.getDisplayName() + ") at this moment. Booking cannot proceed.");
            // Consider suggesting checking back later or informing manager?
            return;
        }

        // --- Confirmation ---
        System.out.println("\n--- Confirm Booking ---");
        System.out.println("Applicant: " + applicant.getName() + " (" + applicant.getNric() + ")");
        System.out.println("Project: " + applicationToBook.getProjectName());
        System.out.println("Flat Type: " + appliedFlatType.getDisplayName());
        System.out.println("Available Units Before Booking: " + details.getAvailableUnits());
        System.out.printf("Selling Price: $%.2f\n", details.getSellingPrice());

        System.out.print("\nConfirm booking for this applicant? (yes/no): ");
        String confirm = scanner.nextLine().trim().toLowerCase();

        if (confirm.equals("yes")) {
            // --- Process Booking ---
            // 1. Decrement available units in the Project's FlatTypeDetails
            if (!details.decrementAvailableUnits()) {
                // This could happen in a concurrent scenario, or if the check above was somehow bypassed.
                System.out.println(
                        "Error: Failed to decrement unit count (Units might have just become zero). Booking cancelled.");
                return;
            }

            // 2. Update BTOApplication status
            applicationToBook.setStatus(ApplicationStatus.BOOKED);

            // 3. Update Applicant status and booked flat type
            applicant.setApplicationStatus(ApplicationStatus.BOOKED);
            applicant.setBookedFlatType(appliedFlatType);

            // --- Post-booking Actions ---
            System.out.println("Booking confirmed successfully!");
            System.out.println("Applicant status updated to BOOKED.");
            System.out.println("Remaining units for " + appliedFlatType.getDisplayName() + ": " + details.getAvailableUnits());

            // Generate receipt (uses current user NRIC as Officer NRIC)
            generateBookingReceipt(applicant, applicationToBook, currentProjectState); // Pass the up-to-date project state

            // Save updated data
            applicationService.saveApplications(applicationService.getAllApplications());
            projectService.saveProjects(projectService.getAllProjects()); // Save project because unit count changed
            // userService.saveUsers(userService.getAllUsers()); // Save user state change

        } else {
            System.out.println("Booking cancelled.");
        }
    }

    // generateBookingReceipt remains a private helper method within this controller
    private void generateBookingReceipt(Applicant applicant, BTOApplication application, Project project) {
        System.out.println("\n================ BTO Booking Receipt ================");
        System.out.println(" Receipt Generated: " + DateUtils.formatDate(DateUtils.getCurrentDate()) + " by Officer " + currentUser.getNric());
        System.out.println("-----------------------------------------------------");
        System.out.println(" Applicant Details:");
        System.out.println("   Name:          " + applicant.getName());
        System.out.println("   NRIC:          " + applicant.getNric());
        System.out.println("   Age:           " + applicant.getAge());
        System.out.println("   Marital Status:" + applicant.getMaritalStatus());
        System.out.println("-----------------------------------------------------");
        System.out.println(" Booking Details:");
        System.out.println("   Project Name:  " + project.getProjectName());
        System.out.println("   Neighborhood:  " + project.getNeighborhood());
        System.out.println("   Booked Flat:   " + (application.getFlatTypeApplied() != null ? application.getFlatTypeApplied().getDisplayName() : "N/A"));
        // Get price from the project details passed in
        FlatTypeDetails details = project.getFlatTypeDetails(application.getFlatTypeApplied());
        if (details != null) {
            System.out.printf("   Selling Price: $%.2f\n", details.getSellingPrice());
        } else {
            System.out.println("   Selling Price: N/A"); // Should not happen if booking succeeded
        }
        System.out.println("   Booking Status:" + application.getStatus()); // Should be BOOKED
        System.out.println("   Application ID:" + application.getApplicationId());
        System.out.println("-----------------------------------------------------");
        System.out.println(" Thank you for choosing HDB!");
        System.out.println("=====================================================");
    }
}
```

Controllers/OfficerController.java
```java
package Controllers;

import java.util.Scanner;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;

// Main controller for Officer role, delegates actions to specific controllers
// Inherits from ApplicantController to provide Applicant functionalities
public class OfficerController extends ApplicantController {

    // Hold instances of the specialized Officer controllers
    private final OfficerActionController officerActionController;
    private final EnquiryOfficerController enquiryOfficerController;
    private final BookingOfficerController bookingOfficerController;

    public OfficerController(IUserService userService, IProjectService projectService,
                             IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                             IEnquiryService enquiryService, // Enquiry service needed for both Applicant and Officer parts
                             User currentUser, Scanner scanner, AuthController authController) {
        // Call ApplicantController constructor, which in turn calls BaseController constructor
        super(userService, projectService, applicationService, officerRegistrationService, enquiryService, currentUser, scanner, authController);

        // Instantiate Officer-specific controllers
        this.officerActionController = new OfficerActionController(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
        this.enquiryOfficerController = new EnquiryOfficerController(userService, projectService, applicationService, officerRegistrationService, enquiryService, currentUser, scanner, authController);
        this.bookingOfficerController = new BookingOfficerController(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
    }

    // --- Delegate Officer-specific methods ---

    public void registerForProject() {
        officerActionController.registerForProject();
    }

    public void viewRegistrationStatus() {
        officerActionController.viewRegistrationStatus();
    }

    public void viewHandlingProjectDetails() {
        officerActionController.viewHandlingProjectDetails();
    }

    public void viewAndReplyToEnquiries() { // Note: This is the Officer version
        enquiryOfficerController.viewAndReplyToEnquiries();
    }

    public void manageFlatBooking() {
        bookingOfficerController.manageFlatBooking();
    }

    // --- Inherited Applicant methods (viewOpenProjects, applyForProject, etc.) ---
    // These are available directly via inheritance from ApplicantController.
    // For example, calling officerController.viewOpenProjects() will execute
    // the viewOpenProjects method defined in ApplicantActionController (via ApplicantController).
    // Similarly, Officer's own enquiry actions (submit, view my, edit my, delete my)
    // are handled by the EnquiryApplicantController instance held by the parent ApplicantController.
}
```

Controllers/ProjectManagerController.java
```java
package Controllers;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Enums.OfficerRegistrationStatus;
import Models.BTOApplication;
import Models.FlatTypeDetails;
import Models.HDBManager;
import Models.OfficerRegistration;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

// Handles Manager actions related to Project CRUD and visibility
public class ProjectManagerController extends BaseController {

     private final IEnquiryService enquiryService; // Needed for deletion cleanup

    public ProjectManagerController(IUserService userService, IProjectService projectService,
                                   IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                                   IEnquiryService enquiryService, // Inject enquiry service
                                   User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
        this.enquiryService = enquiryService;
         if (!(currentUser instanceof HDBManager)) {
            throw new IllegalArgumentException("ProjectManagerController requires an HDBManager user.");
        }
    }

    public void createProject() {
        HDBManager manager = (HDBManager) currentUser; // Cast is safe due to constructor check

        System.out.println("\n--- Create New BTO Project ---");

        String projectName;
        while (true) {
            System.out.print("Enter Project Name: ");
            projectName = scanner.nextLine().trim();
            if (projectName.isEmpty()) {
                System.out.println("Project name cannot be empty.");
            } else if (projectService.findProjectByName(projectName) != null) { // Check using service
                System.out.println("Project name already exists. Please choose a unique name.");
            } else {
                break;
            }
        }

        System.out.print("Enter Neighborhood: ");
        String neighborhood = scanner.nextLine().trim();
        if (neighborhood.isEmpty()) {
            System.out.println("Neighborhood cannot be empty. Creation cancelled.");
            return;
        }

        // Get Flat Type Details
        Map<FlatType, FlatTypeDetails> flatTypes = new HashMap<>();
        System.out.println("--- Flat Type Details ---");
        int units2Room = getIntInput("Enter total number of 2-Room units (0 if none): ", 0, 9999);
        if (units2Room > 0) {
            double price2Room = getDoubleInput("Enter selling price for 2-Room units: $", 0, Double.MAX_VALUE);
            // Initial available units = total units
            flatTypes.put(FlatType.TWO_ROOM, new FlatTypeDetails(units2Room, units2Room, price2Room));
        }
        int units3Room = getIntInput("Enter total number of 3-Room units (0 if none): ", 0, 9999);
        if (units3Room > 0) {
            double price3Room = getDoubleInput("Enter selling price for 3-Room units: $", 0, Double.MAX_VALUE);
            // Initial available units = total units
            flatTypes.put(FlatType.THREE_ROOM, new FlatTypeDetails(units3Room, units3Room, price3Room));
        }

        if (flatTypes.isEmpty()) {
            System.out.println(
                    "Error: Project must have at least one type of flat (2-Room or 3-Room). Creation cancelled.");
            return;
        }

        // Get and Validate Dates, checking for overlap with manager's *other* projects
        Date openingDate;
        Date closingDate;
        while (true) {
            openingDate = getDateInput("Enter Application Opening Date (yyyy-MM-dd): ", false); // Not blank
            closingDate = getDateInput("Enter Application Closing Date (yyyy-MM-dd): ", false); // Not blank

            if (openingDate == null || closingDate == null) {
                // Should not happen with allowBlank=false, but check anyway
                System.out.println("Dates cannot be empty. Please re-enter.");
                continue;
            }
            if (closingDate.before(openingDate)) {
                System.out.println("Closing date cannot be before opening date. Please re-enter.");
                continue;
            }

            // Check overlap with *other* projects managed by the same manager
            Project proposedProjectDates = new Project("__temp__", "__temp__", flatTypes, openingDate, closingDate, manager.getNric(), 0, null, true); // Temporary project for date check
            boolean overlapsWithActive = projectService.getProjectsManagedBy(manager.getNric()) // Get manager's projects via service
                    .stream()
                    // No need to filter out the project being created as it doesn't exist yet
                    .anyMatch(existingProject -> checkDateOverlap(proposedProjectDates, existingProject)); // Use BaseController helper

            if (overlapsWithActive) {
                System.out.println("Error: The specified application period overlaps with another project you manage.");
                System.out.println("Please enter different dates or manage the visibility/dates of the existing project.");
            } else {
                break; // Dates are valid and don't overlap
            }
        }

        // Get Max Officer Slots
        int maxOfficers = getIntInput("Enter Maximum HDB Officer Slots (1-10): ", 1, 10);

        // Create Project object - initially no approved officers, visibility off
        Project newProject = new Project(projectName, neighborhood, flatTypes, openingDate, closingDate,
                manager.getNric(), maxOfficers, new ArrayList<>(), false); // Visibility false by default

        projectService.addProject(newProject); // Add via service
        System.out.println("Project '" + projectName + "' created successfully. Visibility is currently OFF.");
        projectService.saveProjects(projectService.getAllProjects()); // Save immediately
    }

     public void editProject() {
        System.out.println("\n--- Edit BTO Project ---");
        // Get projects managed by the current user (manager) using the service
        List<Project> myProjects = getManagedProjects(false); // Use helper that filters by manager NRIC
        if (myProjects.isEmpty()) {
            // Message is printed within getManagedProjects
            return;
        }

        viewAndSelectProject(myProjects, "Select Project to Edit");
        Project projectToEdit = selectProjectFromList(myProjects);
        if (projectToEdit == null) return; // User cancelled

        System.out.println("Editing Project: " + projectToEdit.getProjectName() + " (Leave blank to keep current value)");

        // Edit Neighborhood
        System.out.print("Enter new Neighborhood [" + projectToEdit.getNeighborhood() + "]: ");
        String newNeighborhood = scanner.nextLine().trim();
        if (!newNeighborhood.isEmpty()) {
            projectToEdit.setNeighborhood(newNeighborhood);
        }

        // Edit Flat Type Prices (cannot change types or total units easily after creation)
        Map<FlatType, FlatTypeDetails> currentFlatTypes = projectToEdit.getMutableFlatTypeDetailsMap(); // Get mutable map
        for (FlatType type : FlatType.values()) { // Iterate through possible types
            FlatTypeDetails currentDetails = currentFlatTypes.get(type);
            if (currentDetails != null) { // If this type exists in the project
                System.out.println("--- Edit " + type.getDisplayName() + " ---");
                System.out.print("Enter new selling price [" + String.format("%.2f", currentDetails.getSellingPrice())
                        + "] (leave blank to keep): $");
                String priceInput = scanner.nextLine().trim();
                if (!priceInput.isEmpty()) {
                    try {
                        double newPrice = Double.parseDouble(priceInput);
                        if (newPrice >= 0) {
                            currentDetails.setSellingPrice(newPrice); // Update the details object directly
                        } else {
                            System.out.println("Price cannot be negative. Keeping original price.");
                        }
                    } catch (NumberFormatException e) {
                        System.out.println("Invalid price format. Keeping original price.");
                    }
                }
            }
        }
        // No need to call projectToEdit.setFlatTypes as we modified the internal map directly

        // Edit Dates (check for overlap)
        Date originalOpening = projectToEdit.getApplicationOpeningDate();
        Date originalClosing = projectToEdit.getApplicationClosingDate();
        Date newOpeningDate = getDateInput("Enter new Opening Date (yyyy-MM-dd) ["
                + DateUtils.formatDate(originalOpening) + "] (leave blank to keep): ", true); // Allow blank
        Date newClosingDate = getDateInput("Enter new Closing Date (yyyy-MM-dd) ["
                + DateUtils.formatDate(originalClosing) + "] (leave blank to keep): ", true); // Allow blank

        // Determine final dates, considering blanks
        Date finalOpening = (newOpeningDate != null) ? newOpeningDate : originalOpening;
        Date finalClosing = (newClosingDate != null) ? newClosingDate : originalClosing;

        boolean datesChanged = (newOpeningDate != null || newClosingDate != null);
        boolean datesValid = true;

        // Validate final dates
        if (finalClosing.before(finalOpening)) {
            System.out.println("Error: Closing date cannot be before opening date. Dates not updated.");
            datesValid = false;
        }

        // If dates changed and are valid so far, check for overlap with *other* projects
        if (datesChanged && datesValid) {
            // Create a temporary project object with the new dates for overlap check
             Project proposedProjectDates = new Project(
                    projectToEdit.getProjectName(), projectToEdit.getNeighborhood(), projectToEdit.getFlatTypes(), // Use current types
                    finalOpening, finalClosing, projectToEdit.getManagerNric(), projectToEdit.getMaxOfficerSlots(),
                    projectToEdit.getApprovedOfficerNrics(), projectToEdit.isVisible());

            boolean overlapsWithOther = projectService.getProjectsManagedBy(currentUser.getNric())
                    .stream()
                    .filter(p -> !p.getProjectName().equals(projectToEdit.getProjectName())) // Exclude self
                    .anyMatch(otherProject -> checkDateOverlap(proposedProjectDates, otherProject)); // Use BaseController helper

            if (overlapsWithOther) {
                System.out.println("Error: The new application period overlaps with another project you manage. Dates not updated.");
                datesValid = false;
            }
        }

        // Apply date changes if valid
        if (datesValid) {
            if (newOpeningDate != null) projectToEdit.setApplicationOpeningDate(newOpeningDate);
            if (newClosingDate != null) projectToEdit.setApplicationClosingDate(newClosingDate);
            if (datesChanged) System.out.println("Application dates updated.");
        }

        // Edit Max Officer Slots
        int currentMaxSlots = projectToEdit.getMaxOfficerSlots();
        int currentApprovedCount = projectToEdit.getApprovedOfficerNrics().size();
        // Minimum allowed slots is the number currently approved
        int minSlots = currentApprovedCount;
        System.out.print("Enter new Max Officer Slots [" + currentMaxSlots + "] (min " + minSlots
                + ", max 10, leave blank to keep): ");
        String slotsInput = scanner.nextLine().trim();
        if (!slotsInput.isEmpty()) {
            try {
                int newMaxSlots = Integer.parseInt(slotsInput);
                // Use the project's setter which includes validation
                projectToEdit.setMaxOfficerSlots(newMaxSlots); // Setter handles check >= approved count and range 1-10
                 // If setter printed an error, that's fine. If it succeeded, update was done.
            } catch (NumberFormatException e) {
                System.out.println("Invalid number format. Max slots not changed.");
            }
        }

        System.out.println("Project details update attempt complete.");
        projectService.saveProjects(projectService.getAllProjects()); // Save changes
    }

     public void deleteProject() {
        System.out.println("\n--- Delete BTO Project ---");
        List<Project> myProjects = getManagedProjects(false);
        if (myProjects.isEmpty()) return;

        viewAndSelectProject(myProjects, "Select Project to Delete");
        Project projectToDelete = selectProjectFromList(myProjects);
        if (projectToDelete == null) return;

        // Check for active associations using services
        boolean hasActiveApplications = applicationService.getApplicationsByProject(projectToDelete.getProjectName())
            .stream()
            .anyMatch(app -> app.getStatus() == ApplicationStatus.PENDING ||
                             app.getStatus() == ApplicationStatus.SUCCESSFUL ||
                             app.getStatus() == ApplicationStatus.BOOKED ||
                             app.getStatus() == ApplicationStatus.PENDING_WITHDRAWAL);

        boolean hasActiveRegistrations = officerRegistrationService.getRegistrationsByProject(projectToDelete.getProjectName())
             .stream()
             .anyMatch(reg -> reg.getStatus() == OfficerRegistrationStatus.PENDING ||
                              reg.getStatus() == OfficerRegistrationStatus.APPROVED);

        if (hasActiveApplications || hasActiveRegistrations) {
            System.out.println("Error: Cannot delete project '" + projectToDelete.getProjectName() + "'.");
            if (hasActiveApplications) System.out.println("- It has active BTO applications (Pending/Successful/Booked/PendingWithdrawal).");
            if (hasActiveRegistrations) System.out.println("- It has active Officer registrations (Pending/Approved).");
            System.out.println("Resolve these associations (e.g., reject applications/registrations, wait for booking/withdrawal) before deleting.");
            return;
        }

        // Confirmation
        System.out.print("Are you sure you want to permanently delete project '" + projectToDelete.getProjectName()
                + "'? This will also remove associated historical applications, registrations, and enquiries. (yes/no): ");
        String confirm = scanner.nextLine().trim().toLowerCase();

        if (confirm.equals("yes")) {
            String deletedProjectName = projectToDelete.getProjectName();

            // 1. Remove the project itself
            if (projectService.removeProject(projectToDelete)) { // Use service
                System.out.println("Project '" + deletedProjectName + "' deleted successfully.");
                projectService.saveProjects(projectService.getAllProjects()); // Save project list

                // 2. Remove associated applications
                List<String> appIdsToRemove = applicationService.getApplicationsByProject(deletedProjectName)
                                                .stream()
                                                .map(BTOApplication::getApplicationId)
                                                .collect(Collectors.toList());
                int removedAppCount = 0;
                for (String appId : appIdsToRemove) {
                    if (applicationService.removeApplication(appId)) {
                        removedAppCount++;
                    }
                }
                if (removedAppCount > 0) {
                    System.out.println("Removed " + removedAppCount + " associated applications.");
                    applicationService.saveApplications(applicationService.getAllApplications()); // Save changes
                }

                // 3. Remove associated officer registrations
                List<String> regIdsToRemove = officerRegistrationService.getRegistrationsByProject(deletedProjectName)
                                                .stream()
                                                .map(OfficerRegistration::getRegistrationId)
                                                .collect(Collectors.toList());
                int removedRegCount = 0;
                for (String regId : regIdsToRemove) {
                     if (officerRegistrationService.removeRegistration(regId)) {
                         removedRegCount++;
                     }
                }
                if (removedRegCount > 0) {
                    System.out.println("Removed " + removedRegCount + " associated officer registrations.");
                    officerRegistrationService.saveOfficerRegistrations(officerRegistrationService.getAllRegistrations()); // Save changes
                }

                // 4. Remove associated enquiries
                List<String> enqIdsToRemove = enquiryService.getEnquiriesByProject(deletedProjectName)
                                                .stream()
                                                .map(Enquiry::getEnquiryId)
                                                .collect(Collectors.toList());
                int removedEnqCount = 0;
                 for (String enqId : enqIdsToRemove) {
                      if (enquiryService.removeEnquiry(enqId)) {
                          removedEnqCount++;
                      }
                 }
                if (removedEnqCount > 0) {
                    System.out.println("Removed " + removedEnqCount + " associated enquiries.");
                    enquiryService.saveEnquiries(enquiryService.getAllEnquiries()); // Save changes
                }

            } else {
                System.err.println("Error: Failed to remove project from service layer.");
            }
        } else {
            System.out.println("Deletion cancelled.");
        }
    }

    public void toggleProjectVisibility() {
        System.out.println("\n--- Toggle Project Visibility ---");
        List<Project> myProjects = getManagedProjects(false); // Get only managed projects
        if (myProjects.isEmpty()) return;

        viewAndSelectProject(myProjects, "Select Project to Toggle Visibility");
        Project projectToToggle = selectProjectFromList(myProjects);

        if (projectToToggle != null) {
            boolean currentVisibility = projectToToggle.isVisible();
            projectToToggle.setVisibility(!currentVisibility); // Toggle the state
            System.out.println("Project '" + projectToToggle.getProjectName() + "' visibility toggled to "
                    + (projectToToggle.isVisible() ? "ON" : "OFF") + ".");
            projectService.saveProjects(projectService.getAllProjects()); // Save the change
        }
    }

     public void viewAllProjects() {
        System.out.println("\n--- View All Projects (Manager View) ---");
        // Manager view ignores visibility, eligibility, availability, period checks
        List<Project> displayProjects = getFilteredProjects(false, false, false, false, false);
        viewAndSelectProject(displayProjects, "All BTO Projects (Manager View)");
    }

    public void viewMyProjects() {
        System.out.println("\n--- View My Managed Projects ---");
        // Use the helper that applies filters *and* manager NRIC
        List<Project> myProjects = getManagedProjects(true);
        viewAndSelectProject(myProjects, "Projects Managed By You");
    }

    // Helper specific to Manager context to get their projects, optionally applying user filters
    private List<Project> getManagedProjects(boolean applyUserFilters) {
        // Get all projects managed by current user (Manager)
        List<Project> managed = projectService.getProjectsManagedBy(currentUser.getNric());

        // Apply view filters (location, flat type) if requested
        if (applyUserFilters) {
            managed = managed.stream()
                .filter(p -> filterLocation == null || p.getNeighborhood().equalsIgnoreCase(filterLocation))
                .filter(p -> filterFlatType == null || p.getFlatTypes().containsKey(filterFlatType))
                .collect(Collectors.toList());
        }

        // Sort the result
        managed.sort(Comparator.comparing(Project::getProjectName));

        // Print message if list is empty
        if (managed.isEmpty()) {
            String filterMsg = (applyUserFilters && (filterLocation != null || filterFlatType != null))
                                ? " matching the current filters."
                                : ".";
            System.out.println("You are not managing any projects" + filterMsg);
        }
        return managed;
    }
}
```

Controllers/OfficerRegistrationManagerController.java
```java
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.OfficerRegistrationStatus;
import Models.HDBManager;
import Models.HDBOfficer;
import Models.OfficerRegistration;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

// Handles Manager actions related to Officer Registrations (Approve/Reject)
public class OfficerRegistrationManagerController extends BaseController {

     private final IEnquiryService enquiryService; // Needed by parent but not used here

    public OfficerRegistrationManagerController(IUserService userService, IProjectService projectService,
                                   IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                                   IEnquiryService enquiryService,
                                   User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
         this.enquiryService = enquiryService;
         if (!(currentUser instanceof HDBManager)) {
            throw new IllegalArgumentException("OfficerRegistrationManagerController requires an HDBManager user.");
        }
    }

     public void manageOfficerRegistrations() {
        System.out.println("\n--- Manage HDB Officer Registrations ---");
        // Get projects managed by this manager
        List<Project> myProjects = projectService.getProjectsManagedBy(currentUser.getNric())
                                    .stream()
                                    .sorted(Comparator.comparing(Project::getProjectName))
                                    .collect(Collectors.toList());
        if (myProjects.isEmpty()) {
            System.out.println("You are not managing any projects for which to manage registrations.");
            return;
        }

        // Select project
        System.out.println("Select project to manage registrations for:");
        viewAndSelectProject(myProjects, "Select Project"); // Display only managed projects
        Project selectedProject = selectProjectFromList(myProjects);
        if (selectedProject == null) return; // User cancelled

        System.out.println("\n--- Registrations for Project: " + selectedProject.getProjectName() + " ---");
        System.out.println("Officer Slots: " + selectedProject.getApprovedOfficerNrics().size() + " / "
                + selectedProject.getMaxOfficerSlots() + " (Remaining: " + selectedProject.getRemainingOfficerSlots() + ")");

        // Get registrations for this project using the service
        List<OfficerRegistration> projectRegistrations = officerRegistrationService.getRegistrationsByProject(selectedProject.getProjectName())
                .stream()
                .sorted(Comparator.comparing(OfficerRegistration::getRegistrationDate)) // Sort by date
                .collect(Collectors.toList());

        // Separate pending registrations
        List<OfficerRegistration> pendingRegistrations = projectRegistrations.stream()
                .filter(reg -> reg.getStatus() == OfficerRegistrationStatus.PENDING)
                .collect(Collectors.toList());

        // --- Process Pending Registrations ---
        System.out.println("\n--- Pending Registrations ---");
        if (pendingRegistrations.isEmpty()) {
            System.out.println("(None)");
        } else {
            // Display pending registrations for selection
            for (int i = 0; i < pendingRegistrations.size(); i++) {
                OfficerRegistration reg = pendingRegistrations.get(i);
                User officerUser = userService.findUserByNric(reg.getOfficerNric()); // Get officer details
                System.out.printf("%d. NRIC: %s | Name: %-15s | Date: %s\n",
                        i + 1, reg.getOfficerNric(),
                        officerUser != null ? officerUser.getName() : "N/A",
                        DateUtils.formatDate(reg.getRegistrationDate()));
            }

            // Prompt for action
            int choice = getIntInput("Enter number to Approve/Reject (or 0 to skip): ", 0, pendingRegistrations.size());

            if (choice >= 1) {
                OfficerRegistration regToProcess = pendingRegistrations.get(choice - 1);
                User officerUser = userService.findUserByNric(regToProcess.getOfficerNric());

                // Validate if the user is still a valid HDBOfficer
                if (!(officerUser instanceof HDBOfficer)) {
                    System.out.println("Error: User " + regToProcess.getOfficerNric()
                            + " is no longer a valid HDB Officer. Rejecting registration.");
                    regToProcess.setStatus(OfficerRegistrationStatus.REJECTED);
                    officerRegistrationService.saveOfficerRegistrations(officerRegistrationService.getAllRegistrations()); // Save change
                    return; // Exit processing for this round
                }
                HDBOfficer officer = (HDBOfficer) officerUser;

                // Prompt for Approve/Reject
                System.out.print("Approve or Reject registration for Officer " + officer.getName() + "? (A/R): ");
                String action = scanner.nextLine().trim().toUpperCase();

                if (action.equals("A")) {
                    // --- Approve Action ---
                    // Check remaining slots
                    if (selectedProject.getRemainingOfficerSlots() <= 0) {
                        System.out.println("Cannot approve. No remaining officer slots for this project.");
                    }
                    // Check if officer handles overlapping project
                    else if (isOfficerHandlingOverlappingProject(officer, selectedProject)) {
                        System.out.println("Cannot approve. Officer is already handling another project with overlapping dates.");
                        // Optionally suggest rejecting or waiting?
                    }
                    // If checks pass, approve
                    else {
                        approveOfficerRegistration(regToProcess, selectedProject, officer); // Call helper
                    }
                } else if (action.equals("R")) {
                    // --- Reject Action ---
                    regToProcess.setStatus(OfficerRegistrationStatus.REJECTED);
                    System.out.println("Registration Rejected for Officer " + officer.getName() + ".");
                    officerRegistrationService.saveOfficerRegistrations(officerRegistrationService.getAllRegistrations()); // Save change
                } else {
                    System.out.println("Invalid action ('A' or 'R' expected). No change made.");
                }
            } else if (choice != 0) {
                System.out.println("Invalid choice.");
            }
            // If choice is 0, skip processing
        }

        // --- Display Other Statuses ---
        System.out.println("\n--- Approved Officers for this Project ---");
        List<String> approvedNrics = selectedProject.getApprovedOfficerNrics();
        if (approvedNrics.isEmpty()) {
            System.out.println("(None)");
        } else {
            approvedNrics.forEach(nric -> {
                User user = userService.findUserByNric(nric);
                System.out.println("- NRIC: " + nric + (user != null ? " (Name: " + user.getName() + ")" : " (Name: N/A)"));
            });
        }

        System.out.println("\n--- Rejected Registrations for this Project ---");
        List<OfficerRegistration> rejected = projectRegistrations.stream()
                .filter(r -> r.getStatus() == OfficerRegistrationStatus.REJECTED)
                .collect(Collectors.toList());
        if (rejected.isEmpty()) {
            System.out.println("(None)");
        } else {
            rejected.forEach(reg -> {
                 User user = userService.findUserByNric(reg.getOfficerNric());
                 System.out.println("- NRIC: " + reg.getOfficerNric()
                                     + (user != null ? " (Name: " + user.getName() + ")" : " (Name: N/A)")
                                     + " | Rejected on/after: " + DateUtils.formatDate(reg.getRegistrationDate())); // Date is registration date
            });
        }
    }

     // Helper to check if an officer is already handling an approved project with overlapping dates
    private boolean isOfficerHandlingOverlappingProject(HDBOfficer officer, Project targetProject) {
        // Get all APPROVED registrations for this officer
        return officerRegistrationService.getRegistrationsByOfficer(officer.getNric())
                .stream()
                .filter(reg -> reg.getStatus() == OfficerRegistrationStatus.APPROVED)
                // Exclude the target project itself (though status should be PENDING anyway)
                .filter(reg -> !reg.getProjectName().equals(targetProject.getProjectName()))
                // Find the corresponding project for the approved registration
                .map(reg -> projectService.findProjectByName(reg.getProjectName()))
                .filter(otherProject -> otherProject != null) // Ensure project exists
                // Check if any of these other projects overlap with the target project
                .anyMatch(otherProject -> checkDateOverlap(targetProject, otherProject)); // Use BaseController helper
    }

     // Helper to perform the approval steps
    private void approveOfficerRegistration(OfficerRegistration registration, Project project, HDBOfficer officer) {
        // Double-check slots (although checked before calling)
        if (project.getRemainingOfficerSlots() <= 0) {
            System.out.println("Error: No remaining officer slots. Approval cannot proceed.");
            return;
        }

        // 1. Add officer NRIC to the project's approved list
        if (project.addApprovedOfficer(registration.getOfficerNric())) {
            // 2. Update the registration status
            registration.setStatus(OfficerRegistrationStatus.APPROVED);
            System.out.println("Registration Approved. Officer " + registration.getOfficerNric() + " (" + officer.getName() + ") added to project '" + project.getProjectName() + "'.");

            // 3. Save both the updated registration and the updated project
            officerRegistrationService.saveOfficerRegistrations(officerRegistrationService.getAllRegistrations());
            projectService.saveProjects(projectService.getAllProjects());
        } else {
            // This might happen if the officer was already added concurrently, or slots became zero.
            System.err.println("Error: Failed to add officer " + registration.getOfficerNric() + " to project '" + project.getProjectName() + "' approved list (Slots full or already added?). Approval aborted.");
            // Consider potentially reverting registration status if needed, but unlikely necessary.
        }
    }
}
```

Controllers/ApplicationManagerController.java
```java
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Models.Applicant;
import Models.BTOApplication;
import Models.FlatTypeDetails;
import Models.HDBManager;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

// Handles Manager actions related to BTO Application approval/rejection
public class ApplicationManagerController extends BaseController {

     private final IEnquiryService enquiryService; // Needed by parent

    public ApplicationManagerController(IUserService userService, IProjectService projectService,
                                   IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                                   IEnquiryService enquiryService,
                                   User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
        this.enquiryService = enquiryService;
         if (!(currentUser instanceof HDBManager)) {
            throw new IllegalArgumentException("ApplicationManagerController requires an HDBManager user.");
        }
    }

     public void manageApplications() {
        System.out.println("\n--- Manage BTO Applications ---");
        // Get projects managed by this manager
        List<Project> myProjects = projectService.getProjectsManagedBy(currentUser.getNric())
                                    .stream()
                                    .sorted(Comparator.comparing(Project::getProjectName))
                                    .collect(Collectors.toList());
        if (myProjects.isEmpty()) {
            System.out.println("You are not managing any projects for which to manage applications.");
            return;
        }

        // Select project
        System.out.println("Select project to manage applications for:");
        viewAndSelectProject(myProjects, "Select Project");
        Project selectedProject = selectProjectFromList(myProjects);
        if (selectedProject == null) return;

        System.out.println("\n--- Applications for Project: " + selectedProject.getProjectName() + " ---");

        // Get all applications for this project via service
        List<BTOApplication> projectApplications = applicationService.getApplicationsByProject(selectedProject.getProjectName())
                .stream()
                .sorted(Comparator.comparing(BTOApplication::getApplicationDate)) // Sort by date
                .collect(Collectors.toList());

        if (projectApplications.isEmpty()) {
            System.out.println("No applications found for this project.");
            return;
        }

        // Filter for PENDING applications
        List<BTOApplication> pendingApps = projectApplications.stream()
                .filter(app -> app.getStatus() == ApplicationStatus.PENDING)
                .collect(Collectors.toList());

        // --- Process Pending Applications ---
        System.out.println("--- Pending Applications ---");
        if (pendingApps.isEmpty()) {
            System.out.println("(None)");
        } else {
            // Display pending applications for selection
            for (int i = 0; i < pendingApps.size(); i++) {
                BTOApplication app = pendingApps.get(i);
                User applicantUser = userService.findUserByNric(app.getApplicantNric()); // Get applicant details
                System.out.printf("%d. NRIC: %s | Name: %-15s | Type: %-8s | Date: %s\n",
                        i + 1, app.getApplicantNric(),
                        applicantUser != null ? applicantUser.getName() : "N/A",
                        app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A",
                        DateUtils.formatDate(app.getApplicationDate()));
            }

            // Prompt for action
            int choice = getIntInput("Enter number to Approve/Reject (or 0 to skip): ", 0, pendingApps.size());

            if (choice >= 1) {
                BTOApplication appToProcess = pendingApps.get(choice - 1);
                User applicantUser = userService.findUserByNric(appToProcess.getApplicantNric());

                // Validate applicant data
                if (!(applicantUser instanceof Applicant)) {
                    System.out.println("Error: Applicant data not found or invalid for NRIC "
                            + appToProcess.getApplicantNric() + ". Rejecting application.");
                    appToProcess.setStatus(ApplicationStatus.UNSUCCESSFUL); // Set status in application object
                    // Applicant profile status will be updated during next sync or manually if needed
                    applicationService.saveApplications(applicationService.getAllApplications()); // Save change
                    return; // Exit processing for this round
                }
                Applicant applicant = (Applicant) applicantUser;

                // Prompt for Approve/Reject
                System.out.print("Approve or Reject application for Applicant " + applicant.getName() + "? (A/R): ");
                String action = scanner.nextLine().trim().toUpperCase();

                if (action.equals("A")) {
                    // --- Approve Action ---
                    FlatType appliedType = appToProcess.getFlatTypeApplied();
                    if (appliedType == null) {
                        System.out.println("Error: Application has no specified flat type. Cannot approve. Rejecting.");
                        appToProcess.setStatus(ApplicationStatus.UNSUCCESSFUL);
                        applicant.setApplicationStatus(ApplicationStatus.UNSUCCESSFUL); // Update profile immediately
                        applicationService.saveApplications(applicationService.getAllApplications());
                        return;
                    }

                    // Get project details (refreshing might be good practice)
                    Project currentProjectState = projectService.findProjectByName(selectedProject.getProjectName());
                     if (currentProjectState == null) {
                          System.out.println("Error: Project details not found. Cannot approve. Rejecting.");
                          appToProcess.setStatus(ApplicationStatus.UNSUCCESSFUL);
                          applicant.setApplicationStatus(ApplicationStatus.UNSUCCESSFUL);
                          applicationService.saveApplications(applicationService.getAllApplications());
                          return;
                     }
                    FlatTypeDetails details = currentProjectState.getFlatTypeDetails(appliedType); // Use non-mutable getter is fine here

                    if (details == null) {
                        System.out.println("Error: Applied flat type (" + appliedType.getDisplayName()
                                + ") does not exist in this project configuration. Rejecting application.");
                        appToProcess.setStatus(ApplicationStatus.UNSUCCESSFUL);
                        applicant.setApplicationStatus(ApplicationStatus.UNSUCCESSFUL);
                        applicationService.saveApplications(applicationService.getAllApplications());
                        return;
                    }

                    // Check if approving exceeds total units (based on SUCCESSFUL or BOOKED apps)
                    long alreadySuccessfulOrBookedCount = applicationService.getApplicationsByProject(currentProjectState.getProjectName())
                            .stream()
                            .filter(a -> a.getFlatTypeApplied() == appliedType &&
                                    (a.getStatus() == ApplicationStatus.SUCCESSFUL || a.getStatus() == ApplicationStatus.BOOKED))
                            .count();

                    if (alreadySuccessfulOrBookedCount < details.getTotalUnits()) {
                        // Approve: Update application and applicant status
                        appToProcess.setStatus(ApplicationStatus.SUCCESSFUL);
                        applicant.setApplicationStatus(ApplicationStatus.SUCCESSFUL); // Update profile immediately
                        System.out.println("Application Approved (Status: SUCCESSFUL). Applicant can now book via Officer.");
                        applicationService.saveApplications(applicationService.getAllApplications()); // Save change
                        // userService.saveUsers(userService.getAllUsers()); // Optional immediate save of user profile
                    } else {
                        // Cannot approve due to capacity
                        System.out.println("Cannot approve. The number of successful/booked applications (" + alreadySuccessfulOrBookedCount + ") already meets or exceeds the total supply ("
                                + details.getTotalUnits() + ") for " + appliedType.getDisplayName() + ".");
                        System.out.println("Consider rejecting this application or managing existing successful/booked ones.");
                    }

                } else if (action.equals("R")) {
                    // --- Reject Action ---
                    appToProcess.setStatus(ApplicationStatus.UNSUCCESSFUL);
                    applicant.setApplicationStatus(ApplicationStatus.UNSUCCESSFUL); // Update profile immediately
                    applicant.setBookedFlatType(null); // Ensure booked type is cleared if they were somehow booked before
                    System.out.println("Application Rejected (Status: UNSUCCESSFUL).");
                    applicationService.saveApplications(applicationService.getAllApplications()); // Save change
                    // userService.saveUsers(userService.getAllUsers()); // Optional immediate save
                } else {
                    System.out.println("Invalid action ('A' or 'R' expected). No change made.");
                }
            } else if (choice != 0) {
                System.out.println("Invalid choice.");
            }
             // If choice is 0, skip processing
        }

        // --- Display Other Statuses ---
        System.out.println("\n--- Other Application Statuses ---");
        List<BTOApplication> otherApps = projectApplications.stream()
                .filter(app -> app.getStatus() != ApplicationStatus.PENDING)
                .collect(Collectors.toList());

        if (otherApps.isEmpty()) {
             System.out.println("(None)");
        } else {
            otherApps.forEach(app -> {
                User applicant = userService.findUserByNric(app.getApplicantNric());
                System.out.printf("- NRIC: %s | Name: %-15s | Type: %-8s | Status: %s\n",
                        app.getApplicantNric(),
                        applicant != null ? applicant.getName() : "N/A",
                        app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A",
                        app.getStatus());
            });
        }
    }
}
```

Controllers/WithdrawalManagerController.java
```java
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Models.Applicant;
import Models.BTOApplication;
import Models.FlatTypeDetails;
import Models.HDBManager;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;


// Handles Manager actions related to Withdrawal Requests
public class WithdrawalManagerController extends BaseController {

    private final IEnquiryService enquiryService; // Needed by parent

    public WithdrawalManagerController(IUserService userService, IProjectService projectService,
                                   IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                                   IEnquiryService enquiryService,
                                   User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
        this.enquiryService = enquiryService;
        if (!(currentUser instanceof HDBManager)) {
            throw new IllegalArgumentException("WithdrawalManagerController requires an HDBManager user.");
        }
    }

     public void manageWithdrawalRequests() {
        System.out.println("\n--- Manage Withdrawal Requests ---");
        // Get names of projects managed by this manager
        List<String> myProjectNames = projectService.getProjectsManagedBy(currentUser.getNric())
                .stream()
                .map(Project::getProjectName)
                .collect(Collectors.toList());

        if (myProjectNames.isEmpty()) {
            System.out.println("You are not managing any projects to have withdrawal requests.");
            return;
        }

        // Find PENDING_WITHDRAWAL applications for the managed projects
        List<BTOApplication> pendingWithdrawals = applicationService.getAllApplications().values().stream()
                .filter(app -> app.getStatus() == ApplicationStatus.PENDING_WITHDRAWAL)
                .filter(app -> myProjectNames.contains(app.getProjectName())) // Filter by managed projects
                .sorted(Comparator.comparing(BTOApplication::getApplicationDate)) // Sort by date
                .collect(Collectors.toList());

        if (pendingWithdrawals.isEmpty()) {
            System.out.println("No pending withdrawal requests found for the projects you manage.");
            return;
        }

        // --- Display Pending Withdrawals ---
        System.out.println("--- Pending Withdrawal Requests ---");
        for (int i = 0; i < pendingWithdrawals.size(); i++) {
            BTOApplication app = pendingWithdrawals.get(i);
            User applicantUser = userService.findUserByNric(app.getApplicantNric()); // Get applicant info

            // Determine the status *before* withdrawal request was made
            ApplicationStatus statusBefore = app.getStatusBeforeWithdrawal();
            if (statusBefore == null) {
                 // statusBeforeWithdrawal should be set when status becomes PENDING_WITHDRAWAL
                 // If it's null here, it's an inconsistency, but we can try to infer.
                 statusBefore = inferStatusBeforeWithdrawal(app, (applicantUser instanceof Applicant) ? (Applicant) applicantUser : null);
                 System.out.print(" (Inferred Original: " + statusBefore + ")");
            } else {
                System.out.print(" (Original: " + statusBefore + ")");
            }

            // Print application details
            System.out.printf("\n%d. NRIC: %s | Name: %-15s | Project: %-15s | Type: %-8s | App Date: %s",
                    i + 1,
                    app.getApplicantNric(),
                    applicantUser != null ? applicantUser.getName() : "N/A",
                    app.getProjectName(),
                    app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A",
                    DateUtils.formatDate(app.getApplicationDate()));
            System.out.println(); // Newline after printing details
        }

        // Prompt for action
        int choice = getIntInput("Enter number to Approve/Reject withdrawal (or 0 to skip): ", 0, pendingWithdrawals.size());

        if (choice >= 1) {
            BTOApplication appToProcess = pendingWithdrawals.get(choice - 1);
            User applicantUser = userService.findUserByNric(appToProcess.getApplicantNric());

            // Validate Applicant
            if (!(applicantUser instanceof Applicant)) {
                System.out.println("Error: Applicant data not found or invalid for NRIC "
                        + appToProcess.getApplicantNric() + ". Cannot process withdrawal.");
                return;
            }
            Applicant applicant = (Applicant) applicantUser;

            // Validate Project
            Project project = projectService.findProjectByName(appToProcess.getProjectName());
            if (project == null) {
                System.out.println("Error: Project data not found for application "
                        + appToProcess.getApplicationId() + ". Cannot process withdrawal.");
                return;
            }

            // Determine original status (use stored value if available, otherwise infer)
            ApplicationStatus originalStatus = appToProcess.getStatusBeforeWithdrawal();
            if (originalStatus == null) {
                originalStatus = inferStatusBeforeWithdrawal(appToProcess, applicant);
                 System.out.println("Note: Original status inferred as " + originalStatus + " due to missing data.");
            }

             // Double check current status is still PENDING_WITHDRAWAL
             if (appToProcess.getStatus() != ApplicationStatus.PENDING_WITHDRAWAL) {
                  System.out.println("Error: Application status is no longer PENDING_WITHDRAWAL (Current: " + appToProcess.getStatus() + "). Cannot process.");
                  return;
             }


            // Prompt for Approve/Reject
            System.out.print("Approve or Reject withdrawal request for Applicant " + applicant.getName() + "? (A/R): ");
            String action = scanner.nextLine().trim().toUpperCase();

            if (action.equals("A")) {
                // --- Approve Withdrawal ---
                ApplicationStatus finalStatus;
                boolean releasedUnit = false;

                // Determine final status based on original status
                if (originalStatus == ApplicationStatus.BOOKED) {
                    finalStatus = ApplicationStatus.UNSUCCESSFUL; // Penalize booked withdrawal
                    FlatType bookedType = appToProcess.getFlatTypeApplied(); // Type that was booked
                    if (bookedType != null) {
                        FlatTypeDetails details = project.getMutableFlatTypeDetails(bookedType); // Get mutable details
                        if (details != null) {
                            // Increment available units for the released flat
                            if (details.incrementAvailableUnits()) {
                                releasedUnit = true;
                                System.out.println("Unit for " + bookedType.getDisplayName()
                                        + " released back to project " + project.getProjectName() + ". Available: " + details.getAvailableUnits());
                            } else {
                                // Should not happen if units were correctly decremented on booking
                                System.err.println("Error: Could not increment available units for " + bookedType.getDisplayName() + " (already at max?). Check data consistency.");
                            }
                        } else {
                            System.err.println("Error: Could not find flat details for " + bookedType.getDisplayName() + " during withdrawal approval.");
                        }
                    } else {
                        System.err.println("Error: Cannot determine booked flat type to release unit during withdrawal approval.");
                    }
                } else if (originalStatus == ApplicationStatus.SUCCESSFUL) {
                    finalStatus = ApplicationStatus.UNSUCCESSFUL; // Penalize successful withdrawal
                } else { // Original was PENDING or unknown/inferred as PENDING
                    finalStatus = ApplicationStatus.WITHDRAWN; // No penalty, just withdrawn
                }

                // Update application status
                appToProcess.setStatus(finalStatus); // This also clears statusBeforeWithdrawal

                // Update applicant profile
                applicant.setApplicationStatus(finalStatus);
                applicant.setBookedFlatType(null); // Clear booked type regardless of original status

                System.out.println("Withdrawal request Approved. Application status set to " + finalStatus + ".");

                // Save changes
                applicationService.saveApplications(applicationService.getAllApplications());
                if (releasedUnit) {
                    projectService.saveProjects(projectService.getAllProjects()); // Save project if unit was released
                }
                // userService.saveUsers(userService.getAllUsers()); // Save user profile change

            } else if (action.equals("R")) {
                // --- Reject Withdrawal ---
                // Revert application status to original status
                appToProcess.setStatus(originalStatus); // This clears statusBeforeWithdrawal

                // Revert applicant profile status
                applicant.setApplicationStatus(originalStatus);
                // Note: We don't need to reset bookedFlatType here, as it wouldn't have been cleared yet.

                System.out.println("Withdrawal request Rejected. Application status reverted to " + originalStatus + ".");
                applicationService.saveApplications(applicationService.getAllApplications()); // Save the reverted status
                // userService.saveUsers(userService.getAllUsers()); // Save reverted user status

            } else {
                System.out.println("Invalid action ('A' or 'R' expected). No change made.");
            }
        } else if (choice != 0) {
            System.out.println("Invalid choice.");
        }
         // If choice is 0, skip processing
    }

     // Helper to infer original status if statusBeforeWithdrawal wasn't set correctly
    private ApplicationStatus inferStatusBeforeWithdrawal(BTOApplication app, Applicant applicant) {
         // If applicant profile shows BOOKED and the application matches the flat type, assume BOOKED.
         if (applicant != null && applicant.hasBooked() && applicant.getBookedFlatType() == app.getFlatTypeApplied()) {
             return ApplicationStatus.BOOKED;
         }
         // If applicant profile shows SUCCESSFUL for this project, assume SUCCESSFUL.
         // (Checking project name might be needed if applicant could have multiple non-booked apps somehow)
         else if (applicant != null && applicant.getApplicationStatus() == ApplicationStatus.SUCCESSFUL && applicant.getAppliedProjectName().equals(app.getProjectName())) {
              return ApplicationStatus.SUCCESSFUL;
         }
         // If the application itself has a flat type (likely from PENDING or SUCCESSFUL state), lean towards SUCCESSFUL as the most likely state before withdrawal if not BOOKED.
         else if (app.getFlatTypeApplied() != null) {
              // This is ambiguous. Could have been PENDING or SUCCESSFUL.
              // Let's default to SUCCESSFUL if a flat type exists, assuming approval happened.
              // This matches the old logic.
              return ApplicationStatus.SUCCESSFUL;
         }
         // Default fallback: assume it was PENDING.
         return ApplicationStatus.PENDING;
    }
}
```

Controllers/ReportManagerController.java
```java
package Controllers;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Enums.ApplicationStatus;
import Enums.FlatType;
import Enums.MaritalStatus;
import Models.Applicant;
import Models.BTOApplication;
import Models.HDBManager;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;

// Handles Manager action for generating reports
public class ReportManagerController extends BaseController {

     private final IEnquiryService enquiryService; // Needed by parent

    public ReportManagerController(IUserService userService, IProjectService projectService,
                                   IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                                   IEnquiryService enquiryService,
                                   User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
         this.enquiryService = enquiryService;
         if (!(currentUser instanceof HDBManager)) {
            throw new IllegalArgumentException("ReportManagerController requires an HDBManager user.");
        }
    }

     public void generateApplicantReport() {
        System.out.println("\n--- Generate Applicant Report (Booked Flats) ---");

        // --- Filter by Project ---
        System.out.println("Filter by project:");
        System.out.println("1. All Projects Managed By You (Respecting View Filters)");
        System.out.println("2. A Specific Project Managed By You");
        System.out.println("0. Cancel");
        int projectFilterChoice = getIntInput("Enter choice: ", 0, 2);

        List<Project> projectsToReportOn = new ArrayList<>();
        if (projectFilterChoice == 0) return; // Cancel

        if (projectFilterChoice == 1) {
            // Get managed projects, applying current view filters (location/type)
            projectsToReportOn = getManagedProjectsApplyingFilters(); // Use helper
            if (projectsToReportOn.isEmpty()) {
                // Message printed by helper if empty
                return;
            }
            System.out.println("Reporting on all projects you manage"
                    + (filterLocation != null || filterFlatType != null ? " (matching current view filters)." : "."));
        } else { // Choice is 2
            // Get managed projects without applying view filters for selection
            List<Project> allMyProjects = projectService.getProjectsManagedBy(currentUser.getNric());
            if (allMyProjects.isEmpty()) {
                System.out.println("You are not managing any projects.");
                return;
            }
            // Let user select one specific project
            viewAndSelectProject(allMyProjects.stream().sorted(Comparator.comparing(Project::getProjectName)).collect(Collectors.toList()), "Select Specific Project to Report On");
            Project specificProject = selectProjectFromList(allMyProjects);
            if (specificProject == null) return; // Cancelled selection
            projectsToReportOn.add(specificProject);
            System.out.println("Reporting specifically for project: " + specificProject.getProjectName());
        }

        // Get list of names of projects to include in the report
        final List<String> finalProjectNames = projectsToReportOn.stream()
                .map(Project::getProjectName)
                .collect(Collectors.toList());

        // --- Filter by Flat Type ---
        System.out.print("Filter report by Flat Type (TWO_ROOM, THREE_ROOM, or leave blank for all): ");
        String typeStr = scanner.nextLine().trim();
        FlatType filterReportFlatType = null;
        if (!typeStr.isEmpty()) {
            filterReportFlatType = FlatType.fromString(typeStr); // Use enum parser
            if (filterReportFlatType != null) {
                System.out.println("Filtering report for flat type: " + filterReportFlatType.getDisplayName());
            } else {
                System.out.println("Invalid flat type entered. Reporting for all types.");
            }
        }

        // --- Filter by Marital Status ---
        System.out.print("Filter report by Marital Status (SINGLE, MARRIED, or leave blank for all): ");
        String maritalStr = scanner.nextLine().trim().toUpperCase();
        MaritalStatus filterMaritalStatus = null;
        if (!maritalStr.isEmpty()) {
            try {
                filterMaritalStatus = MaritalStatus.valueOf(maritalStr); // Use enum valueOf
                System.out.println("Filtering report for marital status: " + filterMaritalStatus);
            } catch (IllegalArgumentException e) {
                System.out.println("Invalid marital status. Reporting for all statuses.");
            }
        }

        // --- Filter by Age Range ---
        int minAge = getIntInput("Filter report by Minimum Age (e.g., 21, or 0 for no minimum): ", 0, 120);
        int maxAge = getIntInput("Filter report by Maximum Age (e.g., 65, or 0 for no maximum): ", 0, 120);
        if (minAge > 0 || maxAge > 0) {
            System.out.println("Filtering report for age range: "
                    + (minAge > 0 ? minAge : "Any") + " to "
                    + (maxAge > 0 ? maxAge : "Any"));
        }
         // Add validation: maxAge should not be less than minAge if both are specified > 0
         if (minAge > 0 && maxAge > 0 && maxAge < minAge) {
             System.out.println("Warning: Maximum age cannot be less than minimum age. Ignoring age filters.");
             minAge = 0;
             maxAge = 0;
         }

        // --- Final Filter Variables --- (effectively final for lambda)
        final FlatType finalFilterReportFlatType = filterReportFlatType;
        final MaritalStatus finalFilterMaritalStatus = filterMaritalStatus;
        final int finalMinAge = minAge;
        final int finalMaxAge = maxAge;

        // --- Generate Report Data ---
        List<BTOApplication> bookedApplications = applicationService.getAllApplications().values().stream()
                // 1. Filter by Status = BOOKED
                .filter(app -> app.getStatus() == ApplicationStatus.BOOKED)
                // 2. Filter by selected Project(s)
                .filter(app -> finalProjectNames.contains(app.getProjectName()))
                // 3. Filter by selected Flat Type (if any)
                .filter(app -> finalFilterReportFlatType == null || app.getFlatTypeApplied() == finalFilterReportFlatType)
                // 4. Filter by Applicant Demographics (Marital Status, Age)
                .filter(app -> {
                    User user = userService.findUserByNric(app.getApplicantNric());
                    if (user == null) return false; // Skip if user data not found

                    // Apply Marital Status filter
                    if (finalFilterMaritalStatus != null && user.getMaritalStatus() != finalFilterMaritalStatus) return false;
                    // Apply Min Age filter
                    if (finalMinAge > 0 && user.getAge() < finalMinAge) return false;
                    // Apply Max Age filter
                    if (finalMaxAge > 0 && user.getAge() > finalMaxAge) return false;

                    return true; // Include if all filters pass
                })
                // Sort the results (e.g., by Project Name then Applicant NRIC)
                .sorted(Comparator.comparing(BTOApplication::getProjectName)
                                  .thenComparing(BTOApplication::getApplicantNric))
                .collect(Collectors.toList());

        // --- Display Report ---
        System.out.println("\n--- Report: Applicants with Flat Bookings ---");
        // Display applied filters
        System.out.println("Filters Applied: Projects=" + String.join(", ", finalProjectNames)
                         + ", FlatType=" + (finalFilterReportFlatType == null ? "Any" : finalFilterReportFlatType.getDisplayName())
                         + ", MaritalStatus=" + (finalFilterMaritalStatus == null ? "Any" : finalFilterMaritalStatus)
                         + ", Age=" + (finalMinAge > 0 ? finalMinAge : "Any") + "-" + (finalMaxAge > 0 ? finalMaxAge : "Any"));
        System.out.println("---------------------------------------------------------------------------------");
        System.out.printf("%-15s | %-15s | %-5s | %-10s | %-15s | %-8s\n",
                "Applicant NRIC", "Name", "Age", "Marital", "Project Name", "FlatType");
        System.out.println("---------------------------------------------------------------------------------");

        if (bookedApplications.isEmpty()) {
            System.out.println("No matching booked applications found for the specified filters.");
        } else {
            // Print each booked application row
            bookedApplications.forEach(app -> {
                User user = userService.findUserByNric(app.getApplicantNric()); // Fetch user details again
                System.out.printf("%-15s | %-15s | %-5s | %-10s | %-15s | %-8s\n",
                        app.getApplicantNric(),
                        user != null ? user.getName() : "N/A",
                        user != null ? String.valueOf(user.getAge()) : "N/A", // Age as string
                        user != null ? user.getMaritalStatus().name() : "N/A", // Marital status name
                        app.getProjectName(),
                        app.getFlatTypeApplied() != null ? app.getFlatTypeApplied().getDisplayName() : "N/A");
            });
        }
        System.out.println("---------------------------------------------------------------------------------");
        System.out.println("Total matching booked applicants: " + bookedApplications.size());
        System.out.println("--- End of Report ---");
    }

     // Helper to get managed projects, applying view filters
     private List<Project> getManagedProjectsApplyingFilters() {
        return projectService.getProjectsManagedBy(currentUser.getNric())
            .stream()
            .filter(p -> filterLocation == null || p.getNeighborhood().equalsIgnoreCase(filterLocation))
            .filter(p -> filterFlatType == null || p.getFlatTypes().containsKey(filterFlatType))
            .sorted(Comparator.comparing(Project::getProjectName))
            .collect(Collectors.toList());
     }
}
```

Controllers/EnquiryManagerController.java
```java
package Controllers;

import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

import Models.Enquiry;
import Models.HDBManager;
import Models.Project;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;
import Utils.DateUtils;

// Handles Manager actions related to Enquiries (View All, View/Reply Managed)
public class EnquiryManagerController extends BaseController {

    private final IEnquiryService enquiryService;

    public EnquiryManagerController(IUserService userService, IProjectService projectService,
                                    IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                                    IEnquiryService enquiryService, // Inject enquiry service
                                    User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);
        this.enquiryService = enquiryService;
        if (!(currentUser instanceof HDBManager)) {
            throw new IllegalArgumentException("EnquiryManagerController requires an HDBManager user.");
        }
    }

    public void viewAllEnquiries() {
        System.out.println("\n--- View Enquiries (ALL Projects) ---");
        List<Enquiry> allEnquiries = enquiryService.getAllEnquiries(); // Get all from service

        if (allEnquiries.isEmpty()) {
            System.out.println("No enquiries found in the system.");
            return;
        }

        // Sort by Project Name, then by Date (reversed, newest first)
        allEnquiries.stream()
            .sorted(Comparator.comparing(Enquiry::getProjectName)
                              .thenComparing(Enquiry::getEnquiryDate, Comparator.reverseOrder()))
            .forEach(e -> {
                printEnquiryDetails(e); // Use helper to print
                System.out.println("----------------------------------------");
            });
    }

    public void viewAndReplyToManagedEnquiries() {
        System.out.println("\n--- View/Reply Enquiries (Managed Projects) ---");
        // Get names of projects managed by the current manager
        List<String> myManagedProjectNames = projectService.getProjectsManagedBy(currentUser.getNric())
                .stream()
                // Apply view filters (optional, but consistent with menu description)
                .filter(p -> filterLocation == null || p.getNeighborhood().equalsIgnoreCase(filterLocation))
                .filter(p -> filterFlatType == null || p.getFlatTypes().containsKey(filterFlatType))
                .map(Project::getProjectName)
                .collect(Collectors.toList());

        if (myManagedProjectNames.isEmpty()) {
            // Check if filters caused this
            String filterMsg = (filterLocation != null || filterFlatType != null) ? " matching the current filters." : ".";
            System.out.println("You are not managing any projects" + filterMsg + " For which to view enquiries.");
            return;
        }

        // Get all enquiries and filter by managed project names
        List<Enquiry> managedEnquiries = enquiryService.getAllEnquiries().stream()
                .filter(e -> myManagedProjectNames.contains(e.getProjectName()))
                // Sort by Project Name, then Date Descending
                .sorted(Comparator.comparing(Enquiry::getProjectName)
                                  .thenComparing(Enquiry::getEnquiryDate, Comparator.reverseOrder()))
                .collect(Collectors.toList());

        if (managedEnquiries.isEmpty()) {
            String filterMsg = (filterLocation != null || filterFlatType != null) ? " (matching filters)." : ".";
            System.out.println("No enquiries found for the projects you manage" + filterMsg);
            return;
        }

        // Separate unreplied and replied managed enquiries
        List<Enquiry> unrepliedEnquiries = managedEnquiries.stream()
                .filter(e -> !e.isReplied())
                .collect(Collectors.toList());
        List<Enquiry> repliedEnquiries = managedEnquiries.stream()
                .filter(Enquiry::isReplied)
                .collect(Collectors.toList());

        // --- Handle Unreplied Managed Enquiries ---
        System.out.println("--- Unreplied Enquiries (Managed Projects" + ((filterLocation != null || filterFlatType != null) ? " - Filtered" : "") + ") ---");
        if (unrepliedEnquiries.isEmpty()) {
            System.out.println("(None)");
        } else {
            // Display for selection
            for (int i = 0; i < unrepliedEnquiries.size(); i++) {
                Enquiry e = unrepliedEnquiries.get(i);
                System.out.printf("%d. ", i + 1); // Print number first
                printEnquiryDetails(e); // Use helper
                System.out.println("---"); // Separator
            }
            // Prompt for reply
             int choice = getIntInput("Enter the number of the enquiry to reply to (or 0 to skip): ", 0, unrepliedEnquiries.size());

            if (choice >= 1) {
                Enquiry enquiryToReply = unrepliedEnquiries.get(choice - 1);
                System.out.print("Enter your reply: ");
                String replyText = scanner.nextLine().trim();
                // Set reply using Enquiry object's method
                if (enquiryToReply.setReply(replyText, currentUser.getNric(), DateUtils.getCurrentDate())) {
                    System.out.println("Reply submitted successfully.");
                    enquiryService.saveEnquiries(enquiryService.getAllEnquiries()); // Save changes
                } else {
                    System.out.println("Reply not submitted.");
                }
            } else if (choice != 0) {
                 System.out.println("Invalid choice.");
            }
             // If choice is 0, do nothing (skip)
        }

        // --- Display Replied Managed Enquiries ---
        System.out.println("\n--- Replied Enquiries (Managed Projects" + ((filterLocation != null || filterFlatType != null) ? " - Filtered" : "") + ") ---");
        if (repliedEnquiries.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (Enquiry e : repliedEnquiries) {
                printEnquiryDetails(e); // Use helper
                System.out.println("----------------------------------------"); // Separator
            }
        }
    }

    // Helper method to print enquiry details consistently
    private void printEnquiryDetails(Enquiry e) {
         User applicant = userService.findUserByNric(e.getApplicantNric());
         String applicantName = applicant != null ? applicant.getName() : "N/A";
        System.out.printf("ID: %s | Project: %-15s | Applicant: %s (%s) | Date: %s\n",
                e.getEnquiryId(),
                e.getProjectName(),
                e.getApplicantNric(),
                applicantName, // Show name if found
                DateUtils.formatDate(e.getEnquiryDate()));
        System.out.println("   Enquiry: " + e.getEnquiryText());
        if (e.isReplied()) {
             User replier = userService.findUserByNric(e.getRepliedByNric());
             String replierName = replier != null ? replier.getName() : "N/A";
             String replierRole = replier != null ? " (" + replier.getRole().toString().replace("HDB_", "") + ")" : ""; // Show role briefly

            System.out.printf("   Reply (by %s%s on %s): %s\n",
                    e.getRepliedByNric() != null ? e.getRepliedByNric() : "N/A",
                    replierRole, // Add role info
                    e.getReplyDate() != null ? DateUtils.formatDate(e.getReplyDate()) : "N/A",
                    e.getReplyText());
        } else {
            System.out.println("   Reply: (Pending)");
        }
    }
}
```

Controllers/ManagerController.java
```java
package Controllers;

import java.util.Scanner;
import Models.User;
import Services.IApplicationService;
import Services.IEnquiryService;
import Services.IOfficerRegistrationService;
import Services.IProjectService;
import Services.IUserService;

// Main controller for Manager role, delegates actions to specific controllers
public class ManagerController extends BaseController {

    // Hold instances of the specialized controllers
    private final ProjectManagerController projectManagerController;
    private final OfficerRegistrationManagerController officerRegManagerController;
    private final ApplicationManagerController applicationManagerController;
    private final WithdrawalManagerController withdrawalManagerController;
    private final ReportManagerController reportManagerController;
    private final EnquiryManagerController enquiryManagerController;

    public ManagerController(IUserService userService, IProjectService projectService,
                             IApplicationService applicationService, IOfficerRegistrationService officerRegistrationService,
                             IEnquiryService enquiryService, // Enquiry service needed by multiple sub-controllers
                             User currentUser, Scanner scanner, AuthController authController) {
        super(userService, projectService, applicationService, officerRegistrationService, currentUser, scanner, authController);

        // Instantiate the specialized controllers, passing necessary dependencies
        this.projectManagerController = new ProjectManagerController(userService, projectService, applicationService, officerRegistrationService, enquiryService, currentUser, scanner, authController);
        this.officerRegManagerController = new OfficerRegistrationManagerController(userService, projectService, applicationService, officerRegistrationService, enquiryService, currentUser, scanner, authController);
        this.applicationManagerController = new ApplicationManagerController(userService, projectService, applicationService, officerRegistrationService, enquiryService, currentUser, scanner, authController);
        this.withdrawalManagerController = new WithdrawalManagerController(userService, projectService, applicationService, officerRegistrationService, enquiryService, currentUser, scanner, authController);
        this.reportManagerController = new ReportManagerController(userService, projectService, applicationService, officerRegistrationService, enquiryService, currentUser, scanner, authController);
        this.enquiryManagerController = new EnquiryManagerController(userService, projectService, applicationService, officerRegistrationService, enquiryService, currentUser, scanner, authController);

         // Propagate filters if needed (though BaseController handles filter application)
         // this.projectManagerController.filterFlatType = this.filterFlatType;
         // ... etc for other controllers if they use filters directly ...
    }

    // --- Delegate methods to specialized controllers ---

    public void createProject() {
        projectManagerController.createProject();
    }

    public void editProject() {
        projectManagerController.editProject();
    }

    public void deleteProject() {
        projectManagerController.deleteProject();
    }

    public void toggleProjectVisibility() {
        projectManagerController.toggleProjectVisibility();
    }

    public void viewAllProjects() {
        projectManagerController.viewAllProjects();
    }

    public void viewMyProjects() {
        projectManagerController.viewMyProjects();
    }

    public void manageOfficerRegistrations() {
        officerRegManagerController.manageOfficerRegistrations();
    }

    public void manageApplications() {
        applicationManagerController.manageApplications();
    }

    public void manageWithdrawalRequests() {
        withdrawalManagerController.manageWithdrawalRequests();
    }

    public void generateApplicantReport() {
        reportManagerController.generateApplicantReport();
    }

    public void viewAllEnquiries() {
        enquiryManagerController.viewAllEnquiries();
    }

    public void viewAndReplyToManagedEnquiries() {
        enquiryManagerController.viewAndReplyToManagedEnquiries();
    }

    // applyFilters is handled by BaseController and accessed via ManagerView
}
```

Controllers/AuthController.java
```java
package Controllers;

import java.util.Map;
import Models.User;
import Services.DataService; // Still uses static DataService.saveUsers
import Services.IUserService; // Can be injected if DataService.saveUsers is removed
import Utils.NricValidator;

public class AuthController {
    // Can optionally inject IUserService instead of passing map if needed elsewhere
    private final IUserService userService; // Changed to use UserService

    public AuthController(IUserService userService) { // Accept IUserService
        this.userService = userService;
    }

    public User login(String nric, String password) {
        if (!NricValidator.isValidNric(nric)) {
            System.out.println("Invalid NRIC format.");
            return null;
        }
        User user = userService.findUserByNric(nric); // Find user via service
        if (user != null && user.getPassword().equals(password)) {
            return user; // Login success
        } else if (user != null) {
            System.out.println("Incorrect password.");
            return null; // Wrong password
        } else {
            System.out.println("User NRIC not found.");
            return null; // User not found
        }
    }

    // This method modifies User state and triggers a save.
    // It needs access to the *live* user object and a way to save.
    public boolean changePassword(User user, String oldPassword, String newPassword) {
        if (user == null) return false; // Should not happen if called after login

        // Verify old password
        if (user.getPassword().equals(oldPassword)) {
            // Validate new password
            if (newPassword != null && !newPassword.isEmpty()) {
                if (newPassword.equals(oldPassword)) {
                     System.out.println("New password cannot be the same as the old password. Password not changed.");
                     return false;
                }
                // Update password on the User object
                user.setPassword(newPassword);

                // Save the updated user data
                // Ideally, use userService.saveUsers(userService.getAllUsers())
                // But for minimal change, keep using the static DataService method
                DataService.saveUsers(userService.getAllUsers()); // Save ALL users

                System.out.println("Password changed successfully. Please log in again.");
                return true; // Indicate success (caller should handle logout)
            } else {
                 System.out.println("New password cannot be empty.");
                 return false;
            }
        } else {
            System.out.println("Incorrect old password.");
            return false;
        }
    }
}
```

BTOApp.java
```java
import java.util.List;
import java.util.Map;
import java.util.Scanner;

import Models.User;
import Models.Project;
import Models.BTOApplication;
import Models.Enquiry;
import Models.OfficerRegistration;

import Controllers.*; // Import all controllers
import Services.*; // Import all services (including interfaces)

import Views.ApplicantView;
import Views.BaseView;
import Views.OfficerView;
import Views.ManagerView;

public class BTOApp {

    // Service Instances
    private IUserService userService;
    private IProjectService projectService;
    private IApplicationService applicationService;
    private IEnquiryService enquiryService;
    private IOfficerRegistrationService officerRegistrationService;

    // AuthController and Scanner
    private AuthController authController;
    private Scanner scanner;

    public BTOApp() {
        scanner = new Scanner(System.in);
        // Instantiate services
        userService = new UserService();
        projectService = new ProjectService();
        applicationService = new ApplicationService();
        enquiryService = new EnquiryService();
        officerRegistrationService = new OfficerRegistrationService();
    }

    public void initialize() {
        System.out.println("Initializing BTO Management System...");

        // Load data using services
        Map<String, User> loadedUsers = userService.loadUsers();
        List<Project> loadedProjects = projectService.loadProjects(loadedUsers); // Pass users for validation
        // Pass projects to loadApplications for unit adjustments
        Map<String, BTOApplication> loadedApplications = applicationService.loadApplications(loadedProjects);
        List<Enquiry> loadedEnquiries = enquiryService.loadEnquiries();
        // Pass users and projects for validation during registration load
        Map<String, OfficerRegistration> loadedOfficerRegistrations = officerRegistrationService.loadOfficerRegistrations(loadedUsers, loadedProjects);

        // Perform initial data synchronization
        DataService.synchronizeData(userService, projectService, applicationService, officerRegistrationService);

        // Initialize AuthController with the user service
        authController = new AuthController(userService);

        System.out.println("Initialization complete. System ready.");
    }

    public void run() {
        User currentUser = null;
        while (true) {
             // Synchronize data before each menu display iteration
             // This ensures controllers operate on the latest consistent state
             DataService.synchronizeData(userService, projectService, applicationService, officerRegistrationService);

            currentUser = loginScreen(); // Attempt login

            if (currentUser != null) {
                // User logged in successfully, show the appropriate menu
                showRoleMenu(currentUser);
                // After menu loop finishes (logout), reset currentUser
                currentUser = null;
                System.out.println("\nReturning to Login Screen...");
            } else {
                // Login failed
                System.out.print("Login failed. Try again? (yes/no): ");
                String retry = scanner.nextLine().trim().toLowerCase();
                if (!retry.equals("yes")) {
                    break; // Exit the main loop if user doesn't want to retry
                }
            }
        }
        // Save all data on exit
        System.out.println("Exiting application and saving data...");
        DataService.saveAllData(userService, projectService, applicationService, enquiryService, officerRegistrationService);
        System.out.println("Exiting complete.");
    }

    private User loginScreen() {
        System.out.println("\n--- BTO Management System Login ---");
        System.out.print("Enter NRIC: ");
        String nric = scanner.nextLine().trim().toUpperCase();
        System.out.print("Enter Password: ");
        String password = scanner.nextLine(); // Read password

        // Perform login using AuthController
        User user = authController.login(nric, password);
        if (user != null) {
            System.out.println("Login successful! Welcome, " + user.getName() + " (" + user.getRole() + ")");
        }
        // Return the user object (null if login failed)
        return user;
    }

    // Show menu based on User Role
    private void showRoleMenu(User user) {
        BaseView view; // The view to display
        // No longer need a single BaseController instance here, as views take specific controllers

        switch (user.getRole()) {
            case APPLICANT:
                // Instantiate ApplicantController (which holds its sub-controllers)
                ApplicantController appController = new ApplicantController(
                        userService, projectService, applicationService, officerRegistrationService, enquiryService,
                        user, scanner, authController);
                // Pass the main ApplicantController to the ApplicantView
                view = new ApplicantView(scanner, user, appController, authController);
                break;
            case HDB_OFFICER:
                // Instantiate OfficerController (which holds its sub-controllers and inherits from ApplicantController)
                 OfficerController offController = new OfficerController(
                         userService, projectService, applicationService, officerRegistrationService, enquiryService,
                         user, scanner, authController);
                 // Pass the main OfficerController to the OfficerView
                 view = new OfficerView(scanner, user, offController, authController);
                break;
            case HDB_MANAGER:
                // Instantiate ManagerController (which holds its sub-controllers)
                 ManagerController manController = new ManagerController(
                         userService, projectService, applicationService, officerRegistrationService, enquiryService,
                         user, scanner, authController);
                 // Pass the main ManagerController to the ManagerView
                 view = new ManagerView(scanner, user, manController, authController);
                break;
            default:
                // Should not happen with defined roles
                System.err.println("FATAL Error: Unknown user role encountered: " + user.getRole());
                return; // Exit this method if role is unknown
        }
        // Display the menu using the selected view
        view.displayMenu();
    }

    public static void main(String[] args) {
        BTOApp app = new BTOApp();
        try {
            app.initialize(); // Load data and set up services
            app.run();        // Start the login and menu loop
        } catch (Exception e) {
             // Catch unexpected errors in the main flow
             System.err.println("An unexpected critical error occurred in the main application thread: " + e.getMessage());
             e.printStackTrace();
             // Optionally save data here as well in case of crash?
             // DataService.saveAllData(...);
        } finally {
             // Ensure scanner is closed if necessary, though System.in usually isn't closed.
             app.scanner.close();
        }
         System.exit(0); // Ensure application exits cleanly
    }
}
```